---
title: "MySQL进阶（四）索引"
date: 2022-03-17T14:21:14+08:00
draft: false
categories: ["技术"]
tags: ["MySQL"]
---

## 索引的概念与意义

索引是数据库中最重要的概念之一，它是一种特殊的查询表，可以被数据库搜索引擎用来加速数据的检索。

索引可大大提高SELECT和WHERE的查询速度，不过会降低UPDATE和INSERT的速度。

可以理解为查阅某本书的章节名，目录就是一个索引，可以通过目录快速找到有没有自己想要的内容，而不必翻遍这本书。

通过`CREATE INDEX`创建索引：


## 索引的多种实现方式

索引有很多种实现方式，其中叫为简单的有哈希表、有序数组、搜索树。

### 哈希表

哈希表的概念不做介绍，理论上它可以在$O(1)$时间内找到这个key对应的元素，然而多个key在hash之后出现同一个值的话，也就是哈希冲突，会挂在后面退化成链表，这个倒是有解决方法。

但是哈希表不能自持快速的范围查询，比如查询[a,b]之间的数据，哈希表就只能$O(n)$

哈希表做等值kv查询的效率不错，比如NoSQL、Memcached的一些，但是范围查询表现不佳。

### 有序数组

有序数组字在等值和范围查询的效率都很高，但是缺点也非常明显，插入和删除的复杂度很高。

适用于很少插入删除但是查询很多的场景，也就是静态存储，比如往年的一些数据，很少修改经常查询的，可以使用有序数组。

### 二叉搜索树

二叉搜索树的查询复杂度是$O(log N)$，当然为了保持这个效率还需要维持平衡，更新的复杂度也是$O(log N)$

但是大部分实际情况都不会用二叉搜索树，因为实际数据量较大时，会造成二叉树高度过高，底部节点的访问需要读取很多数据块。

更多的是使用N叉树。

### 跳表

Redis用的就是跳表，跳表的原理见`跳表.md`

### B+树

MySQL的InnoDB采用的就是B+树，其基本原理之后再补充。

## InnoDB索引结构

聚簇索引：存的是主键，叶子节点的内容是整行数据
二次索引：存的是非主键，叶子节点的内容是主键

每个索引都会新建一个B+树来存储。

> 如果查询语句是关于主键的查询

比如：
```sql
select * from table where ID=1
```
就需要查找聚簇索引

> 如果查询的是非主键

比如：

```sql
select * from table where c1=2
```

就需要先去查找c1这个字段的索引，得到主键值，然后回聚簇索引里搜索具体的一行数据。这个过程称为**回表**。

> 如果范围查询非主键

比如：

```sql
select * from table where c1 between 1 and 3
```

首先会在字段c1的索引表上找c1=1的记录，取得主键ID，然后回聚簇索引里取对应的行，接下来找c1索引的下一个值，取得主键ID...一直找到c1索引的c1值大于3，循环结束。

这种范围查询的情况会产生很多次回表。


这也说明了，我们应该尽量用主键进行查询。

## 联合索引

联合多个键进行索引，好处有：
1. 减少开销，根据最左匹配匹配，创建一个联合索引相当于建立了多个索引
2. 如果是覆盖，也就是只通过一些索引的列选取索引的其他列，可以不用回表，提高性能
3. 如果是where...and查询，只有单条索引就需要筛选很多元素然后回表，但是联合索引可以让筛选出的量大大减少。


## 一些补充

### 覆盖索引

覆盖索引（Covering Index）就是可以从非主键索引中就能查到的记录，而不需要回表。从而提升性能。

比如我们有一个需求就是通过查询c1获得c2的内容，如果正常的建立c1和主键ID的索引，那么每次查询一行都要回表。

而可以建立联合索引：

```sql
ALTER TABLE t DROP INDEX c1;
ALTER TABLE t ADD INDEX I_c1_c2(c1, c2);
```

之后再通过c1查询c2的话：

```sql
select col1,col2 from test where col1=1 and col2=2;
```

在联合索引上找到c1，就可以直接返回c2

### 关于自增主键

表中可以定义自增主键：

```sql
NOT NULL PRIMARY KEY AUTO_INCREMENT
```

插入记录不需要指定ID，数据库会自动获取ID最大值+1作为其主键然后插入。

很多业务都可以用自增主键，节约空间从而提高效率。

除了kv场景，一般用业务字段做主键。

### 前缀索引

可以通过`col(n)`的语法来为该列的前n个字符创建索引，这样创建的索引文件会小很多。对`BLOB`和`TEXT`创建索引也必须采用这种方式。

### 最左前缀原则

建立**联合索引**的时候，索引内的字段顺序，可以通过调整顺序来少维护索引，但是必须保持最左前缀原则。

比如该表：

```sql
CREATE TABLE test (
    id         INT NOT NULL,
    last_name  CHAR(30) NOT NULL,
    first_name CHAR(30) NOT NULL,
    PRIMARY KEY (id),
    INDEX name (last_name,first_name)
);
```

为`last_name`和`first_name`创建了一个联合索引`name`，这个索引支持`last_name`和`first_name`的联合查询，也支持只有`last_name`的查询，但是不支持只有`first_name`的查询

联合索引的任何一个索引的最左前缀都会被优化器用于查找列。比如，一个包含三列的联合索引 (col1, col2, col3)，索引会生效于 (col1), (col1, col2), and (col1, col2, col3)，但是其他情况的组合则不会生效。


### 索引下推

MySQL5.6之后引入索引下推，在遍历的过程中可以直接过滤掉不满足条件的记录，从而减少回表次数。

### 普通索引还是唯一索引

### 多个索引，MySQL会选择哪个

### 字符串字段的前缀索引

正常情况来说，给字符串字段加索引，会给整个字符串建立索引，但有有些时候字符串很长，比较浪费空间，我们没必要全部存，存一部分即可。

比如有
```
123454@gmail.com
123455@gmail.com
123456@gmail.com
123457@gmail.com
```

我们只需要将前缀存在索引里，比如对于这个情况，我们存前6位即可区分出所有数据，这样既可以节约空间，又可以提高匹配效率。

```sql
alter table t add index index1(email(6));
```

如果出现数据不同只是前缀一样的情况，回表的时候会多访问一些次数，所以最好这种情况不要占比太多，也就是说前缀长度的选取有讲究。

比如可以通过下面的sql参看选取各个长度的索引的不同值，设定一个可接受的比例然后选取合适的前缀长度。

```sql
select
  count(distinct left(email,4)）as L4,
  count(distinct left(email,5)）as L5,
  count(distinct left(email,6)）as L6,
  count(distinct left(email,7)）as L7,
from t;
```

除了前缀索引之外，如果一些字符串是后面的不一样前面的一样，比如一个地区的身份证，那么可以考虑倒序存储，每次存的时候倒过来存，查的时候再倒回来。
另一个方式是使用哈希字段，也就在表上再增加一个字段，这个字段是我们需要做索引的字段的哈希值。我们在这个哈希值字段上做索引，这样索引的长度就变成了四个字节。

但是倒序和哈希的缺点是不再支持范围查询。
