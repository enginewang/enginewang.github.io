<?xml version="1.0" encoding="utf-8"?>






<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>王毅诚的博客</title>
        <link>https://yichengme.site/</link>
        <description>这里是王毅诚的博客，分享技术文章和生活经历</description>
        <generator>Hugo 0.91.1 https://gohugo.io/</generator>
        
            <language>zh-CN</language>
        
        
            <managingEditor>engine74396@gmail.com (王毅诚)</managingEditor>
        
        
            <webMaster>engine74396@gmail.com (王毅诚)</webMaster>
        
        
            <copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</copyright>
        
        <lastBuildDate>Thu, 23 Dec 2021 20:22:33 &#43;0800</lastBuildDate>
        
            <atom:link rel="self" type="application/rss&#43;xml" href="https://yichengme.site/rss.xml" />
        
        
            <item>
                <title>返璞归真，博客重新迁移到Hugo</title>
                <link>https://yichengme.site/posts/hello-world/</link>
                <guid isPermaLink="true">https://yichengme.site/posts/hello-world/</guid>
                <pubDate>Tue, 21 Dec 2021 23:08:40 &#43;0800</pubDate>
                
                    <author>engine74396@gmail.com (王毅诚)</author>
                
                <copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</copyright>
                
                    <description>&lt;p&gt;第一次开博客应该是在大二的时候，也就是2018年，用的是Hexo。之后觉得配置太少，想要有发挥的空间，就用当时学的Django写了一个博客网站，再后来又改成了Go+Vue，作为一个前后端分离的单体应用，包含博客的完整的功能，还能有其他拓展。&lt;/p&gt;
&lt;p&gt;这本来应该是博客的最终形态了，然而精力有限，不想折腾markdown渲染和其他各种功能，以及为一些前后端、运维、优化的问题所烦恼，再加上服务器成本也不少，还是希望能够纯粹的写作。&lt;/p&gt;
&lt;p&gt;因此现在又回到了最初的起点，转回了静态网页，这次用Hugo搭建，主题用的是Meme，所谓是从简到繁，又从繁到简。&lt;/p&gt;
&lt;p&gt;之前的博客内容会逐步迁移过来，由于静态网页发文章很方便，会增加更多的内容，敬请期待。&lt;/p&gt;
</description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="https://yichengme.site/categories/%E7%94%9F%E6%B4%BB/">生活</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="https://yichengme.site/tags/hugo/">hugo</category>
                                
                            
                                
                                
                                
                                    <category domain="https://yichengme.site/tags/site/">site</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>分布式系统（二）：共识算法</title>
                <link>https://yichengme.site/posts/distribution-system-2/</link>
                <guid isPermaLink="true">https://yichengme.site/posts/distribution-system-2/</guid>
                <pubDate>Sun, 19 Dec 2021 23:18:18 &#43;0800</pubDate>
                
                    <author>engine74396@gmail.com (王毅诚)</author>
                
                <copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</copyright>
                
                    <description>&lt;h4 id=&#34;拜占庭将军问题&#34;&gt;拜占庭将军问题&lt;/h4&gt;
&lt;p&gt;拜占庭将军问题是分布式领域最复杂的一个容错模型，较好地抽象了分布式系统面临的共识问题。&lt;/p&gt;
&lt;p&gt;假如你是一位拜占庭的将军，需要与其他几个国家的军队做沟通，而信使可能会被杀，可能会被替换，可能某国军队会传递错误信息等等，抽象出来的问题就是，如何在可能有错误发生的情况下，让多个节点达成共识，保持一致。&lt;/p&gt;
&lt;p&gt;拜占庭将军是最困难的一种情况，因为会存在恶意节点行为行为，在某些场景（比如数字货币区块链）只能使用拜占庭容错算法（Byzantine Fault Torerace，BFT），常见的拜占庭算法有口信消息型算法、签名消息型算法、PBFT算法、PoW算法等。&lt;/p&gt;
&lt;p&gt;在计算机分布式系统中，最常使用的还是非拜占庭容错算法，也就是故障容错算法（Crash Fault Tolerance，CFT），解决的是分布式系统中存在故障，但不存在恶意节点的场景。常见的算法有Paxos算法、Raft算法、ZAB协议等，这些协议之后都会讲解。&lt;/p&gt;
&lt;p&gt;不过对于恶性的情况，一般只在区块链中出现，算法有PBFT、PoW等。但是我并没有打算涉足区块链相关的研究，所以这些算法不在讨论范围之内。&lt;/p&gt;
&lt;h4 id=&#34;共识算法的概念&#34;&gt;共识算法的概念&lt;/h4&gt;
&lt;p&gt;共识算法就是用来达成一致性的方法。&lt;/p&gt;
&lt;p&gt;需要满足三个条件：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Termination：保证算法最后可以做出决定，不能是无限循环的&lt;/li&gt;
&lt;li&gt;Validity：最终决议一定来自于其中一个参与的节点&lt;/li&gt;
&lt;li&gt;Agreement：算法完成时，所有节点一定会做出相同的决定&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;FLP定理：完美的共识算法不存在。在非同步的网络环境中，就算只应付一个节点故障，也没有一个共识算法能保证完全正确。&lt;/p&gt;
&lt;p&gt;一般的共识算法分为两类：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Symmetric, no leader&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;所有的节点地位等同，client可以向每一个server发送请求&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;Asymmetric, leader based&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;任一时刻只会有一个leader，leader处理client的请求，其余server只接受leader的决策，client只可以向leader发送请求。&lt;/p&gt;
&lt;h4 id=&#34;paxos算法&#34;&gt;Paxos算法&lt;/h4&gt;
&lt;p&gt;Paxos算法是分布式共识算法的元老，目前最流行的分布式算法都是基于Paxos改进的，所以不得不提。&lt;/p&gt;
&lt;p&gt;兰伯特Lamport提出的Paxos包含两个部分：
一个是Basic Paxos，描述的是多个节点之间如何就一个value达成共识；
一个是Multi-Paxos，描述的是执行多个Basic Paxos实例，为一系列value达成共识。
这一节只说Basic Paxos，Multi-Paxos下一节&lt;/p&gt;
&lt;h5 id=&#34;系统角色&#34;&gt;系统角色&lt;/h5&gt;
&lt;p&gt;提议者（Proposers）：向系统里的其他节点提出v=C，希望大家达成共识。&lt;/p&gt;
&lt;p&gt;接受者（Acceptors）：不发起proposal的节点，接受Proposers的提议。&lt;/p&gt;
&lt;p&gt;学习者（Learner）：不参与投票的过程，被告知投票的结果，接受达成的共识存储保存数据。&lt;/p&gt;
&lt;h5 id=&#34;算法流程&#34;&gt;算法流程&lt;/h5&gt;
&lt;p&gt;分为两个流程：&lt;/p&gt;
&lt;p&gt;第一步：准备阶段&lt;/p&gt;
&lt;p&gt;在提出提案之前，先得到超过半数节点的回应，也就是有半数以上的节点愿意聆听这个Proposer。假设这次要发送的数据是v&lt;/p&gt;
&lt;p&gt;具体的过程：Proposers向所有节点发送&lt;code&gt;Prepare(n)&lt;/code&gt;，n包含了一些元信息，可以比较大小，Acceptors接收到后，与这一轮从其他Proposers里收到的最大的提议N比较。&lt;/p&gt;
&lt;p&gt;准备阶段只需要发送n即可，不需要发送v。&lt;/p&gt;
&lt;p&gt;如果$n&amp;lt;N$，也就是目前的这个提议的n比这一轮已有的最大的N还小，直接无视这个提议。
否则，就认为当前提议更好，如果此时已经发送过了一个返回给之前最大的那个Proposer，就返回一个&lt;code&gt;ack(n, (nx, vx))&lt;/code&gt;，n是这一次的n，nx是之前最大的那个Proposer的n，vx之前最大的那个Proposer的x。如果之前没接受过其他提议，就发送&lt;code&gt;ack(n, (null, null))&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;第二步：接受阶段&lt;/p&gt;
&lt;p&gt;Proposers等待过半的Acceptors返回后，对&lt;code&gt;ack&lt;/code&gt;作出判断，如果里面有节点的&lt;code&gt;ack&lt;/code&gt;返回的nx、vx不为空，就主动放弃，找出里面最大nx的vx，再发送&lt;code&gt;accept(n,vx)&lt;/code&gt;给所有的Acceptors。
如果都为空的话，就传送&lt;code&gt;accept(n,v)&lt;/code&gt;给所有的Acceptors。&lt;/p&gt;
&lt;p&gt;Acceptors收到&lt;code&gt;accept(n,v)&lt;/code&gt;后，不过可能还会收到&lt;code&gt;prepare(n)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Paxos论文描述：
&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1640193486/paxos-8.png&#34; alt=&#34;paxos-8&#34;&gt;&lt;/p&gt;
&lt;p&gt;一些容易想错的地方，进行声明：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;这里的n并不是具体的int，只是为了简单描述算法，实际上这里的n是一种数据结构，但是相互之间可以被比较，并且对于每个节点而言，它们的n必然不相同。
并不是说一个节点只能当Proposer、Acceptor、Learner中的一种，实际上，每个节点都同时具有这三种角色。
Basic Paxos只是对一个值形成决议，并不是多个值。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5 id=&#34;具体例子&#34;&gt;具体例子&lt;/h5&gt;
&lt;p&gt;举一个具体的例子，两个客户端作为提议者，n分别为1和5，v分别为3和7，有三个接受者。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;准备阶段&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;提议者分别发送&lt;code&gt;Prepare(n)&lt;/code&gt;给三个节点，假设说AB先接收到了客户端1的信息，C先接受到了客户端2的信息&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1640193484/paxos-1.jpg&#34; alt=&#34;paxos-1&#34;&gt;&lt;/p&gt;
&lt;p&gt;由于接受者之前没有提案（也可以认为目前的n是无穷小），所以接受到第一个提案后都进行响应，返回&lt;code&gt;ack(n, (null, null))&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1640193485/paxos-2.jpg&#34; alt=&#34;paxos-2&#34;&gt;&lt;/p&gt;
&lt;p&gt;之后AB接受到客户端2传来的&lt;code&gt;Prepare(5)&lt;/code&gt;，5&amp;gt;1，所以会发送准备响应给2。C接受到客户端1传来的&lt;code&gt;Prepare(1)&lt;/code&gt;，1&amp;lt;5，直接无视该请求&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1640193485/paxos-3.jpg&#34; alt=&#34;paxos-3&#34;&gt;&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;接受阶段
由于1、2都收到了多于半数的准备返回响应，并且返回的响应包含的之前最大提案号为空，所以会发送分别接受请求&lt;code&gt;accpet(1, 3)&lt;/code&gt;和&lt;code&gt;accept(5, 7)&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1640193484/paxos-4.jpg&#34; alt=&#34;paxos-4&#34;&gt;&lt;/p&gt;
&lt;p&gt;最后ABC接受到1的确认，由于之前承诺不再接受n小于5的，所以不会变。接受到5的确认后就修改为了5&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1640193485/paxos-5.jpg&#34; alt=&#34;paxos-5&#34;&gt;&lt;/p&gt;
&lt;p&gt;假设另一个例子，在某个顺序AB是n=5,v=7，C是n=1,v=3。此时有一个请求[9, 6]，发送给ABC之后，准备阶段，由于9&amp;gt;5，ABC会接受，并返回
&lt;code&gt;ack(n, (nx, nv))&lt;/code&gt;，具体是AB返回&lt;code&gt;ack(9, (5, 7))&lt;/code&gt;,C返回&lt;code&gt;ack(9, (1, 3))&lt;/code&gt;，那么客户端3由于接受到的返回不为空，就会判断之前最大的n，这里是5，对应的v是7，所以在接受阶段会发送&lt;code&gt;accpet(9, 7)&lt;/code&gt;给所有节点。&lt;/p&gt;
&lt;p&gt;可以参考这个视频：https://www.youtube.com/watch?v=UUQ8xYWR4do&lt;/p&gt;
&lt;h4 id=&#34;multi-paxos&#34;&gt;Multi-Paxos&lt;/h4&gt;
&lt;p&gt;Multi-Paxos并不是一个具体的算法，而是一种思想。指的是基于Mulit-Paxos算法通过多个Basic Paxos实例实现一系列值的共识的算法。（比如Raft算法、ZAB协议等）&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1640193485/paxos-6.jpg&#34; alt=&#34;paxos-6&#34;&gt;&lt;/p&gt;
&lt;p&gt;由于第一阶段收到大多数准备响应的提议者才能发起第二阶段，那么如果多个提议者同时提交提案，可能因为永远无法收到超过半数的准备响应而阻塞。（比如系统中有5个节点，有3个同时发起提案）。
另一个问题是两轮的RPC太消耗性能，也增加了延迟。&lt;/p&gt;
&lt;p&gt;通过引入Leader（领导者）角色以及优化Basic Paxos来解决这两个问题。
Leader节点作为唯一的提议者，这样就不存在提议冲突的情况。
Leader的提案永远是最新的，所以省略掉准备阶段，直接开始接受阶段：
&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1640193485/paxos-7.jpg&#34; alt=&#34;paxos-7&#34;&gt;&lt;/p&gt;
&lt;h5 id=&#34;chubby的multi-paxos实现&#34;&gt;Chubby的Multi-Paxos实现&lt;/h5&gt;
&lt;p&gt;Chubby实现了闭源的Multi-Paxos，通过引入Leader节点。Leader是通过执行Basic Paxos投票产生的。
运行过程中会通过续租的方式延长租期，如果Leader故障，其他节点会选举出新的Leader。
所有的读和写操作也只能在Leader上进行：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;写请求，Leader收到客户端的写请求，作为唯一的Proposer执行Basic Paxos将数据发给所有的节点来达成一致，半数以上的服务器接受了写请求之后，响应给客户端成功&lt;/li&gt;
&lt;li&gt;读请求，很简单，Leader直接查询本地数据返回给客户端即可。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Chubby的ulti-Paxos实现的一些点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Leader本地的数据一定是最新的。&lt;/li&gt;
&lt;li&gt;可以容忍$\frac{n-1}{2}$个节点的故障&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;raft&#34;&gt;Raft&lt;/h4&gt;
&lt;p&gt;Raft算法在Multi-Paxos的思想上进行了简化和限制，是最常用的一个共识算法，也是目前分布式系统的首选共识算法。包括Etcd、Consul等。&lt;/p&gt;
&lt;p&gt;本质上来说，Raft算法是通过一切以领导者为准的方式，实现一系列值的共识和各节点的日志一致。&lt;/p&gt;
&lt;p&gt;强烈推荐看一下这个可视化的Raft，可以加深理解：http://thesecretlivesofdata.com/raft/&lt;/p&gt;
&lt;h5 id=&#34;leader选举&#34;&gt;Leader选举&lt;/h5&gt;
&lt;p&gt;服务器节点的状态分为三种：Leader（领导者）、Follower（追随者）、Candidate（候选人），其中Leader有且只有一个。&lt;/p&gt;
&lt;p&gt;Leader：系统的核心角色，负责处理写请求、管理日志复制和不断与其他节点维持心跳，告知节点Leader存活，不要选举
Follower：普通群众，接受和处理来自Leader的消息，如果Leader心跳超时就主动站出来变成Candidate
Candidate：候选人，向其他节点发送RequestVote的RPC消息，通知其他节点投票，一旦获得了多数投票就晋升为Leader&lt;/p&gt;
&lt;p&gt;Raft算法实现了随机超时时间，每个节点等待Leader的心跳超时时间随机。&lt;/p&gt;
&lt;p&gt;初始时没有Leader，都是Follower，所有节点听不到Leader心跳，超时时间最小的节点首先称为候选者。
它会增加自己的任期编号，给自己先投一票，然后发送RPC请求其他节点投票。
其他节点收到RPC投票消息之后，如果还没有称为候选者，也还没投票的话，就会去投一票，同时增加自己的任期编号。
如果在选举超时时间内获得了大多数的选票，就晋升为Leader。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;关于RPC
Raft算法总共有两类RPC，一个是请求投票RequestVote，一个是日志复制AppendEntries&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;关于timeout
每个节点的等待时间有两种：
① 一个是election timeout，也就是从上一次Leader心跳开始算，如果过了这个timeout还没听到心跳，就自己称为Candidate，这个timeout一般是150-300ms
② heartbeat timeout&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;关于任期
任期由单调递增的数字（任期编号）标识
何时加1？Follow发现Leader心跳超时，将自己任期+1，并发RPC
何时更新？
① 跟随者接受到包含任期的RPC请求后，发现任期比自己的大，就更新自己的任期为更大的任期。
② Leader或者Candidate发现自己的任期编号比其他节点小，会立即降为Follower&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果一个节点收到一个包含任期编号比自己小的RPC请求，会直接无视。
任期编号相同时，日志完整性高的Follow会拒绝投票给日志完整性低的Candidate&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;做法就是RequestVote RPC也会包含Candidate自己最后一个log entry的index和term，如果收到RequestRPC的节点发现这个Candidate最后一个log的term小于自己的term，或者term相等的时候index小于自己的index，那么就不会投票给它。这一策略保证了Leader一定拥有最完整的log entries&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;可能会出现多个Candidate同时发起投票请求，这样的话瓜分选票会导致无法选出半数以上的票，不过Raft通过随机超时时间解决了这一问题，把超时时间都进行了分散。这里的超时时间有两种，一个是Follower和Leader维持的心跳超时，一个是等待选举超时的时间间隔。&lt;/p&gt;
&lt;p&gt;当然还有可能出现的极限情况，比如说刚好两个Candidate各拿到了一半的票，那么陷入阻塞，此时这两个Candidate还会有随机timeout，如果时间过了就重新发送RequestVote&lt;/p&gt;
&lt;p&gt;几个注意的点：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;只有日志最完整的节点才能当Leader，Raft中，日志必须是连续的&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5 id=&#34;日志复制&#34;&gt;日志复制&lt;/h5&gt;
&lt;p&gt;日志项包含指令、索引值、任期编号等。&lt;/p&gt;
&lt;p&gt;第一阶段，Leader通过日志复制AppendEntries，将日志项复制到集群的其他节点上，如果收到了大多数的“复制成功”消息，就把提交这条日志，并返回成功给客户端，否则会返回错误给客户端。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;一开始只是保存日志到本地，比如客户端提交一条&lt;code&gt;SET x = 5&lt;/code&gt;，Leader会先把这条写在日志里，不会修改x的值，等到多数节点返回成功之后才会执行这条指令，把x设为5。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;AppendEntries RPC在每个heartbeat都会发送&lt;/p&gt;
&lt;p&gt;Leader不需要发送消息来告知其他节点提交日志项，Leader的日志复制RPC和心跳包含了当前最大的将被提交的日志项。从而将二阶段简化为一阶段。&lt;/p&gt;
&lt;p&gt;具体的过程为：
&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1640193609/raft-1.jpg&#34; alt=&#34;raft-1&#34;&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;客户端提交一条写请求&lt;/li&gt;
&lt;li&gt;Leader将其存在本地日志上，然后给各个Followers发送日志复制AppendEntries RPC，&lt;/li&gt;
&lt;li&gt;如果有多数的Follower返回成功，Leader就将日志进行提交&lt;/li&gt;
&lt;li&gt;Leader将执行的结果返回给客户端&lt;/li&gt;
&lt;li&gt;之后如果Follower收到新的日志复制RPC或心跳，发现自己有日志项没提交，就进行提交&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;日志一致性的保证：
Leader的日志必然是完整的，以Leader的日志为准来协调各个节点的日志。&lt;/p&gt;
&lt;p&gt;首先通过AppendEntries RPC的一致性检查来找到自己与Follower相同日志项的最大索引值，之前的日志Follower和Leader一致，之后的就不一致了，然后Leader强制Follower覆盖不一致日志。&lt;/p&gt;
&lt;p&gt;引入两个变量：
PrevLogEntry：当前要复制的日志项的前一项的索引值，下面例子中为7
PrevLogTerm：当前要复制的日志项的前一项的任期编号，下面例子中为4&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1640193609/raft-2.jpg&#34; alt=&#34;raft-2&#34;&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Leader发送AppendEntries RPC，包含当前任期编号4、PrevLogEntry=7、PrevLogTerm=4，&lt;/li&gt;
&lt;li&gt;Follower发现自己的索引中没有这一条，返回Failure&lt;/li&gt;
&lt;li&gt;Leader递减要复制的日志项的索引，发送PrevLogEntry=6、PrevLogTerm=3&lt;/li&gt;
&lt;li&gt;Follower能在本地日志找到这一项，返回Success&lt;/li&gt;
&lt;li&gt;Leader知道了自己与该Follower的相同日志的最大索引，复制并更新覆盖索引值之后的日志项。&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;为什么要上一条？因为这一条的话刚写，必然不一样，如果Follower一直和Leader一致，Follower是有Leader的上一条的，但是必然没有Leader新的一条，所以Leader如果从最新的一条发RPC，每一个节点都必然返回Failure，然后递减，非常浪费RPC。
由于大部分节点是能同步日志的，所以第一次都会返回Success，然后Leader把新的一条复制过去即可，对于第一次Failure的个别节点，才会递减找到相同的最大索引值。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5 id=&#34;成员变更&#34;&gt;成员变更&lt;/h5&gt;
&lt;p&gt;在成员进行变更的时候，如何避免出现大于一个的Leader？
比如出现了分区，节点被分为了多个簇，簇与簇之间无法沟通，那么每个簇内都会有一个Leader。&lt;/p&gt;
&lt;p&gt;如果只是为了解决不出现多个Leader的情况，最暴力的方式就是节点全部关闭然后再重新启动，这样投票只会有一个Leader，但是这段时间系统会瘫痪，明显不合理。
最常用的方法是单节点变更，也就是每次只变更一个节点。&lt;/p&gt;
&lt;p&gt;比如当前集群配置为[A, B, C]，现在往里面加入[D, E]，一个一个加，先加D进去：
首先Leader向D同步所有数据，然后Leader更新自己的配置为[A,B,C,D]，将包含新配置的日志项提交到本地状态机，完成单节点变更，之后E加入也一样。
通过单节点变更，可以保证系统只有一个Leader。&lt;/p&gt;
&lt;p&gt;可以看一下Raft作者讲的：
&lt;a href=&#34;https://www.youtube.com/watch?v=vYp4LYbnnW8&#34;&gt;https://www.youtube.com/watch?v=vYp4LYbnnW8&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&#34;总结&#34;&gt;总结&lt;/h4&gt;
&lt;p&gt;以这张图进行总结：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1640193631/%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95-1.png&#34; alt=&#34;共识算法-1&#34;&gt;&lt;/p&gt;
&lt;p&gt;对于上述共识算法进行比较：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Backup，简单备份&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;比如mac的time machine。
首先对于Consistency一致性，是无法保证的，一旦改变当前的文件，备份的旧版本和目前的会不一致。
Transaction事务也只能是weak。
Latency（时延）低、Throuput（吞吐量）高，因为读写的时候不需要运行协议，直接读取即可。
Data loss，如果没备份完，系统失效了，那最新的资料会遗失。
Failover 故障恢复，系统恢复的这段时间系统是不能工作的。&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;Master/Salve 主从模式&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;读写请求都在master上进行，master将更新 的数据写到slave上。类似Dropbox。&lt;/p&gt;
&lt;p&gt;Consistency：可以实现最终一致性
Transactions：Master支持完整事务
Latency、Throuput：读写的时候都直接在master上完成，所以低时延、高吞吐。
Data loss：可能造成数据丢失
Failover：恢复的时候slave还是可以提供read&lt;/p&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;Master/Master&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Leaderless模式，每一个节点都可以接受读写请求。比如DynamoDB。&lt;/p&gt;
&lt;p&gt;Consistency：可以实现最终一致性
Transactions：只能本地支持
Latency、Throuput：低时延、高吞吐。
Data loss：可能造成数据丢失
Failover：仍能正常运作&lt;/p&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;2PC&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;二阶段模式&lt;/p&gt;
&lt;p&gt;Consistency：强一致性
Transactions：支持完整事务
Latency、Throuput：因为每次都需要两阶段，比较差
Data loss：只要写入后资料达成一致就不会丢失
Failover：仍能正常运作&lt;/p&gt;
&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;Paxos &amp;amp; Raft&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;虽然表中没有raft，实际上raft和paxos也差不多。
Paxos可以认为是优化2PC之后的最优解。&lt;/p&gt;
&lt;p&gt;Consistency：强一致性
Transactions：支持完整事务
Latency、Throuput：需要半数达成一致，相对差一点
Dataloss：只要写入后资料达成一致就不会丢失
Failover：只要有半数的节点存活就可以正常运行。&lt;/p&gt;
&lt;p&gt;参考：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://ithelp.ithome.com.tw/users/20121042/ironman/2792&#34;&gt;https://ithelp.ithome.com.tw/users/20121042/ironman/2792&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://time.geekbang.org/column/intro/100046101&#34;&gt;https://time.geekbang.org/column/intro/100046101&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="https://yichengme.site/categories/%E5%8E%9F%E7%90%86/">原理</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="https://yichengme.site/tags/%E5%88%86%E5%B8%83%E5%BC%8F/">分布式</category>
                                
                            
                                
                                
                                
                                    <category domain="https://yichengme.site/tags/%E7%B2%BE%E9%80%89/">精选</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>分布式系统（一）：CAP及基础理论</title>
                <link>https://yichengme.site/posts/distribution-system-1/</link>
                <guid isPermaLink="true">https://yichengme.site/posts/distribution-system-1/</guid>
                <pubDate>Fri, 19 Nov 2021 00:21:18 &#43;0800</pubDate>
                
                    <author>engine74396@gmail.com (王毅诚)</author>
                
                <copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</copyright>
                
                    <description>&lt;h4 id=&#34;acidbase2pc3pc&#34;&gt;ACID、BASE、2PC/3PC&lt;/h4&gt;
&lt;h5 id=&#34;acid&#34;&gt;ACID&lt;/h5&gt;
&lt;p&gt;在讲ACID之前，先讲本地事务，事务最早在数据库等课程中就接触过，简单来说，事务提供一种“要么什么也不做，要么全做完”的机制。&lt;/p&gt;
&lt;p&gt;ACID特性是数据库事务的基本特征，包括：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Atomicity 原子性&lt;/li&gt;
&lt;li&gt;Consistency 一致性&lt;/li&gt;
&lt;li&gt;Isolation 隔离性&lt;/li&gt;
&lt;li&gt;Durability 持久性&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;合称就是ACID（在英语中正好是酸的意思，之后的BASE碱也与之对应）&lt;/p&gt;
&lt;p&gt;然而分布式事务和本地事务不同，假设有一个操作需要多个机器上执行，要么都执行，要么都不执行。
要保持分布式事务的ACID，方法有二阶段提交协议和TCC。&lt;/p&gt;
&lt;h5 id=&#34;2pc二阶段提交协议&#34;&gt;2PC二阶段提交协议&lt;/h5&gt;
&lt;p&gt;一个事务跨越多个节点，成为分布式事务，为了保持ACID，需要引入一个协调者的角色来统一掌控所有节点的结果。&lt;/p&gt;
&lt;p&gt;整个过程被分为两个阶段：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;准备阶段（投票）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;协调者给每个参与者发送Prepare信息，每个参与者有两种选择：
①返回失败
②本地执行事务返回成功，但不提交。询问之后的所有事务操作都记log，以便之后的恢复。&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;提交阶段（执行）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;如果协调者收到了失败或者超时，就直接给每个参与者发送回滚消息，否则就发送提交（commit）消息。
参与者如果收到提交消息，就提交事务，并释放资源和锁。如果收到回滚消息，就回滚事务，并释放资源和锁。&lt;/p&gt;
&lt;p&gt;二阶段提交协议的缺点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;同步阻塞，从投票开始到提交完成的这段时间，所用的资源被锁死&lt;/li&gt;
&lt;li&gt;单点故障，如果协调者故障了，就会一直阻塞&lt;/li&gt;
&lt;li&gt;数据不一致，第二阶段发送commit时可能部分节点因为故障收不到，导致只有一部分执行了commit。
等&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;之后有提出三阶段协议3PC，对二阶段协议进行了改进，然而由于增加了通信成本，实际用的并不多，就不细讲。&lt;/p&gt;
&lt;h5 id=&#34;tcctry-confirm-cancel&#34;&gt;TCC（Try-Confirm-Cancel）&lt;/h5&gt;
&lt;p&gt;TCC是一个业务层面的协议，需要在业务代码中编写，包含了预留、确认或撤销三个阶段。
核心思想是针对每个操作都要注册一个对其对应的确认操作和补偿操作。
首先是try阶段，先通知各个节点的将要进行的操作。
如果try阶段的回复都是ok，就执行确认操作，通知各个节点要执行操作；如果try阶段有错误或者超时，就执行撤销操作，&lt;/p&gt;
&lt;p&gt;可以说ACID是CAP一致性的边界，也就是最强的一致性。&lt;/p&gt;
&lt;h5 id=&#34;base&#34;&gt;BASE&lt;/h5&gt;
&lt;p&gt;BASE则是追求可用性，是CAP中AP的拓展。&lt;/p&gt;
&lt;p&gt;BASE的核心是基本可用（Basically Available）和最终一致性（Eventually Consistent）&lt;/p&gt;
&lt;p&gt;比如遇到峰值，可以用四板斧解决：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;流量削峰，将访问请求错开，比如多个秒杀商品放在不同的时间开始&lt;/li&gt;
&lt;li&gt;延迟请求，比如买火车票抢票的时候等一段时间系统才处理&lt;/li&gt;
&lt;li&gt;体验降级，比如先用小图片代替原始图片&lt;/li&gt;
&lt;li&gt;过载保护，请求放入队列中排队处理，超时了就直接拒绝，队列满了之后就清除一定的请求。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;目的是在基本可用性上保持妥协，谁也不想牺牲这些服务，但是为了可用性必须这样。&lt;/p&gt;
&lt;p&gt;最终一致性是指所有数据副本在经过一段时间的同步之后，最终能保持一致性。
显示生活中，除了金融等对一致性要求极高的领域，它们会使用强一致性。绝大部分互联网系统都采用最终一致性。&lt;/p&gt;
&lt;p&gt;实现最终一致性的方式用的多的有以下几种：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;读时修复，查询数据的时候如果检测到不同的数据，系统自动修复&lt;/li&gt;
&lt;li&gt;写时修复，写失败的时候先将数据缓存下来，之后定时重传&lt;/li&gt;
&lt;li&gt;异步修复，最常用，通过定时对账来检测副本数据的一致性并修复&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;然而异步修复和读时修复的开销比较大，需要进行一致性对比，而写时修复的开销低。&lt;/p&gt;
&lt;p&gt;如果要设计分布式数据库的一致性的时候，可以采用自定义写一致级别（All、Quorum、One、All）来让用户自主选择业务所适合的一致性级别&lt;/p&gt;
&lt;p&gt;BASE通过牺牲强一致性来获得高可用性。&lt;/p&gt;
&lt;h4 id=&#34;cap&#34;&gt;CAP&lt;/h4&gt;
&lt;p&gt;分布式系统的最大难点之一就是维护各个节点之间的数据状态一致性。
需要通过数据库或者分布式缓存来维护数据的一致性。&lt;/p&gt;
&lt;p&gt;CAP是三个缩写的组合：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;C（Consistency）：数据一致性，分布式系统中，同一份数据可能存在于多个实例中，其中一份的修改必须同步到所有它的备份中。也就是说每一次必然能读到最新写入的数据，或者返回错误。&lt;/li&gt;
&lt;li&gt;A（Availability）：服务可用性，服务在接收到客户端请求时必须要给出响应。在高并发和部分结点宕机的情况下依然可以响应。也就是每一次必然会返回结果，但是不保证是最新的正确的。&lt;/li&gt;
&lt;li&gt;P（Partition tolerance）：分区容忍性，由于网络的不可靠性，位于不同网络分区的结点可能会通信失败，如果能容忍这种情况，那么就满足分区容忍性。也就是说出现问题能够容忍。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;一个分布式系统不可能同时满足这三个基本需求，最多只能满足两项。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;满足CA&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;也就是必然一致而且能够返回正确结果，这样是不存在的，其实就是单Server，不叫分布式系统。&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;满足CP&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;牺牲A，只要系统中有一个Server没更新完，就返回错误，否则就返回正确的最新的值。&lt;/p&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;满足AP&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;牺牲C，也就是只要Server接收到请求就返回目前的值，但是不能保证一定是最新的正确的值。&lt;/p&gt;
&lt;p&gt;分布式系统必须满足分区容忍性，也就是只能从A和P中进行取舍，数据一致性和服务可用性只能满足一个。当然实际情况不可能只顾一个而完全放弃另一个，而是在主要关心一个的前提下尽量满足另一个。&lt;/p&gt;
&lt;p&gt;比较成熟的服务注册与发现有以下几个：Consul、Etcd、Zookeeper、Eureka&lt;/p&gt;
&lt;p&gt;其中Consul、Etcd、Zookeeper满足了CP，而Eureka满足了AP。&lt;/p&gt;
&lt;h4 id=&#34;一致化模型consistency-model&#34;&gt;一致化模型Consistency Model&lt;/h4&gt;
&lt;p&gt;对Consistency的不同程度的要求也衍生出了多种不同的等级模型。根据不同的情况采取不同的模型。&lt;/p&gt;
&lt;p&gt;假设有一场球赛，记分员负责将分数写入主Server，然后会将操作复制到各个replica server，读取分数的话可能是任意一个server。&lt;/p&gt;
&lt;p&gt;k=0,1分别代表主队和客队，如果主队得了一分，记分员操作是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;v = get(k)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;set(k, v+1)&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1640193245/cap-2.png&#34; alt=&#34;cap-2&#34;&gt;&lt;/p&gt;
&lt;p&gt;假设目前比分是2:5&lt;/p&gt;
&lt;h5 id=&#34;strong-consistency&#34;&gt;Strong Consistency&lt;/h5&gt;
&lt;p&gt;对于任何一个人，读到的一定是最新的&lt;/p&gt;
&lt;h5 id=&#34;eventual-consistency&#34;&gt;Eventual Consistency&lt;/h5&gt;
&lt;p&gt;只把结果给其他Server，只能保证最后的时刻会更新到正确的最终值，但是之前读到任何小于结果的得分都有可能，甚至是完全没出现过的得分，比如2:0&lt;/p&gt;
&lt;h5 id=&#34;consistent-prefix&#34;&gt;Consistent Prefix&lt;/h5&gt;
&lt;p&gt;连同操作一起给其他Server，从而保证读到的一定是比赛中的某个比分，历史发生过。&lt;/p&gt;
&lt;h5 id=&#34;bounded-staleness&#34;&gt;Bounded Staleness&lt;/h5&gt;
&lt;p&gt;保证读到的一定是t以内的结果。Bounded=0则为Strong Consistency。Bounded=无穷则为Eventual Consistency。&lt;/p&gt;
&lt;h5 id=&#34;monotonic-reads&#34;&gt;Monotonic Reads&lt;/h5&gt;
&lt;p&gt;可能返回任何结果，但是接下来会持续从同一个replica server中读取，保证每一次都至少会比之前的值新。&lt;/p&gt;
&lt;h5 id=&#34;read-my-writes&#34;&gt;Read My Writes&lt;/h5&gt;
&lt;p&gt;如果某个client对Server进行了set操作，那么之后的get必然是set的值。&lt;/p&gt;
&lt;p&gt;不同的角色，要求的系统模型不一样。
记分员：只有他会写入系统，用Read My Writes
裁判：只能Strong Consistency
报分员：保证是历史正确比分，然后每一次至少比上次新，Consistent Prefix+Monotonic Reads
记者：Bounded Staleness就可以，多等点时间
观众：无所谓，Eventual Consistency都行&lt;/p&gt;
&lt;p&gt;银行的系统必然是Strong Consistency，只能最新。而DNS只要是Eventual Consistency就可以，因为需要快速返回结果，不是最新的也可以接受。&lt;/p&gt;
&lt;h4 id=&#34;quorum-system&#34;&gt;Quorum System&lt;/h4&gt;
&lt;p&gt;Quorum System随着Amazon与2007年发表的&lt;code&gt;Dynamo: Amazon’s Highly Available Key-value Store&lt;/code&gt;论文而提出，这篇论文是NoSQL的代表之作。DynamoDB是一个NoSQL数据库，支持键值和文档数据结构，具有Strongly Consistent和Eventually Consistent。&lt;/p&gt;
&lt;p&gt;之前都是往一个Leader Server里写入，然后复制到replica server里，而我们更需要的是写入的时候任何一个Server都可以，读取的时候也是任何一个Server都可以。
也就是Leaderless Replication&lt;/p&gt;
&lt;p&gt;但是这样做的问题在于，如果两个写入操作的时间比较靠近，很可能出现对于不同的服务器而言，指令到达的时刻顺序不一致，从而错误。&lt;/p&gt;
&lt;p&gt;一种方法是每次写入都加锁，也就是去抢每个replicas server的锁，直到都写完了才释放所有的锁，让下一个写入进入。但是这样的话过于严格，效率低下。&lt;/p&gt;
&lt;p&gt;把条件放松一些。
对于写入操作，当一个client取得w个replicas的Lock才被允许写入。
取得R个replicas的Lock才被允许读。
写入时搭配timestamp。&lt;/p&gt;
&lt;p&gt;只要W+W&amp;gt;N就可以防止同时写的发生，保证不会出现最新的值不明确的情况。这个不解释。&lt;/p&gt;
&lt;p&gt;只要W+R&amp;gt;N就可以防止同时读写的发生，保证不会出现读取的值不是最新值的情况。配合timestamp之后，根据抽屉原理，读的时候至少会读到一台最新的server，从而根据timestamp可以找出它。&lt;/p&gt;
&lt;p&gt;通过Quorum System，可以不必设置primary server、replica server的形式，直接对任一server进行读写，仍然能保证Strong Consistency。&lt;/p&gt;
&lt;p&gt;这样的话，通过使用DynamoDB，Amazon会在世界各个地方的数据中心存放你的数据，进行备份，也能通过local replica进行加速。&lt;/p&gt;
&lt;h5 id=&#34;read-repair和anti-entropy&#34;&gt;Read-Repair和Anti-Entropy&lt;/h5&gt;
&lt;p&gt;如果说有几个节点瘫痪了，导致每个都无法拿到超过一半的锁。&lt;/p&gt;
&lt;p&gt;Read-Repair就是在读取的时候不仅通过timestamp拿到最新的结果，还顺便将最新的结果写回其他的server里去。这种适用于频繁读取的情况。&lt;/p&gt;
&lt;p&gt;另一个方法是Anti-Entropy，也就是单独创建一个process，通过检查replica的版本并将所有server都同步成最新的。适用于读取不频繁的情况。&lt;/p&gt;
&lt;h5 id=&#34;hinted-handoff&#34;&gt;Hinted Handoff&lt;/h5&gt;
&lt;p&gt;故障的server恢复之后，系统会写回这个server，这种做法叫Hinted Handoff。
写失败的请求会缓存到本地硬盘上，并周期性的尝试重传。&lt;/p&gt;
&lt;h5 id=&#34;quorum-nwr&#34;&gt;Quorum NWR&lt;/h5&gt;
&lt;p&gt;对于AP系统，可以保证最终一致性但是无法保证强一致性。如果想满足强一致性，可以借助Quorum NWR。&lt;/p&gt;
&lt;p&gt;Quorum NWR可以根据业务的特点，调整一致性级别。&lt;/p&gt;
&lt;p&gt;三个要素：N、W、R&lt;/p&gt;
&lt;p&gt;N：复制因子，也就是一个集群中，数据有多少个副本，当然不同的数据可能有不同的副本数
W：写一致性级别，成功完成W个副本更新，才完成写操作
R：读一致性级别，读一个数据对象需要读R个副本&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;W + R &amp;gt; N：不会出现并行读写，一定能读到最新值&lt;/strong&gt;
W + W &amp;gt; N：不会出现并行写
W + W &amp;lt;= N：可能出现不一致
W + R &amp;lt;= N：可能会读不到最新的值
R + R &amp;gt; N：&lt;/p&gt;
&lt;h4 id=&#34;分布式系统的时间&#34;&gt;分布式系统的时间&lt;/h4&gt;
&lt;p&gt;通常会采用W+W&amp;lt;=N来尽量保证Availablity，这种情况下如何规避并行写导致的不一致呢。&lt;/p&gt;
&lt;p&gt;一个方式就是要了解两个指令在发出时的先后顺序，而不是到达时的顺序，从而保证一致性。看起来通过发出信号时就附加timestamp可以解决问题，看起来每台机器的时间是一样的，然而实际上并不一定。&lt;/p&gt;
&lt;p&gt;由于每台机器自身的时间并不一定准确，甚至可能会出现接受到信息的timestamp比机器当前时间还要晚的情况（收到来自“未来”的消息），这样就很离谱，明显不合理。&lt;/p&gt;
&lt;h5 id=&#34;lamport-logical-clock&#34;&gt;Lamport Logical Clock&lt;/h5&gt;
&lt;p&gt;在消息里夹带一个timestamp，但是在传递的时候，每个结点接受到timestamp后，会比较自身时间与timestamp的大小，然后选择最大的那个置为新的timestamp，从而保证一定递增。收到的消息的timestamp比本身时间还大的话，就将自己的时间改为timestamp的时间。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;每个参与者最开始都保存一个timestamp=0&lt;/li&gt;
&lt;li&gt;如果在本地发生，timestamp+1&lt;/li&gt;
&lt;li&gt;如果传递这个消息，timestamp+1，然后传递时附带该timestamp&lt;/li&gt;
&lt;li&gt;如果接受这个消息，timestamp = Max(本地Clock, 消息timestamp) + 1&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;（Lamport发明了Latex）&lt;/p&gt;
&lt;h5 id=&#34;vector-clock&#34;&gt;Vector Clock&lt;/h5&gt;
&lt;p&gt;Lamport timestamp会显示两个先后的事件有因果关系，但是实际逻辑上并不一定，可能只是同时平行发生。&lt;/p&gt;
&lt;p&gt;对于N个Node的系统，Vector Clock让每个Node都存储一个长度为N的timestamp vector&lt;/p&gt;
&lt;p&gt;对于$Node_i$而言，存储$Vector_i = {t_0, t_1, ..., t_n}$&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;初始化每个Node的vector中的每个元素都为0&lt;/li&gt;
&lt;li&gt;$Node_i$发生一个事件，$V_i[t_i]+1$&lt;/li&gt;
&lt;li&gt;$Node_i$发生一个发送事件，$V_i[t_i]+1$，并夹带这个vector&lt;/li&gt;
&lt;li&gt;$Node_j$发生一个接受事件，$V_j[t_i] = V_i[t_i]$、$V_j[t_j] = Max(V_j[t_j],V_i[t_i]) + 1$&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;参考：https://ithelp.ithome.com.tw/users/20121042/ironman/2792&lt;/p&gt;
</description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="https://yichengme.site/categories/%E5%8E%9F%E7%90%86/">原理</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="https://yichengme.site/tags/%E5%88%86%E5%B8%83%E5%BC%8F/">分布式</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>Google三驾马车（三）—— Bigtable</title>
                <link>https://yichengme.site/posts/bigtable/</link>
                <guid isPermaLink="true">https://yichengme.site/posts/bigtable/</guid>
                <pubDate>Wed, 27 Oct 2021 00:21:18 &#43;0800</pubDate>
                
                    <author>engine74396@gmail.com (王毅诚)</author>
                
                <copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</copyright>
                
                    <description>&lt;h4 id=&#34;介绍&#34;&gt;介绍&lt;/h4&gt;
&lt;p&gt;为什么需要Bigtable？
需要一个集群支持海量的随机读写，需要支持到每秒百万级别的随机读写。在Bigtable没出之前，使用MySQL集群可以解决一些问题，然而一方面会放弃关系型数据库的很多特征，比如外键约束、跨行跨表的事务等。一方面在扩容的时候不得不翻倍扩容，非常浪费。缩减服务器也非常麻烦。另外，在每次故障恢复的时候也需要人工介入。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1640192906/bigtable-0.png&#34; alt=&#34;bigtable-0&#34;&gt;&lt;/p&gt;
&lt;p&gt;希望的伸缩性是可以随机增加或者去掉人任何数量的服务器，并且进行这些操作时不会使服务暂停。&lt;/p&gt;
&lt;p&gt;Bigtable建立在GFS的架构之上，是一个管理结构化数据的分布式存储系统，可以拓展到非常大的规模，比如跨越数千服务器的PB级别的数据。
Google已经将其用在了很多内部产品中，Bigtable为其提供了一套高性能的可灵活拓展的解决方案。&lt;/p&gt;
&lt;p&gt;在很多方面，Bigtable像是数据库，但相比于以往的系统，Bigtable提供了不一样的接口。它不支持完整的关系型数据模型。可以使用任意字符的行列名对数据进行索引，Bigtable将数据都视为未解释的字符串。&lt;/p&gt;
&lt;p&gt;当然Bigtable也有缺点，一个是放弃了关系模型，不支持SQL；一个是放弃了跨行的事务，只支持单行的事务模型。&lt;/p&gt;
&lt;p&gt;Bigtable的解决方法是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;将存储层搭建在GFS上，通过单Master调度多Tablets的形式，使得集群容易维护，伸缩性好&lt;/li&gt;
&lt;li&gt;通过MenTable+SSTable的底层文件格式，解决高速随机读写的问题&lt;/li&gt;
&lt;li&gt;通过Chubby分布式锁解决一致性的问题&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;数据模型&#34;&gt;数据模型&lt;/h4&gt;
&lt;p&gt;Bigtable是一个稀疏的、分布式的永久存储的多维排序map，这个map通过row key、column key和timestamp进行索引，每个值都是一个未解释的字符串。&lt;/p&gt;
&lt;p&gt;(row: string, column: string, time: int64) -&amp;gt; string&lt;/p&gt;
&lt;p&gt;下图是一个存储网页的table&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;row是url的倒转，比如www.google.com会存为com.google.www，这样的目的是前面的www大家都一样，而且子域名就会主域名靠一起。&lt;/li&gt;
&lt;li&gt;有多列，其中&lt;code&gt;contents:&lt;/code&gt;列存储网页html内容。&lt;code&gt;anchor:&lt;/code&gt;列存储指向这个页面的anchor文字，比如cnnsi.com和my.look.ca有指向www.cnn.com的anchor，就如下图所示存储。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1640192906/bigtable-1.png&#34; alt=&#34;bigtable-1&#34;&gt;&lt;/p&gt;
&lt;h5 id=&#34;rows&#34;&gt;Rows&lt;/h5&gt;
&lt;p&gt;行key是表的主键，可以是任意字符串，最大为64kb，在单行的读写都是原子的。
由于读写总是通过行键，这样的数据库也叫做KV数据库。
Bigtable按行key对数据进行排序，行范围动态分区，每个行的范围被称为tablet，是分布式和负载均衡的单位。&lt;/p&gt;
&lt;h5 id=&#34;column-families-列族&#34;&gt;Column Families 列族&lt;/h5&gt;
&lt;p&gt;每一行的数据需要指定列族，每个列族下不需要指定列，每个数据都可以有自己的列，每一行的列可以不一样。这也就是为什么说Bigtable是稀疏的表：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1640192908/bigtable-2.png&#34; alt=&#34;bigtable-2&#34;&gt;&lt;/p&gt;
&lt;p&gt;列key被分组到了一个集合里，被称为column families，每个column families里的应当是相同类型。必须先创建column families，才能使用列key存储数据。
列key通过&lt;code&gt;family:qualifier&lt;/code&gt;命名。比如存储web的表可以用language当做family，另一种是可以用anchor来当做family，每个列key是一个anchor，qualifier是指向该url的网址，内容是链接文本。
访问控制和硬盘内存的记录都是在列family层级下进行的。
比如Bigtable的开源实现HBase，每一个列族的数据存在同一个HFile文件下。&lt;/p&gt;
&lt;h5 id=&#34;timestamp&#34;&gt;Timestamp&lt;/h5&gt;
&lt;p&gt;Bigtable的每个单元格可以包含相同数据的多个版本，不同的版本通过时间戳进行索引。Bigtable的时间戳是64位的整数。不同版本以递减的形式存储，以便可以首先读取最新版本。&lt;/p&gt;
&lt;p&gt;为了防止变得过于繁重，可以指定个数或过期时间，之前的版本被gc。&lt;/p&gt;
&lt;h4 id=&#34;api&#34;&gt;API&lt;/h4&gt;
&lt;p&gt;Bigtable的API包括创建、删除表和列族，以及修改簇、表、列族元数据等。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;9
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-C++&#34; data-lang=&#34;C++&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// Open the table
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Table&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;T&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;OpenOrDie&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;/bigtable/web/webtable&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;

&lt;span class=&#34;c1&#34;&gt;// Write a new anchor and delete an old anchor
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;RowMutation&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;r1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;T&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;com.cnn.www&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;r1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Set&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;anchor:www.c-span.org&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;CNN&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;r1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Delete&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;anchor:www.abc.com&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;Operation&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;op&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;Apply&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;op&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;r1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-C++&#34; data-lang=&#34;C++&#34;&gt;&lt;span class=&#34;n&#34;&gt;Scanner&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;scanner&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;T&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;ScanStream&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;stream&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;stream&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;scanner&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;FetchColumnFamily&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;anchor&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;stream&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;SetReturnAllVersions&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;scanner&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Lookup&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;com.cnn.www&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;stream&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Done&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;stream&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Next&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;())&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;n&#34;&gt;printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;%s %s %lld %s&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\n&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
  &lt;span class=&#34;n&#34;&gt;scanner&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;RowName&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(),&lt;/span&gt;
  &lt;span class=&#34;n&#34;&gt;stream&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ColumnName&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(),&lt;/span&gt;
  &lt;span class=&#34;n&#34;&gt;stream&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;MicroTimestamp&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(),&lt;/span&gt;
  &lt;span class=&#34;n&#34;&gt;stream&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Value&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;());&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h4 id=&#34;构建块&#34;&gt;构建块&lt;/h4&gt;
&lt;p&gt;Bigtable使用GFS存储日志和数据文件，&lt;code&gt;SSTable&lt;/code&gt;用于存储Bigtable数据，每个SSTable包含一个块序列（每个块64kb），并且SSTable可以被完全的映射到内存中，不需要接触磁盘就可以执行查找和扫描。&lt;/p&gt;
&lt;p&gt;Bigtable依赖于分布式锁Chubby，Chubby包含了5个副本，其中一个被选为master并提供request服务。我后面会专门再讲一下Chubby。&lt;/p&gt;
&lt;p&gt;Bigtable通过Chubby完成以下任务：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;确保每个时刻只有一个master&lt;/li&gt;
&lt;li&gt;存储Bigtable数据的引导位置&lt;/li&gt;
&lt;li&gt;存储Bigtable每个表的列族信息&lt;/li&gt;
&lt;li&gt;存储访问控制列表ACL&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;如果Chubby不可用，那么Bigtable也将不可用&lt;/p&gt;
&lt;h4 id=&#34;实现&#34;&gt;实现&lt;/h4&gt;
&lt;p&gt;Bigtable包含三个主要组件：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;链接到每个客户端的库&lt;/li&gt;
&lt;li&gt;一个master服务器&lt;/li&gt;
&lt;li&gt;多个tablet服务器&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;tablet可以动态的增加删除。&lt;/p&gt;
&lt;p&gt;master的职责：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;负责将tablet分配给tablet服务器&lt;/li&gt;
&lt;li&gt;检测tablet的添加和过期&lt;/li&gt;
&lt;li&gt;平衡Tablet server之间的负载&lt;/li&gt;
&lt;li&gt;对GFS的文件进行gc&lt;/li&gt;
&lt;li&gt;管理Table和列族的Schema变更&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;每个tablet服务器存储一组tablet（通常是10-1000个），&lt;/p&gt;
&lt;p&gt;Bigtable和Tablet Server都不进行数据的存储只负责在线业务，存储工作通过SSTable的数据格式写到GFS上。&lt;/p&gt;
&lt;h5 id=&#34;tablet位置&#34;&gt;Tablet位置&lt;/h5&gt;
&lt;p&gt;通过B+树存储tablet的位置&lt;/p&gt;
&lt;p&gt;定义了一张特殊的表Root tablet专门存放元数据，这个分区不会分裂，存的是元数据里其他Tablets的位置。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1640192904/bigtable-5.jpg&#34; alt=&#34;bigtable-5&#34;&gt;&lt;/p&gt;
&lt;p&gt;第一级存储在Chubby的文件，包含root tablet的位置，root包含metadata tablets，包含了其他所有tablet的位置。tablet不做分割，确保不超过三层。&lt;/p&gt;
&lt;p&gt;举个例子，客户端查询ECOMMERCE_ORDERS业务表行键是A20210101RST的某个记录，客户端查询的具体操作：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1640192906/bigtable-6.png&#34; alt=&#34;bigtable-6&#34;&gt;&lt;/p&gt;
&lt;p&gt;也就是说在具体查找数据之前需要三次网络请求来获得数据的具体位置。一般前几次的查询也会缓存起来，以减少请求次数。&lt;/p&gt;
&lt;p&gt;三层结构可以让Bigtable拓展到足够大，tablet大小限制为128MB，每条记录大约1KB，可以存$2^{34}$个Tablet，也就是160亿个Tablet。&lt;/p&gt;
&lt;p&gt;客户端不需要经过master，让设计更加高可用&lt;/p&gt;
&lt;h5 id=&#34;动态分区&#34;&gt;动态分区&lt;/h5&gt;
&lt;p&gt;Bigtable采用动态区间分区，通过自动去split的方式动态分区。
好比是往箱子里放书，按照书名的字母顺序，一旦箱子装满，就中间一分为二，将下面一半放到一个新的空箱子里去。
如果两个相邻的箱子都很空，就可以将其合并。
&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1640192909/bigtable-4.png&#34; alt=&#34;bigtable-4&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;sstable底层结构&#34;&gt;SSTable底层结构&lt;/h4&gt;
&lt;p&gt;Bigtable的写入数据的过程：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;tablet server先做数据验证，以及权限验证&lt;/li&gt;
&lt;li&gt;如果合法，就以追加写的形式顺序写到GFS&lt;/li&gt;
&lt;li&gt;写入成功后还会写到一张内存表MenTable中&lt;/li&gt;
&lt;li&gt;写入的数据快要超过阈值时，会将内存的MemTable冻结，创建一个新的MemTable，被冻结的MemTable会被转换为SSTable写入到GFS，然后从内存中释放掉。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Major Compaction机制，对SSTable进行合并，把数据压实在一起，比如只留下时间戳最近的三个版本的数据。
读取数据的时候，读取的是MemTable和SSTable的合并在一起的视图。
也就是说并没有直接的修改和删除操作，一旦写入就是不可变的，写入的是数据的一个新版本，后台会定时gc，通过合并SSTable来清楚过期和被删除的数据。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1640192906/bigtable-7.png&#34; alt=&#34;bigtable-7&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;总结&#34;&gt;总结&lt;/h4&gt;
&lt;p&gt;Bigtable包括四个组件：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;负责存储数据的GFS&lt;/li&gt;
&lt;li&gt;负责作为分布式锁和目录服务的Chubby&lt;/li&gt;
&lt;li&gt;复杂提供在线服务的Tablet Server&lt;/li&gt;
&lt;li&gt;复杂调度Tablet和调整负载的Master&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1640192908/bigtable-8.png&#34; alt=&#34;bigtable-8&#34;&gt;&lt;/p&gt;
</description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="https://yichengme.site/categories/%E7%AE%97%E6%B3%95/">算法</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="https://yichengme.site/tags/bigtable/">Bigtable</category>
                                
                            
                                
                                
                                
                                    <category domain="https://yichengme.site/tags/%E5%88%86%E5%B8%83%E5%BC%8F/">分布式</category>
                                
                            
                                
                                
                                
                                    <category domain="https://yichengme.site/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/">大数据</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>Google三驾马车（二）—— MapReduce</title>
                <link>https://yichengme.site/posts/mapreduce/</link>
                <guid isPermaLink="true">https://yichengme.site/posts/mapreduce/</guid>
                <pubDate>Mon, 18 Oct 2021 20:21:18 &#43;0800</pubDate>
                
                    <author>engine74396@gmail.com (王毅诚)</author>
                
                <copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</copyright>
                
                    <description>&lt;h4 id=&#34;介绍&#34;&gt;介绍&lt;/h4&gt;
&lt;p&gt;MapReduce是一个用于处理和生成大型数据集的编程模型和相关实现，它是一个分布式模型，通过一个Map函数将k/v对生存一组中间态的k/v对，然后通过一个reduce函数将所有的中间态k/v对进行聚合。
MapReduce运行在一个大型的商用机器集群上，比如可以在数千台机器上处理大量TB级别的数据。
实际上Google早已将其用于实际的任务，每天有超过1000个MapReduce任务在谷歌的集群上运行。&lt;/p&gt;
&lt;p&gt;面对百亿级别的爬虫数据、日志文件等，常规方法不可能做到时效性，只能采用分布式系统进行并行计算。&lt;/p&gt;
&lt;h4 id=&#34;编程模型&#34;&gt;编程模型&lt;/h4&gt;
&lt;p&gt;输入是一系列k/v对的set，输出也是一系列k/v对的set&lt;/p&gt;
&lt;p&gt;用户需要编写Map和Reduce这两个函数，其中Map函数通过输入pair来产生中间过程的k/v对
接下来会将Key为I的中间值传递给对应处理Key I的Reduce函数
Reduce函数接受一系列的Key为I的值，然后merge在一起，每次只有0或1
具体的见下面的例子。&lt;/p&gt;
&lt;h5 id=&#34;例子&#34;&gt;例子&lt;/h5&gt;
&lt;p&gt;输入文件首先分块，
需要一个Map函数，每个输入文件输入Map进行处理，每个都是并行的，产生对应的输出，输出是一个list形式的Key/Value的键值对。&lt;/p&gt;
&lt;p&gt;假设我们的功能是读取字符出现的次数。
假设输入为&amp;quot;abbac&amp;quot;，被拆成了三个文件，总共也就这三个Key。分别是&amp;quot;ab&amp;quot;,&amp;quot;b&amp;quot;,&amp;quot;ac&amp;quot;，并行输入进Map，三个输出分别为：
(a,1), (b,1)
(b,1)
(a,1), (c,1)&lt;/p&gt;
&lt;p&gt;然后进行reduce操作，对于每个Key，会传入reduce函数进行汇总，去统计每个Key的出现个数。这也是并行的。&lt;/p&gt;
&lt;p&gt;那么经过reduce操作之后，输出为：
(a, 2)
(b, 2)
(c, 1)&lt;/p&gt;
&lt;p&gt;完整的Job由一系列的MapTask和一系列的reduceTask组成。&lt;/p&gt;
&lt;p&gt;下面来说说对于统计字母的功能下，Map和Reduce这两个函数的结构：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-C++&#34; data-lang=&#34;C++&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// Map函数，k指明文件，v是文件内容
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Map&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;k&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;v&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;){&lt;/span&gt;
  &lt;span class=&#34;n&#34;&gt;split&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;v&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;to&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;words&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
  &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;each&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;word&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;w&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;emit&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;w&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;1&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
  &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-C++&#34; data-lang=&#34;C++&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// reduce函数，k是这个字母，v是包含这个字母的map数量
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;reduce&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;k&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;v&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;n&#34;&gt;emit&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;len&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;v&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;MapReduc和GFS都运行在一起，在并行进Map的时候，实际上避免了网络传输，中控通过某些方式能够知道该文件存在哪台主机里，然后在该主机调用Map本地操作，从而减少带宽传输限制。后面reduce只能通过网络。&lt;/p&gt;
&lt;p&gt;最开始是按行存储，然后按列存储，这个过程叫Shuffle，从Map服务器到Reduce服务器，这一过程很消耗网络。&lt;/p&gt;
&lt;h5 id=&#34;类型&#34;&gt;类型&lt;/h5&gt;
&lt;p&gt;&lt;code&gt;map&lt;/code&gt;函数 输入是&lt;code&gt;(k1, v1)&lt;/code&gt;，输出是&lt;code&gt;list(k2, v2)&lt;/code&gt;
&lt;code&gt;reduce&lt;/code&gt;函数 输入是&lt;code&gt;(k2, list(v2))&lt;/code&gt;，输出是&lt;code&gt;list(v2)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;以统计词频为例，这里map的输入是(filename, fileContent)，输出是对于每一个单词为key的k/v列表，比如[&amp;quot;Apple&amp;quot;: 1, &amp;quot;Banana&amp;quot;: 1,...]。
这里reduce的输入就是一个单独单词的一系列值，比如&lt;code&gt;&amp;quot;Apple&amp;quot;, [1, 1, 1,...]&lt;/code&gt;，然后输出是该单词的词频。&lt;/p&gt;
&lt;h5 id=&#34;更多的例子&#34;&gt;更多的例子&lt;/h5&gt;
&lt;p&gt;除此之外还有很多适用于MapReduce的很好的例子。&lt;/p&gt;
&lt;h4 id=&#34;实现&#34;&gt;实现&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1640192780/mapreduce-1.png&#34; alt=&#34;mapreduce-1&#34;&gt;&lt;/p&gt;
&lt;p&gt;分割输入数据，分成M个子集，被调用分布到多台机器上并行处理。之后分割中间key形成R个片（比如通过&lt;code&gt;hash(key) mod R&lt;/code&gt;），reduce调用分布到各个机器上。&lt;/p&gt;
&lt;p&gt;具体步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;分割输入文件为M个片，每个片的大小约16-64M&lt;/li&gt;
&lt;li&gt;一个master，和多个worker，有M个map任务和R个reduce任务将被分配，管理者的一个任务是分配map或者reduce任务给一个空闲的worker&lt;/li&gt;
&lt;li&gt;被分配了map任务的worker需要做的是读取输入片的内容，分析出k/v对，传递给用户自定义的map函数，产生的中间k/v对缓存在内存中。&lt;/li&gt;
&lt;li&gt;缓存在内存中的k/v对通过分割函数写入R个区域，本地的缓存对的位置传送给master，然后master把这些位置传送给reduce worker。&lt;/li&gt;
&lt;li&gt;reduce worker通过远程调用来从map worker的磁盘上读取缓存的内容，reduce worker通过排序使得具有相同key的内容聚集在一起。如果中间数据比内存还大，就需要外排序。&lt;/li&gt;
&lt;li&gt;reduce worker迭代排过序的中间数据，对于每一个唯一的key，把key和相关的value传递给reduce函数，reduce函数的输出被添加到最终的输出文件中&lt;/li&gt;
&lt;li&gt;所有的map和reduce都完成之后，管理者唤醒用户程序，用户程序的MapReduce调用返回到用户代码&lt;/li&gt;
&lt;/ol&gt;
&lt;h5 id=&#34;master的数据结构&#34;&gt;Master的数据结构&lt;/h5&gt;
&lt;p&gt;master首先会存储每个map任务和reduce任务的状态（空闲、进行中、完成）以及工作机器的标识。
master还会存储由map产生的中间文件的区域和大小，然后传给reduce的worker&lt;/p&gt;
&lt;h5 id=&#34;容错&#34;&gt;容错&lt;/h5&gt;
&lt;ol&gt;
&lt;li&gt;worker故障&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;master会定期ping每个worker，如果一段时间内没有收到响应，master就会将该结点标记为failed。正在进行的map或者reduce更是会重设状态，被调给其他worker。
然而，这些worker已经完成的map任务也会重新设置为idle状态，将会调度给其他的worker，这是因为它们的输出会存在故障机器的本地磁盘上，不过已经完成的reduce任务不需要重新运行，因为它们会存在全局文件系统上。&lt;/p&gt;
&lt;p&gt;如果一个map任务在A worker上执行，然后A挂了，被调度给了B worker。所有的在做reduce的worker都会被通知到这个，然后读取对应的中间数据会从B读取。&lt;/p&gt;
&lt;p&gt;MapReduce对大规模的worker故障有弹性。&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;Master故障&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;master会定期将内部的数据结构写到checkpoints里，如果master挂了，可以很容易的从最后一个checkpoints开启一个新的副本。&lt;/p&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;失败时的Semantics&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;即使有故障，也能得到和没故障发生的情况下一样的输出。&lt;/p&gt;
&lt;p&gt;依赖于map和reduce任务提交的原子性&lt;/p&gt;
&lt;h5 id=&#34;本地&#34;&gt;本地&lt;/h5&gt;
&lt;p&gt;带宽是一种相对稀缺的资源，通过GFS存储在cluster的本地磁盘上。大部分输入数据会在本地读取，不消耗网络带宽。&lt;/p&gt;
&lt;h5 id=&#34;任务粒度&#34;&gt;任务粒度&lt;/h5&gt;
&lt;p&gt;map任务被分为了M个片，reduce任务被分为了R个片，M和R实际上会远高于实际的worker机器，&lt;/p&gt;
&lt;p&gt;master将做$O(M+R)$的任务调度，以及保存$O(M*N)$个状态。&lt;/p&gt;
&lt;h5 id=&#34;备份任务&#34;&gt;备份任务&lt;/h5&gt;
&lt;p&gt;有时候可能会出现某个任务运行过久导致严重影响整体性能，比如某个worker机器的磁盘坏了导致非常慢的运行，它依然响应服务器的心跳不能认为是failed，但是运行就是非常慢。
MapReduce有一个备份任务的机制，就是当MapReduce即将完成的时候，也就是大多数任务都做完了，那么就会去备份还没完成的任务，只要原始任务或者备份任务的其中一个做完了就可以。&lt;/p&gt;
&lt;h4 id=&#34;改良拓展性能表现与实验&#34;&gt;改良拓展、性能表现与实验&lt;/h4&gt;
&lt;p&gt;上述已经是一个基本的MapReduce的任务了，一些改进拓展、性能表现与实验就不详细说明了，日后可以研究。&lt;/p&gt;
</description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="https://yichengme.site/categories/%E7%AE%97%E6%B3%95/">算法</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="https://yichengme.site/tags/mapreduce/">MapReduce</category>
                                
                            
                                
                                
                                
                                    <category domain="https://yichengme.site/tags/%E5%88%86%E5%B8%83%E5%BC%8F/">分布式</category>
                                
                            
                                
                                
                                
                                    <category domain="https://yichengme.site/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/">大数据</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>Google三驾马车（一）—— Google File System</title>
                <link>https://yichengme.site/posts/gfs/</link>
                <guid isPermaLink="true">https://yichengme.site/posts/gfs/</guid>
                <pubDate>Mon, 11 Oct 2021 18:00:18 &#43;0800</pubDate>
                
                    <author>engine74396@gmail.com (王毅诚)</author>
                
                <copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</copyright>
                
                    <description>&lt;h4 id=&#34;介绍&#34;&gt;介绍&lt;/h4&gt;
&lt;p&gt;GFS，即Google File System，谷歌文件系统。
它是一种能够用于大型密集型数据的可拓展的分布式文件系统。（大型存储系统），它对于廉价硬件提供了容错机制；对于大量客户的情况能有高表现。&lt;/p&gt;
&lt;p&gt;GFS的设计是由实际的应用程序负载和技术环境驱动的，与传统的文件系统的一些假设不一样。&lt;/p&gt;
&lt;h4 id=&#34;设计&#34;&gt;设计&lt;/h4&gt;
&lt;h5 id=&#34;一些假设&#34;&gt;一些假设&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;软硬件故障是常态而不是例外&lt;/li&gt;
&lt;li&gt;文件是巨大的（多GB级也是普遍的）&lt;/li&gt;
&lt;li&gt;负载包括大的流式读取和小的随机读取&lt;/li&gt;
&lt;li&gt;负载还包括大的顺序的append写入&lt;/li&gt;
&lt;li&gt;大多数文件是通过append而不是overwrite来改变的，一旦写入，就只能读取，而且是顺序读&lt;/li&gt;
&lt;li&gt;放宽了一致性，从而极大简化了文件系统&lt;/li&gt;
&lt;li&gt;引入了原子的追加写，可以并发的追加&lt;/li&gt;
&lt;li&gt;高的持续带宽比低延迟更重要&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;一般用append，GFS对其一致性有保证，最好不用write&lt;/p&gt;
&lt;h5 id=&#34;接口&#34;&gt;接口&lt;/h5&gt;
&lt;p&gt;接口方面支持通用的create、delte、open、close、read、write。并且还有snapshot和append操作。
snapshot以低成本创建文件或者目录的副本，append允许多个客户端并发的追加同一个文件，保证原子性。
对于实现多路合并以及生产者-消费者模型很有用。&lt;/p&gt;
&lt;h5 id=&#34;架构&#34;&gt;架构&lt;/h5&gt;
&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1640192564/gfs-1.png&#34; alt=&#34;gfs-1&#34;&gt;&lt;/p&gt;
&lt;p&gt;一个GFS集群由一个master结点和多个chunk sever构成，并被多个客户端访问。它们通常都是普通的Linux机器。&lt;/p&gt;
&lt;p&gt;GFS把文件切割为若干固定长度的Chunk块并存储，每个块的大小是64MB，在创建块时，对于每一个Chunk，master还会为其分配一个64位的全局唯一的Handle句柄。为了保证Chunk的可用性，每个块都会被复制到多个chunk server上，默认存储三个副本。&lt;/p&gt;
&lt;p&gt;master维护所有文件系统的元数据，包括namespace、访问控制信息、从文件到chunk的映射、以及块的当前位置。它还控制系统范围内的活动，比如chunk的租约管理、孤立chunk的gc、chunk server之间的chunk迁移。master定期与chunkserver维持心跳通信，给chunkserver指令以及接受它们的状态。客户端和chunkserver都不需要缓存文件数据，从而简化系统，唯一可能要缓存的可能就是客户机会缓存一下元数据。&lt;/p&gt;
&lt;h5 id=&#34;single-master&#34;&gt;Single Master&lt;/h5&gt;
&lt;p&gt;设立一个master可以极大的简化系统的设计，可以很方便地进行全局信息的管理。然而单一的master很容易成为系统的瓶颈，所以只能让其尽可能少的参与读写。客户端从来不从master中读写文件数据，而是向master询问它需要的文件在哪，然后访问这些chunkserver去进行文件交互。&lt;/p&gt;
&lt;p&gt;下面解释一下交互过程，首先客户端借助固定的块大小，将文件名和偏移量转换为块索引，然后向master发送包含文件名和块索引的请求，master返回一个chunk句柄和副本的位置。接下来客户端会向其中一个（往往是最近的）存储着该文件副本的chunkserver发送请求，之后对同一个chunkserver的交互不需要master的参与。事实上客户端通常一次会请求多个块。&lt;/p&gt;
&lt;h5 id=&#34;chunk-size&#34;&gt;Chunk Size&lt;/h5&gt;
&lt;p&gt;选择的是64MB，比典型文件系统的块大得多，相对于小的chunk size，更大的chunk size的优势在于：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;减少客户端请求的chunk数量，减少客户端与master的交互需求。&lt;/li&gt;
&lt;li&gt;大的chunk可以让客户端执行很多操作，通过较长时间与chunkserver的持续的tcp连接来减少网络开销&lt;/li&gt;
&lt;li&gt;减少了chunk的个数，从而减少了存储在master的元数据的大小&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;当然，大的chunk size也有缺点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;可能会出现更多客户端访问一个chunk从而导致这个chunk成为hot spots。一般来说还好，不过如果某个可执行文件被写入了某个chunk，然后在数百台机器上同时启动，那个chunkserver就很容易超载。一个解决方法是将可执行文件复制更多份，并使批队列系统错开启动时间。还有一个解决方法是允许客户机从其他客户机读取数据。&lt;/li&gt;
&lt;/ol&gt;
&lt;h5 id=&#34;metadata&#34;&gt;Metadata&lt;/h5&gt;
&lt;p&gt;元数据包含文件和chunk的namespace、从文件到块的映射、以及每个chunk副本的位置，所有的元数据都存储在master的内存中。前面两个也通过日志的方式存储在本地磁盘中，实现持久性存储，顺带也复制在远程机器上备份。这个主要是保证即使master崩溃了也不会出现不一致。
至于chunk副本的位置，master并不会持久地存储，而是在master启动的时候对每个chunkserver进行轮询，或者在新的chunkserver加入集群时询问。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;内存中的数据结构
元数据存储在内存中，所以访问起来很快。
master还会在后台周期性的扫描整个状态，用于实现gc、chunkserver故障时的重新复制、块迁移来平衡负载等。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;可能会认为说元数据存在master内存中，整个系统的容量会受到master内存的限制，实际上chunk由于比较大，个数不会那么多，master也只需要存每个chunk的不到64字节的元数据，所以还好。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;chunk位置
前面说了master通过启动时的轮询获得信息，并且还会保持一个心跳来监听各个chunkserver的状态。
由于集群很大，如果在master上持久化在本地存储chunk副本位置，之后变动会很多（改名、宕机、重启等），并且实际上chunkserver才是对chunk有着最终决定权，在master上维护一个一致性的视图是没有意义的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;操作日志
操作日志包含了元数据发生重大变化的历史记录，是GFS的核心。它是元数据的唯一持久性记录，也作为定义并发操作顺序的逻辑时间线。操作日志需要被可靠地存储。
如果系统崩了，master就会重新执行log来恢复GFS，所以log也不宜过大，以免启动时间过长。会先找到重载的checkpoint然后执行之后的日志记录。检查点是一种类似B树的紧凑形式，加快恢复速度。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;一致性模型&#34;&gt;一致性模型&lt;/h5&gt;
&lt;p&gt;GFS并不保持一个严格的一致性，而是保持一个相对宽松的一致性&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;GFS保证的
命名空间是原子的，保证操作日志是全局的顺序正确的。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;数据更改之后的文件区域的状态：&lt;/p&gt;
&lt;p&gt;文件数据更改之后，会定义一个region，其状态取决于变化的种类（write/append）、是否并行、成功还是失败。&lt;/p&gt;
&lt;p&gt;如果它是一致的，客户端会看到变化写入的内容。
如何区分已定义区域和未定义区域。&lt;/p&gt;
&lt;p&gt;在一次成功的顺序变化后，GFS会：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在chunk的所有副本上以相同的顺序应用这些变化&lt;/li&gt;
&lt;li&gt;使用chunk版本号来检测副本&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;应用程序应当append而不是write。&lt;/p&gt;
&lt;h4 id=&#34;系统交互&#34;&gt;系统交互&lt;/h4&gt;
&lt;p&gt;描述客户端、master、chunkserver如何进行交互，完成数据更改、原子追加和快照。&lt;/p&gt;
&lt;h5 id=&#34;租约和数据更改顺序&#34;&gt;租约和数据更改顺序&lt;/h5&gt;
&lt;p&gt;数据更改（mutations）就是改变chunk的内容或者元数据的操作，比如write或append。数据更改在chunk副本上执行。
使用租约（leases）来维持副本之间的一致的变化顺序。master会将租约授权给其中一个副本，称之为该chunk的主服务器（primary）。主服务器会为这个chunk的所有更改进行顺序排序，其余的所有副本都遵守这个顺序进行更改。
租约机制的目的也是减少master的管理开销，租约的初始时间是60s，不过主要chunk发生了改变，primary就可以向master请求拓展，这些请求被承载在心跳信息上。&lt;/p&gt;
&lt;p&gt;下图是写操作的控制流与详细的步骤
&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1640192564/gfs-2.png&#34; alt=&#34;gfs-2&#34;&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;客户端询问master哪个chunkserver持有当前chunk的租约，以及其他副本的位置。如果没有服务器有租约，master就选择一个副本服务器分给它租约&lt;/li&gt;
&lt;li&gt;服务器返回primary和副本chunkserver的位置，客户端把它们存在缓存中，如果未来短期内再次访问就不需要请求master。除非primary不可达或者primary告知客户端它没有租约了。&lt;/li&gt;
&lt;li&gt;客户端知道副本位置后，将数据push进所有的副本中，可以按照任何顺序。每个chunkserver将数据存储在一个内部的LRU缓存中&lt;/li&gt;
&lt;li&gt;一旦所有的副本都确认接受到了数据，客户端就向primary发送写请求，标识了之前push的数据，primary会分配序列号给这些mutations，提供必要的序列化&lt;/li&gt;
&lt;li&gt;primary将写请求转发给各个备用副本，每个备份副本按照序列号执行更改&lt;/li&gt;
&lt;li&gt;备份副本回复primary表示已经完成了操作&lt;/li&gt;
&lt;li&gt;primary响应客户端，任何遇到的错误也会报告&lt;/li&gt;
&lt;/ol&gt;
&lt;h5 id=&#34;数据流&#34;&gt;数据流&lt;/h5&gt;
&lt;p&gt;数据流和控制流解耦，为了充分利用每台机器的带宽，数据被线性的沿着chunkserver链进行推送，而不是分布在拓扑网络中，这样每台机器的带宽就可以被充分利用，每台机器将数据转发到网络拓扑中“最近的”没有接收到它的机器。（感觉像Prim算法）&lt;/p&gt;
&lt;h5 id=&#34;原子追加&#34;&gt;原子追加&lt;/h5&gt;
&lt;p&gt;GFS提供了原子追加（atomic record appends）操作。
传统的写操作需要提供数据和偏移量，如果出现并行的情况就很可能会出现来自多个客户端的碎片。
在GFS中，客户端只提供数据，GFS会选择偏移量并将其返回给客户端，类似于Unix的&lt;code&gt;O_APPEND&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;大量使用record append，如果是传统的写操作，为了保持一致性就只能使用分布式锁，代价很昂贵。&lt;/p&gt;
&lt;h5 id=&#34;snapshot快照&#34;&gt;Snapshot快照&lt;/h5&gt;
&lt;p&gt;类似AFS，使用标准的copy-on-write技术实现快照。&lt;/p&gt;
&lt;h4 id=&#34;master操作&#34;&gt;Master操作&lt;/h4&gt;
&lt;p&gt;master的任务：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;执行所有namespace相关的操作&lt;/li&gt;
&lt;li&gt;管理系统的chunk副本以及与之相关的一些操作&lt;/li&gt;
&lt;/ol&gt;
&lt;h5 id=&#34;namespace的管理和锁定&#34;&gt;namespace的管理和锁定&lt;/h5&gt;
&lt;p&gt;GFS没有传统文件系统的per-directory数据结构。也不支持alias。&lt;/p&gt;
&lt;h5 id=&#34;gc&#34;&gt;gc&lt;/h5&gt;
&lt;p&gt;文件被删除之后，不会立即回收资源，而是先重命名为包含删除时间戳的隐藏文件，如果隐藏文件存在超过三天，就删除它们。在此期间，这些文件可以被恢复。
内存元数据也会被删除，切断和所有chunk的联系，在和master的心跳中，chunkserver报告自己的chunks，master会返回不出现在namespace里的，chunkserver接受到后可以删掉这些chunk。&lt;/p&gt;
&lt;h4 id=&#34;容错性与诊断&#34;&gt;容错性与诊断&lt;/h4&gt;
&lt;h5 id=&#34;高可用性&#34;&gt;高可用性&lt;/h5&gt;
&lt;p&gt;通过两种简单而有效的策略来保持整个系统的高可用性:快速恢复和复制&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;快速恢复
master和chunkserver都可以在几秒内启动&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;chunk复制
默认是复制3份&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;master复制&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;操作日志和检查点被复制到多台机器上&lt;/p&gt;
</description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="https://yichengme.site/categories/%E7%AE%97%E6%B3%95/">算法</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="https://yichengme.site/tags/gfs/">GFS</category>
                                
                            
                                
                                
                                
                                    <category domain="https://yichengme.site/tags/%E5%88%86%E5%B8%83%E5%BC%8F/">分布式</category>
                                
                            
                                
                                
                                
                                    <category domain="https://yichengme.site/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/">大数据</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>生存分析基础</title>
                <link>https://yichengme.site/posts/survival-analysis-basic/</link>
                <guid isPermaLink="true">https://yichengme.site/posts/survival-analysis-basic/</guid>
                <pubDate>Wed, 23 Dec 2020 15:23:00 &#43;0800</pubDate>
                
                    <author>engine74396@gmail.com (王毅诚)</author>
                
                <copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</copyright>
                
                    <description>&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1640248844/survival-analysis-0.png&#34; alt=&#34;survival-analysis-1&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;背景与简介&#34;&gt;背景与简介&lt;/h4&gt;
&lt;p&gt;在生物医学、金融保险等领域，生存分析是一种很常见而且重要的方法。&lt;/p&gt;
&lt;p&gt;生存分析主要用在癌症等疾病的研究中，比如对某种抗癌药物做临床试验，筛选一部分癌症患者，分为两组，一组服用该试验药物，一组服用对照药物，服药后开始统计每个患者从服药一直到死亡的生存时间。&lt;/p&gt;
&lt;p&gt;生存分析可以抽象概述为，研究在不同条件下，特定事件发生与时间的关系是否存在差异。这些具体事件可以是死亡，也可以是痊愈、肿瘤转移、复发、出院、重新入院等任何可以明确识别的事件，而不同条件即为不同的分组依据，可以是年龄、性别、地域、某个基因表达量的高低、某个突变的携带与否等等。&lt;/p&gt;
&lt;p&gt;（后面均用&amp;quot;死亡&amp;quot;来代指这个特定事件&lt;/p&gt;
&lt;h4 id=&#34;概念与推导&#34;&gt;概念与推导&lt;/h4&gt;
&lt;h5 id=&#34;生存时间t&#34;&gt;生存时间T&lt;/h5&gt;
&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1640248843/surv-time-1.png&#34; alt=&#34;survival-time&#34;&gt;&lt;/p&gt;
&lt;p&gt;把生存时间作为一个随机变量，用PDF（概率密度函数）和CDF（分布函数）来表达&lt;/p&gt;
&lt;p&gt;其中CDF为$F(t) = Pr(T &amp;lt; t)$，也就是t之前死亡的概率&lt;/p&gt;
&lt;h5 id=&#34;生存概率&#34;&gt;生存概率&lt;/h5&gt;
&lt;p&gt;S(t)，Survival probability，研究对象从试验开始到某个特定时间点仍然存活的概率,$S(t) = pr(T &amp;gt; t)$&lt;/p&gt;
&lt;p&gt;$S(t) = 1 - F(t)$&lt;/p&gt;
&lt;p&gt;之后的Kaplan-Meier模型主要关注S(t)&lt;/p&gt;
&lt;h5 id=&#34;风险概率&#34;&gt;风险概率&lt;/h5&gt;
&lt;p&gt;$h(t): \text{Hazard function}$&lt;/p&gt;
&lt;p&gt;$$h(t) = \lim_{\epsilon \to 0}\frac{P(T \in (t, t+\epsilon] | T \geqslant t)}{\epsilon} = \frac{f(t)}{S(t)}$$&lt;/p&gt;
&lt;p&gt;前一个等号的意义 很明显，表示的意义就是研究对象从试验开始到某个特定时间点t之前存活，但是在t时间点发生&amp;quot;死亡&amp;quot;的概率&lt;/p&gt;
&lt;p&gt;后面一个等号的推导过程&lt;/p&gt;
&lt;p&gt;$$
\begin{array}{llr}
h(t)&amp;amp; = \lim_{\Delta t \to 0} \frac{P(t &amp;lt; T \leqslant t + \Delta t | T &amp;gt; t)}{\Delta t}\newline
&amp;amp; = \lim_{\Delta t \to 0} \frac{P(t &amp;lt; T \leqslant t + \Delta t )}{\Delta t S(t)} &amp;amp; \scriptsize{S(t)的定义}\newline
&amp;amp; = \lim_{\Delta t \to 0} \frac{F(t + \Delta t) - F(t)}{\Delta t S(t)} &amp;amp; \scriptsize{F(t)的定义}\newline
&amp;amp; = \frac{f(t)}{S(t)}&amp;amp;  \scriptsize{f(t)是F(t)的微分}
\end{array}
$$&lt;/p&gt;
&lt;p&gt;然后还可以进一步推导：&lt;/p&gt;
&lt;p&gt;$$
h(t) = \frac{f(t)}{S(t)} = \frac{f(t)}{1 - F(t)} = - \frac{\partial log[1 - F(t)]}{\partial t} = - \frac{\partial log[S(t)]}{\partial t}
$$&lt;/p&gt;
&lt;p&gt;表示了$h(t)$和$S(t)$的关系&lt;/p&gt;
&lt;p&gt;$H(t): \text{Comulative\ Hazard\ function}$
 
$$H(t) = \int_0^t h(u) du$$&lt;/p&gt;
&lt;p&gt;进一步推导：
$$H(t) = \int_0^t h(u) du = - \int_0^t \frac{ \partial log[S(u)]}{\partial u} du = -log[S(t)]$$&lt;/p&gt;
&lt;p&gt;$$\to S(t) = exp[-H(t)]$$&lt;/p&gt;
&lt;p&gt;之后的Cox比例风险模型主要关注H(t)&lt;/p&gt;
&lt;h4 id=&#34;hazard-function理解&#34;&gt;Hazard function理解&lt;/h4&gt;
&lt;p&gt;hazard function 本身不是概率，它描述的是一种在给定时间点的风险，$\Delta t \times h(t)$表示在$(t, t + \Delta t]$的概率&lt;/p&gt;
&lt;p&gt;hazard function优势：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;描述给定时间点的风险，这是我们需要的信息&lt;/li&gt;
&lt;li&gt;可以很好的处理数据缺失的情况&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;举个例子&#34;&gt;举个例子&lt;/h4&gt;
&lt;p&gt;假设survival time服从指数分布$Exp(\lambda)$，即$f(x) = \lambda e ^{-\lambda x}, x &amp;gt; 0$&lt;/p&gt;
&lt;p&gt;也就是$f(t) = \lambda e ^{-\lambda x}$&lt;/p&gt;
&lt;p&gt;可以推出：&lt;/p&gt;
&lt;p&gt;$F(t) = 1 - e ^{-\lambda x}$&lt;/p&gt;
&lt;p&gt;$S(t) = 1 - F(t) = e ^{-\lambda x}$&lt;/p&gt;
&lt;p&gt;$h(t) = \frac{f(t)}{S(t)} = \lambda$&lt;/p&gt;
&lt;p&gt;$H(t) = \lambda t$&lt;/p&gt;
&lt;p&gt;$E(T) = \frac{1}{\lambda} （指数分布的性质）= \frac{1}{h(t)}$&lt;/p&gt;
&lt;p&gt;其他的分布同理
Gamma distribution
Weibull distribution
Log-normal distribution
generized gamma distribution...&lt;/p&gt;
&lt;h4 id=&#34;删失数据-censoring&#34;&gt;删失数据 Censoring&lt;/h4&gt;
&lt;p&gt;生存分析中，很常见的一种特征就是删失数据&lt;/p&gt;
&lt;p&gt;指的是在临床试验中，出现一些数据丢失的情况，比如病人中途主动退出、无法联系到、结束时还未发生特定事件。保留了从一开始到丢失前进度的数据成为右删失，另一种称为左删失。（后面只讨论右删失）&lt;/p&gt;
&lt;h5 id=&#34;type-i-censoring观测时间确定&#34;&gt;Type I Censoring：观测时间确定&lt;/h5&gt;
&lt;p&gt;每一项数据增加一个表示：&lt;/p&gt;
&lt;p&gt;$$(U_i, \delta_i) = {min (T_i, c), I(T_i \leqslant c)}, i = 1, ... , n$$&lt;/p&gt;
&lt;p&gt;$$I(T_i \leqslant C) = \begin{cases}
1, &amp;amp; T_i \leqslant C,\
0, &amp;amp; T_i &amp;gt; C
\end{cases}$$&lt;/p&gt;
&lt;p&gt;c是实验时间，是一个常量
也就是说如果是$(c, 0)$，则代表被删失，如果是$(T_i, 1)$，则没有被删失&lt;/p&gt;
&lt;h5 id=&#34;type-ii-censoring观测人数确定&#34;&gt;Type II Censoring：观测人数确定&lt;/h5&gt;
&lt;p&gt;比如观测n人，当死亡r人时停止试验
$T_{(1, n)}, T_{(2, n)}, ..., T_{(r, n)}$&lt;/p&gt;
&lt;h5 id=&#34;type-iii-censoring随机censoring&#34;&gt;Type III Censoring：随机Censoring&lt;/h5&gt;
&lt;p&gt;不用常量c而是用随机变量$C_i$&lt;/p&gt;
&lt;p&gt;$(U_i, \delta_i) = {min (T_i, C_i), I(T_i \leqslant C_i)}, i = 1, ... , n$&lt;/p&gt;
&lt;p&gt;只考虑右删失，我们只观察$(U_i, \delta_i)$
如果$(U_i, \delta_i) = (u_i, 1)$，则说明$T_i = u_i, C_i &amp;gt; u_i$
如果$(U_i, \delta_i) = (u_i, 0)$，则说明$T_i \geqslant u_i, C_i = u_i$&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1640245124/survival-analysis-2.png&#34; alt=&#34;survival-analysis-2&#34;&gt;&lt;/p&gt;
&lt;p&gt;(推导见https://www.bilibili.com/video/BV1WE411P78Z?p=2)&lt;/p&gt;
&lt;h4 id=&#34;kaplan-meier模型&#34;&gt;Kaplan-Meier模型&lt;/h4&gt;
&lt;p&gt;与生存表、Cox并列的一种生存分析的方法，也叫乘积极限(product-limit estimator)&lt;/p&gt;
&lt;p&gt;$\hat{S}(t)=\prod_{i: t_{i} \leq t}\left(1-\frac{d_{i}}{n_{i}}\right), \quad t \geq 0$&lt;/p&gt;
&lt;p&gt;$d_i$是在$t_i$时刻死亡的人数，$n_i$是还在风险中的人数&lt;/p&gt;
&lt;p&gt;例子：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1640245203/survival-analysis-example-1.png&#34; alt=&#34;survival-analysis-example-1&#34;&gt;&lt;/p&gt;
&lt;h5 id=&#34;life-table-生存表&#34;&gt;Life table 生存表&lt;/h5&gt;
&lt;p&gt;举例：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1640245336/life-table-1.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;设时间点为$t_0, t_1, ... ,t_n$，那么在$t_i$时间点下的生存概率：
$$S(t_i) = \Pi_{j=0}^{i}(1-P(t_j死亡))$$&lt;/p&gt;
&lt;p&gt;也就是：
$$S\left(t_{i}\right)=S\left(t_{i-1}\right)\left(1-\frac{d_{i}}{n_{i}}\right)$$&lt;/p&gt;
&lt;p&gt;$n_i$表示$t_i$时的有效人数，$d_i$表示$t_i$时的死亡人数&lt;/p&gt;
&lt;p&gt;$t_i$处的生存率等于$t_{i-1}$时的生存率乘以（1-$t_i$时间点的死亡率）&lt;/p&gt;
&lt;h5 id=&#34;kaplan-meier-生存曲线&#34;&gt;Kaplan-Meier 生存曲线：&lt;/h5&gt;
&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1640245508/km-curve-1.png&#34; alt=&#34;&#34;&gt;
加号表示删失数据&lt;/p&gt;
&lt;p&gt;往往是多条线（因为是不同的组）&lt;/p&gt;
&lt;h4 id=&#34;cox比例风险回归模型&#34;&gt;Cox比例风险回归模型&lt;/h4&gt;
&lt;p&gt;Cox Proportional-Hazards Model是由英国统计学家D.R.Cox于1972年提出的一种半参数回归模型（半参数值既包含参数模型，又包含非参数模型）&lt;/p&gt;
&lt;p&gt;参数模型：有限维度，有限个参数就可以表示模型分布，比如正态分布的均值和标准差
非参数模型：属于某个无限维的空间，无法用有限个参数来表示，比如决策树、随机森林&lt;/p&gt;
&lt;p&gt;Cox建立回归的是前面提到的$h(x)$
Cox模型：
$$h(t) = h_0(t) \times exp({b_1x_1 + b_2x_2 + ... b_px_p})$$&lt;/p&gt;
&lt;p&gt;其中$h(t)$指的是不同时间的风险值（hazard），$x_i$指的是具有预测效应的变量，$b_i$指的是每个变量对应的效应值，$h_0(t)$是基准风险函数，根据不同的数据来使用不同的分布模型，是非参数模型&lt;/p&gt;
&lt;p&gt;建模时，首先确定需要研究的可能影响生存率的因素，也就是$x_i$，我们主要要做的就是找到合适的$h_0(t)$以及所有协变量的系数$b_p$，需要用到极大似然估计等方法求解参数。&lt;/p&gt;
&lt;h5 id=&#34;两个基本假设&#34;&gt;两个基本假设&lt;/h5&gt;
&lt;p&gt;对公式两边取对数进行变形：&lt;/p&gt;
&lt;p&gt;$$log(h(t)) = log(h_0(t)) + \beta X$$&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;模型中各危险因素对危险率的影响不随时间改变，且与时间无关&lt;/li&gt;
&lt;li&gt;对数危险率与各个危险因素呈线性相关&lt;/li&gt;
&lt;/ol&gt;
&lt;h5 id=&#34;参数的极大似然估计&#34;&gt;参数的极大似然估计&lt;/h5&gt;
&lt;p&gt;通过极大似然估计来求解参数，极大似然估计的思想是，让已经发生的事件出现的可能性最大。&lt;/p&gt;
&lt;p&gt;举个例子，有三个人$X_1, X_2, X_3$分别在三个时间点$t_1, t_2, t_3$死亡&lt;/p&gt;
&lt;p&gt;以$t=t_1$为例，此时我们的目标是$max\ h(t_1, X_1)$和$min\ h(t_1, X_2) + h(t_1, X_3)$，统一这两个的目标：&lt;/p&gt;
&lt;p&gt;$$max\ \frac{h(t_1, X_1)}{h(t_1, X_1) + h(t_1, X_2) + h(t_1, X_3)}$$&lt;/p&gt;
&lt;p&gt;（分母加一个分子不影响结果，但是可以让最后一项不至于分母为0）&lt;/p&gt;
&lt;p&gt;类推得到$t_2$的目标：
$$max\ \frac{h(t_2, X_2)}{h(t_2, X_2) + h(t_2, X_3)}$$&lt;/p&gt;
&lt;p&gt;$t_3$的目标：
$$max\ \frac{h(t_3, X_3)}{h(t_3, X_3)}$$&lt;/p&gt;
&lt;p&gt;所以似然函数是：
$$L(\beta) = \frac{h(t_1, X_1)}{h(t_1, X_1) + h(t_1, X_2) + h(t_1, X_3)} \frac{h(t_2, X_2)}{h(t_2, X_2) + h(t_2, X_3)} \frac{h(t_3, X_3)}{h(t_3, X_3)}$$&lt;/p&gt;
&lt;p&gt;代入$h(x)$的公式之后消掉$h_0(t)$，得到：
$$L(\beta) = \frac{exp(\beta · X_1)}{exp(\beta · X_1) + exp(\beta · X_2) + exp(\beta · X_3)} \frac{exp(\beta · X_2)}{exp(\beta · X_2) + exp(\beta · X_3)} \frac{exp(\beta · X_3)}{exp(\beta · X_3)}$$&lt;/p&gt;
&lt;p&gt;这里我们假设的是3个事件，再泛化到N个的情况：
$$L(\beta)=\prod_{i=1}^{N} \frac{\exp \left(\beta \cdot X_{i}\right)}{\sum_{j: t_{j} \geq t_{i}} \exp \left(\beta \cdot X_{j}\right)}$$&lt;/p&gt;
&lt;p&gt;对数似然函数：
$$l(\beta)=\log L(\beta)=\sum_{i=1}^{N}\left[\beta \cdot X_{i}-\log \left(\sum_{j: t_{j} \geq t_{i}} \exp \left(\beta \cdot X_{j}\right)\right)\right]$$&lt;/p&gt;
&lt;p&gt;梯度为：
$$\frac{\partial l(\beta)}{\partial \beta}=\sum_{i=1}^{N}\left[\beta-\frac{\sum_{j: t_{j} \geq t_{i}} X_{j} \cdot \exp \left(\beta \cdot X_{j}\right)}{\sum_{j: t_{j} \geq t_{i}} \exp \left(\beta \cdot X_{j}\right)}\right]$$&lt;/p&gt;
&lt;p&gt;就可以采用梯度下降法来对参数进行估计&lt;/p&gt;
&lt;h5 id=&#34;解读结果&#34;&gt;解读结果&lt;/h5&gt;
&lt;p&gt;解得了合适的$h_0(t)$以及协变量系数之后，我们可以比较某个协变量$x_i$在不同值的时候对应的不同风险比$\frac{x_i + 1}{x_i}$。&lt;/p&gt;
&lt;p&gt;$$hazard\ ratio = \frac{h_0(t) \times e^{b_1x_1 + b_2x_2 + ...b_i(x_i+1) + ... b_px_p}}{h_0(t) \times e^{b_1x_1 + b_2x_2  + ...b_ix_i + ... b_px_p}} = e^{b_i}$$&lt;/p&gt;
&lt;p&gt;举个例子，假如某个指标$x_i$表示年龄，那么对于年龄x和年龄x+1的人来说，死亡风险比是$e^{b_i}$，如果$b_i&amp;gt;0$，则年龄增大，死亡风险增大。反之减小。等于0则是不起作用&lt;/p&gt;
</description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="https://yichengme.site/categories/%E7%AE%97%E6%B3%95/">算法</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="https://yichengme.site/tags/%E7%94%9F%E5%AD%98%E5%88%86%E6%9E%90/">生存分析</category>
                                
                            
                                
                                
                                
                                    <category domain="https://yichengme.site/tags/%E7%BB%9F%E8%AE%A1%E5%AD%A6/">统计学</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>Mongodb初级教程</title>
                <link>https://yichengme.site/posts/mongodb-basics/</link>
                <guid isPermaLink="true">https://yichengme.site/posts/mongodb-basics/</guid>
                <pubDate>Mon, 20 Apr 2020 14:29:14 &#43;0800</pubDate>
                
                    <author>engine74396@gmail.com (王毅诚)</author>
                
                <copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</copyright>
                
                    <description>&lt;h4 id=&#34;背景&#34;&gt;背景&lt;/h4&gt;
&lt;p&gt;mongodb是一个基于分布式文件存储的数据库。由C++语言编写。旨在为WEB应用提供可扩展的高性能数据存储解决方案。它是一个介于关系数据库和非关系数据库之间的产品，是非关系数据库当中功能最丰富，最像关系数据库的。&lt;/p&gt;
&lt;p&gt;这里简单的讲一下使用方法，不涉及底层原理&lt;/p&gt;
&lt;h4 id=&#34;起步&#34;&gt;起步&lt;/h4&gt;
&lt;h5 id=&#34;mac下安装mongodb&#34;&gt;Mac下安装MongoDB&lt;/h5&gt;
&lt;p&gt;之前是
&lt;code&gt;brew install mongodb&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;但是现在会报错：No available formula with the name “mongodb”。&lt;/p&gt;
&lt;p&gt;先tap一个仓库 &lt;code&gt;brew tap mongodb/brew&lt;/code&gt;
安装mongodb社区版 &lt;code&gt;brew install mongodb-community&lt;/code&gt;&lt;/p&gt;
&lt;h5 id=&#34;运行mongod&#34;&gt;运行mongod&lt;/h5&gt;
&lt;p&gt;新建一个&lt;code&gt;/data/db&lt;/code&gt;文件夹&lt;/p&gt;
&lt;p&gt;运行MongoDB服务
&lt;code&gt;sudo mongod&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;（注：macOS 10.15 Catalina无法在根目录下进行修改，可以在其他目录新建，启动服务时通过&lt;code&gt;sudo mongod --dbpath=new_path/data/db&lt;/code&gt;指定）&lt;/p&gt;
&lt;p&gt;定位和启动MongoDB命令行
&lt;code&gt;cd /usr/local/Cellar/mongodb/4.0.3_1/bin&lt;/code&gt;
&lt;code&gt;./mongo&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;MongoDB和关系型数据库（Oracle、MySQL等）的区别：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;SQL&lt;/th&gt;
&lt;th&gt;MongoDB&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;table&lt;/td&gt;
&lt;td&gt;collection(集合)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;row&lt;/td&gt;
&lt;td&gt;document(文档)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;colume&lt;/td&gt;
&lt;td&gt;field(数据字段)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;每个文档是一组键值对（BSON）相同的字段不需要相同的数据类型&lt;/p&gt;
&lt;h4 id=&#34;基本命令&#34;&gt;基本命令&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;show dbs&lt;/code&gt; 展示所有数据库&lt;/p&gt;
&lt;p&gt;&lt;code&gt;use xx&lt;/code&gt; 使用某个数据库&lt;/p&gt;
&lt;p&gt;使用了某个数据库后：&lt;code&gt;show collections&lt;/code&gt;查看所有的集合&lt;/p&gt;
&lt;p&gt;&lt;code&gt;db.dropDatabase()&lt;/code&gt; 删除当前数据库&lt;/p&gt;
&lt;p&gt;&lt;code&gt;db.&amp;lt;col&amp;gt;.drop()&lt;/code&gt; 删除某个集合&lt;/p&gt;
&lt;p&gt;&lt;code&gt;mongodump -o &amp;lt;output_path&amp;gt;&lt;/code&gt; 导出数据库
（如果设置了密码，需要通过下面的命令导出）
&lt;code&gt;sudo mongodump -o &amp;lt;output_path&amp;gt; --authenticationDatabase admin --username &amp;lt;db_username&amp;gt; --password &amp;lt;db_password&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;mongorestore -d &amp;lt;dbname&amp;gt; &amp;lt;db_path&amp;gt;&lt;/code&gt; 导入数据库&lt;/p&gt;
&lt;h5 id=&#34;验证&#34;&gt;验证&lt;/h5&gt;
&lt;p&gt;本地的还好，如果部署到服务器上，默认是无法外网访问数据库的，倘若你想访问，就得开放端口然后在mongo的配置文件里设置0.0.0.0。然后mongo默认也没有密码&lt;/p&gt;
&lt;p&gt;这就会产生一个很蛋疼的事，当其他人访问你服务器的ip的27017端口时，可以直接完全操作你的数据库，对于非个人弄着玩的项目，这显然是不可能接受的。&lt;/p&gt;
&lt;p&gt;所以我们需要增加数据库验证，这里最常见的就是增加账号密码登录，方法如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span class=&#34;o&#34;&gt;//&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;err&#34;&gt;先使用&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;admin&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;use&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;admin&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;//&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;err&#34;&gt;创建&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;root密码&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;db&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;createUser&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;user&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;root&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;pwd&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;password&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;roles&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;root&amp;#34;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;其他的role：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;read
readWrite
dbAdmin
userAdmin
clusterAdmin
readAnyDatabase
readWriteAnyDatabase
userAdminAnyDatabase
dbAdminAnyDatabase
&lt;/code&gt;&lt;/pre&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span class=&#34;o&#34;&gt;//&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;err&#34;&gt;创建用户&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;db&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;createUser&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;user&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;username&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;pwd&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;password&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;roles&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;userAdminAnyDatabase&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;dbAdminAnyDatabase&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;readWriteAnyDatabase&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;在&lt;code&gt;/etc/mongo.conf&lt;/code&gt;配置文件里，把auth=true前面的&lt;code&gt;#&lt;/code&gt;去掉，让验证生效。&lt;/p&gt;
&lt;p&gt;重启mongodb服务&lt;code&gt;sudo service mongodb restart&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;之后的连接方式：mongo命令行连接：
&lt;code&gt;mongo admin -u username -p password&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;本地GUI（如navicat）连接，设置账号密码即可&lt;/p&gt;
&lt;h5 id=&#34;字段操作&#34;&gt;字段操作&lt;/h5&gt;
&lt;p&gt;字段重命名：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;db.col.update({},{$rename:{&amp;quot;old_field&amp;quot;:&amp;quot;new_field&amp;quot;}},false,true)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;比如：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;db.questionnaire.update({},{$rename:{&amp;quot;questionList&amp;quot;:&amp;quot;question&amp;quot;}},false,true)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;字段增加：
还可以指定默认值xxx&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;db.col.update({},{$set:{new_field:&#39;xxx&#39;}},{multi:true})
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;字段删除：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;db.col.update({},{$unset:{&#39;old_field&#39;:&#39;&#39;}},false, true)
&lt;/code&gt;&lt;/pre&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;db.user_questionnaire.update({},{$unset:{&#39;inputCostEstimation&#39;:&#39;&#39;}},false, true)
&lt;/code&gt;&lt;/pre&gt;&lt;h5 id=&#34;查找&#34;&gt;查找&lt;/h5&gt;
&lt;p&gt;列出集合信息：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;db.&amp;lt;collection-name&amp;gt;.find()
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;列出第一条集合的信息（按Json排版一下）：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;db.&amp;lt;collection-name&amp;gt;.findOne()
db.&amp;lt;col-name&amp;gt;.find({query}, {show})
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;query是一个查询字段。比如{&amp;quot;name&amp;quot;:&amp;quot;yicheng&amp;quot;}这种形式
后面的参数决定field是否显示，比find({&amp;quot;name&amp;quot;:&amp;quot;yicheng&amp;quot;}, {&amp;quot;_id&amp;quot;: 0, &amp;quot;age&amp;quot;: 1}) 表示_id不会显示，age会显示&lt;/p&gt;
&lt;p&gt;条件比较：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;操作&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;th&gt;用法&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;$gt&lt;/td&gt;
&lt;td&gt;&amp;gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;$gte&lt;/td&gt;
&lt;td&gt;&amp;gt;=&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;$lt&lt;/td&gt;
&lt;td&gt;&amp;lt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;$lte&lt;/td&gt;
&lt;td&gt;&amp;lt;=&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;$eq&lt;/td&gt;
&lt;td&gt;=&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;$ne&lt;/td&gt;
&lt;td&gt;!=&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;$in&lt;/td&gt;
&lt;td&gt;in&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;$nin&lt;/td&gt;
&lt;td&gt;not in&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;增删改&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;增加：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;db.col.insert(json)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;e.g.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;db.col.insert({&amp;quot;name&amp;quot;:&amp;quot;engine&amp;quot;, &amp;quot;age&amp;quot;:18})

db.articles.insert({&amp;quot;title&amp;quot;:&amp;quot;Test&amp;quot;,&amp;quot;author&amp;quot;:&amp;quot;engine&amp;quot;,&amp;quot;time&amp;quot;:&amp;quot;2020.02.27&amp;quot;,&amp;quot;kind&amp;quot;:&amp;quot;tech&amp;quot;,&amp;quot;tags&amp;quot;:&amp;quot;golang,website&amp;quot;,&amp;quot;content&amp;quot;:&amp;quot;This is a blog for test&amp;quot;,&amp;quot;comment&amp;quot;:&amp;quot;comment1&amp;quot;,&amp;quot;view&amp;quot;:10,&amp;quot;like&amp;quot;:5})

db.user.insert({&amp;quot;name&amp;quot;:&amp;quot;user1&amp;quot;,avatar:&amp;quot;https://i.loli.net/2020/03/15/XsJjRomr1dy8u4D.png&amp;quot;,&amp;quot;type&amp;quot;:0,&amp;quot;score&amp;quot;:20,&amp;quot;password&amp;quot;:&amp;quot;123456&amp;quot;,&amp;quot;todo&amp;quot;:&amp;quot;&amp;quot;})
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;删除：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;db.col.remove(query)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;修改&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;db.mycoll.update(query, object[, upsert_bool, multi_bool])
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;第一个参数是查询条件，第二个参数是修改信息，第三个是如果没找到是否相当于插入（默认为false），第四个参数是修改一个还是所有（默认为false）&lt;/p&gt;
&lt;p&gt;e.g.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;db.col.update({&amp;quot;name&amp;quot;:&amp;quot;engine&amp;quot;}, {$set:{&amp;quot;age&amp;quot;:20}})

db.col.update({&amp;quot;age&amp;quot;: {$gt: 20}}, {$set:{&amp;quot;age&amp;quot;: 30}}, false, true)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;更复杂的逻辑：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;db.getCollection(&#39;participant&#39;).find().forEach(
   function(item){
       db.getCollection(&#39;participant&#39;).update({&amp;quot;_id&amp;quot;:item._id},{$set:{&amp;quot;modifyTimes&amp;quot;: 3}})
   }
)
&lt;/code&gt;&lt;/pre&gt;&lt;table class=&#34;reference&#34;&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;th&gt;数据类型&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;字符串。存储数据常用的数据类型。在 MongoDB 中，UTF-8 编码的字符串才是合法的。   &lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;Integer&lt;/td&gt;&lt;td&gt;整型数值。用于存储数值。根据你所采用的服务器，可分为 32 位或 64 位。  &lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;Boolean&lt;/td&gt;&lt;td&gt;布尔值。用于存储布尔值（真/假）。  &lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;Double&lt;/td&gt;&lt;td&gt;双精度浮点值。用于存储浮点值。  &lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;Min/Max keys&lt;/td&gt;&lt;td&gt;将一个值与 BSON（二进制的 JSON）元素的最低值和最高值相对比。  &lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;Array&lt;/td&gt;&lt;td&gt;用于将数组或列表或多个值存储为一个键。  &lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;Timestamp&lt;/td&gt;&lt;td&gt;时间戳。记录文档修改或添加的具体时间。  &lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;Object&lt;/td&gt;&lt;td&gt;用于内嵌文档。  &lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;Null&lt;/td&gt;&lt;td&gt;用于创建空值。  &lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;Symbol&lt;/td&gt;&lt;td&gt;符号。该数据类型基本上等同于字符串类型，但不同的是，它一般用于采用特殊符号类型的语言。&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;Date&lt;/td&gt;&lt;td&gt;日期时间。用 UNIX 时间格式来存储当前日期或时间。你可以指定自己的日期时间：创建 Date 对象，传入年月日信息。  &lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;Object ID&lt;/td&gt;&lt;td&gt;对象 ID。用于创建文档的 ID。  &lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;Binary Data&lt;/td&gt;&lt;td&gt;二进制数据。用于存储二进制数据。&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;Code&lt;/td&gt;&lt;td&gt;代码类型。用于在文档中存储 JavaScript 代码。&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;Regular expression&lt;/td&gt;&lt;td&gt;正则表达式类型。用于存储正则表达式。&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;更新某个字段的值&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;db.getCollection&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;participant&amp;#39;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;.find&lt;span class=&#34;o&#34;&gt;()&lt;/span&gt;.forEach&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;
   &lt;span class=&#34;k&#34;&gt;function&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;item&lt;span class=&#34;o&#34;&gt;){&lt;/span&gt;
       db.getCollection&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;participant&amp;#39;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;.update&lt;span class=&#34;o&#34;&gt;({&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;_id&amp;#34;&lt;/span&gt;:item._id&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;,&lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;$set&lt;/span&gt;:&lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;modifiTimes&amp;#34;&lt;/span&gt;: 2&lt;span class=&#34;o&#34;&gt;}})&lt;/span&gt;
   &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h4 id=&#34;golang的mongodb接口mgo&#34;&gt;Golang的MongoDB接口：mgo&lt;/h4&gt;
&lt;p&gt;简单的使用&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;kd&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;Person&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;Name&lt;/span&gt;  &lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;Phone&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;c1&#34;&gt;// mgo.Dial核心函数，由url新建一个session
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;nx&#34;&gt;session&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;mgo&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Dial&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;mongodb://127.0.0.1:27017/&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;nb&#34;&gt;panic&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;defer&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;session&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Close&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
	&lt;span class=&#34;c1&#34;&gt;// Optional. Switch the session to a monotonic behavior.
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;nx&#34;&gt;session&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;SetMode&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;mgo&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Monotonic&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;true&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
        &lt;span class=&#34;c1&#34;&gt;// c就连到了对应的collection
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;session&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;DB&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;test&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;).&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;C&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;people&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
        &lt;span class=&#34;c1&#34;&gt;// 插入数据
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Insert&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Person&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;Ale&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;+55 53 8116 9639&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;},&lt;/span&gt;
		&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Person&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;Cla&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;+55 53 8402 8510&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;})&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;log&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Fatal&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;result&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;Person&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{}&lt;/span&gt;
        &lt;span class=&#34;c1&#34;&gt;// result是一个查询结果
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Find&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;bson&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;M&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;name&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;Ale&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}).&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;One&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;result&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;log&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Fatal&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;fmt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Println&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;Phone:&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;result&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Phone&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;</description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="https://yichengme.site/categories/%E5%B7%A5%E7%A8%8B/">工程</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="https://yichengme.site/tags/mongodb/">MongoDB</category>
                                
                            
                                
                                
                                
                                    <category domain="https://yichengme.site/tags/database/">Database</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>Django2&#43;nginx&#43;uwsgi&#43;Ubuntu部署记录</title>
                <link>https://yichengme.site/posts/django2&#43;nginx&#43;uwsgi&#43;ubuntu%E9%83%A8%E7%BD%B2%E8%AE%B0%E5%BD%95/</link>
                <guid isPermaLink="true">https://yichengme.site/posts/django2&#43;nginx&#43;uwsgi&#43;ubuntu%E9%83%A8%E7%BD%B2%E8%AE%B0%E5%BD%95/</guid>
                <pubDate>Sun, 22 Dec 2019 00:57:19 &#43;0800</pubDate>
                
                    <author>engine74396@gmail.com (王毅诚)</author>
                
                <copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</copyright>
                
                    <description>&lt;p&gt;Django项目写好了，最后一步就是部署(deployment)，部署十分关键，只有部署在服务器上，别人才能从互联网上通过ip地址或域名直接访问到你的网页。&lt;/p&gt;
&lt;p&gt;第一步是购买vps（Virtual Private Server 虚拟服务器），这个很简单而且网上教程一大把，这里就不详述，我在vultr购买的海外服务器，这样不用浪费时间去备案了，vultr的一大特色就是按时长收费，如果你的vps出了什么问题，可以随时关停，并且它还支持微信支付宝，价格也很便宜。
&lt;a href=&#34;https://www.vultr.com/?ref=7617179&#34;&gt; （vultr官网） &lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Django的本地预览十分方便，一行&lt;code&gt;python manage.py runserver&lt;/code&gt;就能搞定，但部署上线可没有这么简单。因为网上关于Django部署的教程都很杂乱，当时部署的时候就踩了很多很多坑，为了给之后一个参考，我又重新部署了一次，来记录详细的过程。&lt;/p&gt;
&lt;h4 id=&#34;相关软件版本&#34;&gt;相关软件版本：&lt;/h4&gt;
&lt;p&gt;Django 2.1.3
Python 3.6.6
nginx 1.14.0
uwsgi 2.0.17.1&lt;/p&gt;
&lt;p&gt;服务器：
Ubuntu-server 18.04&lt;/p&gt;
&lt;h4 id=&#34;准备工作&#34;&gt;准备工作&lt;/h4&gt;
&lt;p&gt;首先打开ssh软件，Xshell、Putty什么的都行，通过vultr上vps详情页上给的ip和root密码连接到这台vps。&lt;/p&gt;
&lt;p&gt;刚拿到的船新Linux，第一步先给它来个更新:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;sudo apt-get update
sudo apt-get upgrade
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;建议使用非root用户，部署时最好使用python虚拟环境，具体操作不是本文的重点，便不赘述了&lt;/p&gt;
&lt;p&gt;系统自带Python3.6、vim和git，所以不用装&lt;/p&gt;
&lt;p&gt;安装python3-pip、python3-setuptools、gcc、python3-dev、wheel：
（缺一不可，不然之后用pip安装uwsgi会有各种各样的报错）&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;sudo apt-get install python3-pip python-setuptools python3-dev wheel
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h4 id=&#34;放置django项目&#34;&gt;放置Django项目&lt;/h4&gt;
&lt;p&gt;直接在服务器端用vim什么的写Django当然可取（虽然会很酸爽），但更多的时候我们是在本地写好了Django项目，要把它挪到服务器上。&lt;/p&gt;
&lt;p&gt;在传输之前，要做一些工作：&lt;/p&gt;
&lt;p&gt;先更改一下&lt;code&gt;setting.py&lt;/code&gt;里的&lt;code&gt;ALLOWED_HOSTS&lt;/code&gt;，把服务器的ip加进去，有域名的话顺便把域名也加进去，要不然之后会无法加载Django项目&lt;/p&gt;
&lt;p&gt;在本地的Python虚拟环境上使用&lt;code&gt;pip freeze &amp;gt; requirements.txt&lt;/code&gt;,生成一个txt文件，里面是需要的Python库以及其版本，之后一并传给服务器&lt;/p&gt;
&lt;p&gt;传输文件到服务器的方法非常之多：可以使用Xshell自带的文件传输，也可以使用linux命令scp或安装更直观的lrzsz，或者使用本地的FileZilla、Winscp等软件，当然万能的git也很不错。&lt;/p&gt;
&lt;p&gt;不过考虑到之后这个web项目之后也要修改，用上面的方法感觉都不是特别方便，介绍一个非常好用的方法，那就是使用Pycharm自带的deployment功能，可以实现实时上传以及下载文件，很是方便。&lt;/p&gt;
&lt;p&gt;在&lt;code&gt;Tools&lt;/code&gt;-&amp;gt;&lt;code&gt;Deployment&lt;/code&gt;-&amp;gt;&lt;code&gt;Configuration&lt;/code&gt;中配置好与自己服务器的连接，IP地址、用户名、密码以及对应项目路径&lt;/p&gt;
&lt;center&gt;
&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1543389659/pycharm-deployment-1.jpg&#34; width=60%&gt;
&lt;/center&gt;
&lt;center&gt;
&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1543389659/pycharm-deployment-2.jpg&#34; width=60%&gt;
&lt;/center&gt;
&lt;p&gt;在&lt;code&gt;Settings&lt;/code&gt;-&amp;gt;&lt;code&gt;Project Interpreter&lt;/code&gt;里把项目解释器更改为服务器里的Python，mappings里填写两边项目的目录，再加一条&lt;code&gt;manage.py&lt;/code&gt;的映射&lt;/p&gt;
&lt;center&gt;
&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1543389660/pycharm-deployment-3.jpg&#34; width=60%&gt;
&lt;/center&gt;
&lt;p&gt;apply之后Pycharm右下角会出现上传进度条，会有点慢，喝杯茶等一段时间即可&lt;/p&gt;
&lt;p&gt;传输完毕后会发现本地的项目已经全部上传到服务器了&lt;/p&gt;
&lt;p&gt;但这个毕竟不是这篇文章的重点，不重点介绍，遇到了什么问题可以留言或者私信我。&lt;/p&gt;
&lt;p&gt;最后别忘了把&lt;code&gt;requirements.txt&lt;/code&gt;上传到服务器，用pycharm的话只要直接把文件拖进本地项目目录，Pycharm就会自动帮我们上传到服务器。&lt;/p&gt;
&lt;p&gt;在服务器上使用&lt;code&gt;pip install -r requirements.txt&lt;/code&gt;来安装必要的Python packages
&lt;br&gt;&lt;/p&gt;
&lt;h4 id=&#34;安装与配置uwsgi&#34;&gt;安装与配置uwsgi&lt;/h4&gt;
&lt;p&gt;使用pip3安装uwsgi（注意是pip安装，不是apt-get，否则之后会各种报错）&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;pip3 install uwsgi
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;下面来试一下uwsgi是否好使：
找个位置新建一个py文件，就叫&lt;code&gt;uwsgi_test.py&lt;/code&gt;好了，然后用vim打开&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;touch uwsgi_test.py
vim uwsgi_test.py
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;写入以下内容：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-Python&#34; data-lang=&#34;Python&#34;&gt;&lt;span class=&#34;k&#34;&gt;def&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;application&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;env&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;start_response&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;start_response&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;200 OK&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[(&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;Content-Type&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;text/html&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)])&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;sa&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;Hello Uwsgi&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;wq保存退出（vim的基本操作不赘述，网上教程一大把）&lt;/p&gt;
&lt;p&gt;然后输入以下命令启动uwsgi，把这个部署到某个端口，以9090端口为例&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;uwsgi --http :9090 --wsgi-file uwsgi_test.py
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这时会出现&lt;code&gt;spawned uWSGI worker 1 (and the only) (pid: 11812, cores: 1) &lt;/code&gt;
找个浏览器，访问&lt;code&gt;http://&amp;lt;你的服务器ip&amp;gt;:9090/&lt;/code&gt;，不出意外的话你会看到Hello Uwsgi的字样，说明uwsgi能正常运行。&lt;/p&gt;
&lt;p&gt;在项目目录下新建&lt;code&gt;uwsgi.ini&lt;/code&gt;文件并编辑加入以下内容：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;uwsgi&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;# 直接访问uwsgi的端口号，绕过nginx&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;http&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;8010&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;# 转发给nginx的端口号&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;socket&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mf&#34;&gt;127.0.0.1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;8001&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;# 是否使用主线程&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;master&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;true&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;# 项目的绝对路径&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;chdir&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;var&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;www&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;PROJECT_NAME&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;/&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;# Django项目wsgi.py文件的相对路径&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;wsgi&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;file&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;PROJECT_NAME&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;wsgi&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;py&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;# 进程数&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;processes&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;4&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;# 每个进程的线程数&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;threads&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;# 监听端口&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;stats&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mf&#34;&gt;127.0.0.1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;9191&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;# 每次退出时是否清理环境配置&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;vacuum&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;true&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;# 目录中一旦有文件被改动就自动重启&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;touch&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;reload&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;var&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;www&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;my_site&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;# 存放日志&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;daemonize&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;var&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;www&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;my_site&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;uWSGI&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;log&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;[uwsgi]
# 直接访问uwsgi的端口号，绕过nginx
http = :8010
# 转发给nginx的端口号
socket = 127.0.0.1:8001
# 是否使用主线程
master = true
# 项目的绝对路径
chdir = /var/www/bangumi_project/
# Django项目wsgi.py文件的相对路径
wsgi-file = bangumi_project/wsgi.py
# 进程数
processes = 4
# 每个进程的线程数
threads = 2
# 监听端口
stats = 127.0.0.1:9191
# 每次退出时是否清理环境配置
vacuum = true
# 目录中一旦有文件被改动就自动重启
touch-reload = /var/www/bangumi_project
# 存放日志
daemonize = /var/www/bangumi_project/uWSGI.log
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;加入uwsgi.ini的目的是使让uwsgi对接Django项目的启动变得更简便，否则就得在终端敲很长的代码&lt;/p&gt;
&lt;p&gt;有了&lt;code&gt;uwsgi.ini&lt;/code&gt;我们只需要输入&lt;code&gt;uwsgi --ini uwsgi.ini&lt;/code&gt;就可以运行，浏览器输入ip地址加:8010端口（先绕过nginx因为还没配置呢），发现可以显示我们的项目了，这时css等静态文件可能没获取到，别急&lt;/p&gt;
&lt;h4 id=&#34;安装和配置nginx&#34;&gt;安装和配置nginx&lt;/h4&gt;
&lt;p&gt;先&lt;code&gt;sudo apt-get install nginx&lt;/code&gt;安装nginx，安装后nginx会自动启动，默认端口为80端口，浏览器输入ip地址加:80，可以看到&amp;quot;Welcome to nginx&amp;quot;的欢迎界面&lt;/p&gt;
&lt;p&gt;把/etc/nginx/目录下的&lt;code&gt;uwsgi_params&lt;/code&gt;复制到项目目录下，也可以直接项目目录下新建&lt;code&gt;uwsgi_params&lt;/code&gt;文件，写入以下内容：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;uwsgi_param  QUERY_STRING       &lt;span class=&#34;nv&#34;&gt;$query_string&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
uwsgi_param  REQUEST_METHOD     &lt;span class=&#34;nv&#34;&gt;$request_method&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
uwsgi_param  CONTENT_TYPE       &lt;span class=&#34;nv&#34;&gt;$content_type&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
uwsgi_param  CONTENT_LENGTH     &lt;span class=&#34;nv&#34;&gt;$content_length&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;

uwsgi_param  REQUEST_URI        &lt;span class=&#34;nv&#34;&gt;$request_uri&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
uwsgi_param  PATH_INFO          &lt;span class=&#34;nv&#34;&gt;$document_uri&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
uwsgi_param  DOCUMENT_ROOT      &lt;span class=&#34;nv&#34;&gt;$document_root&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
uwsgi_param  SERVER_PROTOCOL    &lt;span class=&#34;nv&#34;&gt;$server_protocol&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
uwsgi_param  REQUEST_SCHEME     &lt;span class=&#34;nv&#34;&gt;$scheme&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
uwsgi_param  HTTPS              &lt;span class=&#34;nv&#34;&gt;$https&lt;/span&gt; if_not_empty&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;

uwsgi_param  REMOTE_ADDR        &lt;span class=&#34;nv&#34;&gt;$remote_addr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
uwsgi_param  REMOTE_PORT        &lt;span class=&#34;nv&#34;&gt;$remote_port&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
uwsgi_param  SERVER_PORT        &lt;span class=&#34;nv&#34;&gt;$server_port&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
uwsgi_param  SERVER_NAME        &lt;span class=&#34;nv&#34;&gt;$server_name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;前往/etc/nginx/目录，查看&lt;code&gt;nginx.conf&lt;/code&gt;（nginx基础配置），发现里面有这么两行，意思就是包含conf.d文件夹中所有以conf后缀的配置和site-enabled文件夹中的内容&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;include /etc/nginx/conf.d/*.conf;
include /etc/nginx/sites-enabled/*;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;我们不更改nginx.conf基础配置，只需要修改&lt;code&gt;conf.d&lt;/code&gt;目录下的conf文件即可，进入&lt;code&gt;conf.d&lt;/code&gt;文件夹，修改&lt;code&gt;default.conf&lt;/code&gt;文件，没有的话就新建一个（还可以修改site-enabled/default或者sites-available/default，效果都一样的）&lt;/p&gt;
&lt;p&gt;然后写入以下内容：（务必根据自己的情况做相应更改）&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-nginx&#34; data-lang=&#34;nginx&#34;&gt;&lt;span class=&#34;k&#34;&gt;upstream&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;django&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
   &lt;span class=&#34;kn&#34;&gt;server&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;127.0.0.1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;8001&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;k&#34;&gt;server&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;# 监听端口，可改
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;kn&#34;&gt;listen&lt;/span&gt;       &lt;span class=&#34;mi&#34;&gt;80&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;# 修改为你的ip或者域名
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;kn&#34;&gt;server_name&lt;/span&gt;  &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;.2.3.4&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;# 编码方式
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;kn&#34;&gt;charset&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;utf-8&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;

    &lt;span class=&#34;c1&#34;&gt;# 日志记录，可选
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;kn&#34;&gt;access_log&lt;/span&gt;      &lt;span class=&#34;s&#34;&gt;/var/www/&amp;lt;PROJECT_NAME&amp;gt;/nginx_access.log&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;kn&#34;&gt;error_log&lt;/span&gt;       &lt;span class=&#34;s&#34;&gt;/var/www/&amp;lt;PROJECT_NAME&amp;gt;/nginx_error.log&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;

    &lt;span class=&#34;c1&#34;&gt;# 静态文件所在目录（自行修改）
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;kn&#34;&gt;location&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;/static&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;kn&#34;&gt;alias&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;/var/www/my_site/blog/static&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;# 媒体文件所在目录（自行修改）
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;#location /media  {
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;#    alias /home/www/djangotest/Hello/media; # 媒体文件所在文件夹
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;#}
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;kn&#34;&gt;location&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;/&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;kn&#34;&gt;include&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;/var/www/&amp;lt;PROJECT_NAME&amp;gt;/uwsgi_params&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
        &lt;span class=&#34;kn&#34;&gt;uwsgi_pass&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;django&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;运行&lt;code&gt;service nginx restart&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;如果报错&lt;code&gt;nginx.service failed because the control process exited with error code&lt;/code&gt;，那么运行一下&lt;code&gt;nginx -t -c /etc/nginx/nginx.conf&lt;/code&gt;，可以很容易的找到问题在哪。&lt;/p&gt;
&lt;p&gt;浏览器输入ip地址，如果发现看到的还是&amp;quot;Welcome to nginx&amp;quot;，这个是因为在&lt;code&gt;nginx.conf&lt;/code&gt;中还include了一个&lt;code&gt;sites-enabled/*&lt;/code&gt;，它覆盖了我们在&lt;code&gt;default.conf&lt;/code&gt;中的配置，可以干脆直接去&lt;code&gt;nginx.conf&lt;/code&gt;里把&lt;code&gt;include /etc/nginx/sites-enabled/*;&lt;/code&gt;这一行删掉，或者调换两行位置。
如果当时直接修改的sites-available或者sites-enabled中的default，就不会有这个问题&lt;/p&gt;
&lt;p&gt;这时再访问我们的ip，就能看到自己在本地搭建的Django项目了，因为在配置nginx的时候写入了static的路径，所以css什么的都加载进来了。&lt;/p&gt;
&lt;p&gt;至此nginx配置完毕&lt;/p&gt;
&lt;h4 id=&#34;后续工作&#34;&gt;后续工作&lt;/h4&gt;
&lt;p&gt;服务器上的Django还没有执行数据库迁移与管理员创建，所以记得执行&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;python manage.py makemigrations
python manage.py migrate
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;以及&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;python manage.py createsuperuser
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;每次有更新时都要重载uwsgi与nginx才能生效，为了方便uwsgi的重载，在项目目录下新建一个&lt;code&gt;uwsgi&lt;/code&gt;文件夹，然后在里面新建两个文件:&lt;code&gt;uwsgi.pid&lt;/code&gt;（用于重载停止等操作）和&lt;code&gt;uwsgi.status&lt;/code&gt;（用于查看状态）&lt;/p&gt;
&lt;p&gt;修改&lt;code&gt;uwsgi.ini&lt;/code&gt;，把原先的stats那行删掉，下面加上这两行：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;stats=%(chdir)/uwsgi/uwsgi.status
pidfile=%(chdir)/uwsgi/uwsgi.pid
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这样如果项目有更新，就可以使用这两个命令来分别重载uwsgi和nginx了&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;uwsgi --reload uwsgi/uwsgi.pid
systemctl reload nginx.service
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;至此我们的Django项目就部署完成了&lt;/p&gt;
</description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="https://yichengme.site/categories/%E5%B7%A5%E7%A8%8B/">工程</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="https://yichengme.site/tags/django/">Django</category>
                                
                            
                                
                                
                                
                                    <category domain="https://yichengme.site/tags/linux/">Linux</category>
                                
                            
                                
                                
                                
                                    <category domain="https://yichengme.site/tags/nginx/">nginx</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>Precision5510 黑苹果使用体验</title>
                <link>https://yichengme.site/posts/precision5510-hackintosh/</link>
                <guid isPermaLink="true">https://yichengme.site/posts/precision5510-hackintosh/</guid>
                <pubDate>Thu, 05 Sep 2019 14:33:07 &#43;0800</pubDate>
                
                    <author>engine74396@gmail.com (王毅诚)</author>
                
                <copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</copyright>
                
                    <description>&lt;p&gt;前年的时候，也就是17年年底，鉴于最低配的苏菲4性能比较羸弱，可怜的4G内存开个Chrome和Office就能吃满，分分钟卡爆，于是原来的电脑出掉了，准备更换一台高性能的电脑。&lt;/p&gt;
&lt;p&gt;当时还在原专业读土木，某些软件只有Windows才有，上mbp显然是没想过的，另外宿舍用台式机也比较麻烦，所以只能选Windows笔记本。&lt;/p&gt;
&lt;p&gt;预算其实并不是非常充足，但是内心有一种强烈的想法：买个配置够用的电脑多用几年。说实话五千块的电脑用三四年，真心不如一万的电脑用七八年。&lt;/p&gt;
&lt;p&gt;卡顿是对时间的浪费，崩溃是对心血的亵渎。&lt;/p&gt;
&lt;p&gt;一台电脑，配置固然是核心，但对我这种强迫症而言，工业设计也是一个重要因素。于是最后决定在XPS 15或者precision 5510中选择，它们的模具是一样的，主要区别在于其显卡和定位，前者是搭载游戏显卡，定位是超极本；后者搭载图形显卡，定位是移动图形工作站。&lt;/p&gt;
&lt;p&gt;因为不玩大型游戏，所以最后选择了海淘一款官翻的precision 5510移动图形工作站，虽然买的价格不到国行新机的一半，但还是非常高。最后咬咬牙还是买了，事实证明这台precision 5510确实值这个价。&lt;/p&gt;
&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1550418842/precision5510.jpg&#34; width=100%&gt;
&lt;center&gt; *图片来源：Amazon.com*&lt;/center&gt;
&lt;p&gt;主要部件如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;intel i7 6820HQ 处理器&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;16GB 镁光 DDR4  内存条&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;SK hynix 512GB 固态硬盘&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;夏普 SHP1476 屏幕&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Nvidia Quadro M1000M 图形显卡&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Windows10 pro 系统&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;使用这台工作站，跑了一年多Windows，总的体验当然是很用得很舒服，基本没出现过卡顿的情况，除了Ae渲染时风扇会狂转，其他时候完全无压力啊。win10本身尤其是UWP应用对4k触摸屏还是比较友好的（除了Windows的遗留win7风格界面），但是一些比较老旧或者小众的软件根本没有适配4k，导致那些软件要么字体非常小，看瞎了，要么强行靠缩放来保持尺寸，导致图标和字体发虚严重。4k在windows下的体验只能打80分。&lt;/p&gt;
&lt;p&gt;最开始没想到要装黑苹果，只是偶然在B站看到了科技美学的XPS 15顶配黑苹果评测，瞬间被折服了:
&lt;a href=&#34;https://www.bilibili.com/video/av6079016&#34;&gt;「科技美学」戴尔XPS15顶配版体验测评 黑苹果系统安装&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;当海舟用手开始在屏幕上拖视频块来做FCP剪辑时，弹幕已经沸腾了，就算是顶配定制版MacBook Pro也没有触摸屏，不管原因是为了与ipad的交互区分开，以免造成产品线混淆（正常人理解）还是考虑到抬手触屏不方便 触控板万岁！（果粉理解）亦或只是为了节约屏幕成本 赚更多的钱（果黑理解），事实还是：mbp就是没有配置触摸屏。&lt;/p&gt;
&lt;p&gt;然而有趣的是，Mac OS系统和软件不仅支持高分辨率屏幕触摸操作，甚至比win10还支持的更好。&lt;/p&gt;
&lt;p&gt;前几天通过针大的教程&lt;a href=&#34;https://hyejeong.cn/hackintosh5510mojave&#34;&gt;Dell Precision 5510 Mojave Clover分享&lt;/a&gt;，花了两三天就比较顺利的装上了黑苹果，版本为Mojave 10.14.3，针大不仅写了很详细的教程和分享clover等文件，还通过私信解决了我的很多疑问，非常感激。如果有同样的precision5510想安装黑苹果的，可以去参考针大的这篇文章。&lt;/p&gt;
&lt;p&gt;因为一些软件只能在win上运行，因此装的是双系统，512GB的SSD给Mac OS分了320GB，给win10留了剩下的一百来G。&lt;/p&gt;
&lt;p&gt;下面对precision m5510 4k版黑苹果的各个方面做一个简单的小结，与mbp相比的优势与不足，以及黑苹果的完整程度：&lt;/p&gt;
&lt;h4 id=&#34;屏幕&#34;&gt;屏幕&lt;/h4&gt;
&lt;p&gt;MacBook Pro 15.4英寸的屏幕是 2880 x 1800 P3广色域 Retina视网膜屏
Precision5510 / XPS15 4k版的是 3840 x 2160 100%AdobeRGB UHD 康宁大猩猩玻璃触屏&lt;/p&gt;
&lt;p&gt;单论屏幕素质，Retina的校色更准确，观感更舒适，而Dell的镜面屏分辨率更高，观感更鲜艳。这两款屏幕的素质在笔记本中绝对都在第一梯队，是设计人员的福音，两款屏幕属于神仙打架。&lt;/p&gt;
&lt;p&gt;但有着触摸屏和Mac OS的加持，Precision 4k版本实现了mbp没有加入的触屏功能，感觉像是体验到了未来的mbp。&lt;/p&gt;
&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1550418841/photo_2019-02-17_23.40.37.jpg&#34; width=100%&gt;
&lt;h4 id=&#34;触控板&#34;&gt;触控板&lt;/h4&gt;
&lt;p&gt;mbp的触控板有目共睹，触感和手势交互甩了普通PC一条街，precision/xps的触控板在win本中属于很优秀的，说实话触感虽然和mac是两种感觉，但也十分不错，可喜的是在黑苹果中precision/xps也各种手势操作能够有效执行，比如三指上下划、五指缩放等等，虽然还有一些距离但已经有些接近mbp了。但是前者触控板做工任然有一些瑕疵，看到很多反馈是有一部分比例的x/p本触控板出现轻微的下凹或上凸。&lt;/p&gt;
&lt;p&gt;Mac可以不需要鼠标，只用触控板做大部分工作，但是我尝试了一下搭载Mac OS的5510，还是不能完全脱离鼠标。&lt;/p&gt;
&lt;h4 id=&#34;键盘&#34;&gt;键盘&lt;/h4&gt;
&lt;p&gt;precision/xps的键盘键程太短，说实话敲起来完全没有感觉，而且品控有的有些问题，我的两个Shift键都失灵了，扣下键帽也按不动就很难受，必须接着外接机械键盘，这样确实没问题而且敲得爽，但是外接键盘背来背去很不方便。&lt;/p&gt;
&lt;h4 id=&#34;续航&#34;&gt;续航&lt;/h4&gt;
&lt;p&gt;续航是4k版本的大短板，第一次使用这台电脑时，不插电两个小时后电脑就没电自动关机了，我的内心是绝望的。一方面是电池本身不足，另一方面是屏幕和显卡等（尤其是屏幕）耗电严重，我的这台5510就算开着屏幕什么软件也不运行，也就只能撑两个来小时；中大型软件开几个，80分钟内就能耗光全部电量。平常使用一直都得插着电，电脑要背走，充电器必须跟着，没有插座的地方完全不敢开机。&lt;/p&gt;
&lt;p&gt;也许是我的这台情况过于严重了，其他的4k屏5510可能要好一些，不过也好不到太多，续航确实是硬伤。&lt;/p&gt;
&lt;h4 id=&#34;相关驱动&#34;&gt;相关驱动&lt;/h4&gt;
&lt;p&gt;intel的网卡无法驱动，需要去某宝单独购买，拆机后自动识别和正常苹果没区别。丽台M1000M图形显卡无法驱动，不过i7 6820hq的集显就够用了，只要不玩大游戏就好说，设计软件无压力。其他的驱动基本都可以正常运行。&lt;/p&gt;
&lt;h3 id=&#34;总结&#34;&gt;总结&lt;/h3&gt;
&lt;p&gt;总的说来，precision 5000系列/XPS 15可能是win阵营中，最适合安装黑苹果的机器之一，尤其是4k版本，触摸屏的加持更是更够体验到Mac OS别样的功能，4k下Mac的体验也比win10强太多了。&lt;/p&gt;
&lt;p&gt;另外这个系列的模具工艺质量与工业设计很出色，也是PC本中少见的设计感与mbp有的一拼的产品。&lt;/p&gt;
&lt;p&gt;以上便是我的Precision 5510安装黑苹果后的使用体验，若有任何疑问或错误请联系我，谢谢。&lt;/p&gt;
&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1550418841/photo_2019-02-17_23.40.26.jpg&#34; width=100%&gt;
&lt;p&gt;两天时间陆陆续续装了一些应用上去（未完待续），下一篇不鸽的话会写Mac的应用推荐与资源分享，不见不散&lt;/p&gt;
</description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="https://yichengme.site/categories/%E7%94%9F%E6%B4%BB/">生活</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="https://yichengme.site/tags/%E9%BB%91%E8%8B%B9%E6%9E%9C/">黑苹果</category>
                                
                            
                                
                                
                                
                                    <category domain="https://yichengme.site/tags/%E6%8A%98%E8%85%BE/">折腾</category>
                                
                            
                        
                    
                
            </item>
        
    </channel>
</rss>
