<?xml version="1.0" encoding="utf-8"?>


<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="zh-CN">
    <title type="text">王毅诚的博客</title>
    <subtitle type="html">这里是王毅诚的博客，分享技术文章和生活经历</subtitle>
    <updated>2022-03-02T19:25:58&#43;08:00</updated>
    <id>https://yichengme.site/</id>
    <link rel="alternate" type="text/html" href="https://yichengme.site/" />
    <link rel="self" type="application/atom&#43;xml" href="https://yichengme.site/atom.xml" />
    <author>
            <name>王毅诚</name>
            <uri>https://yichengme.site/</uri>
            
                <email>engine74396@gmail.com</email>
            </author>
    <rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights>
    <generator uri="https://gohugo.io/" version="0.91.1">Hugo</generator>
        <entry>
            <title type="text">Docker基础</title>
            <link rel="alternate" type="text/html" href="https://yichengme.site/posts/docker-basics/" />
            <id>https://yichengme.site/posts/docker-basics/</id>
            <updated>2022-02-27T15:21:46&#43;08:00</updated>
            <published>2022-02-19T17:27:34&#43;08:00</published>
            <author>
                    <name>王毅诚</name>
                    <uri>https://yichengme.site/</uri>
                    <email>engine74396@gmail.com</email>
                    </author>
            <rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">Docker概述 为什么需要Docker？ 项目环境需要迁移，重新配环境很麻烦、一些配置很复杂程序想让其他人运行。 一个解决方法是虚拟机，但是虚拟机过于笨重。为了克服……</summary>
            
                <content type="html">&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1645299146/docker-logo.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;docker概述&#34;&gt;Docker概述&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;为什么需要Docker？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;项目环境需要迁移，重新配环境很麻烦、一些配置很复杂程序想让其他人运行。&lt;/p&gt;
&lt;p&gt;一个解决方法是虚拟机，但是虚拟机过于笨重。为了克服虚拟机的缺点，Linux发展出了一种虚拟化技术：Linux Container（LXC），该技术可以对进程进行隔离，对于容器里面的进程来说，接触到的所有资源都是虚拟的。&lt;/p&gt;
&lt;p&gt;Docker则是对LXC的一种封装，是目前最流行的Linux容器方案，甚至成已然为了容器的代名词。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;虚拟机（Virtual Machine）和Docker的区别：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1645299151/docker-1.png&#34; alt=&#34;docker-1&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1645299231/docker-2.png&#34; alt=&#34;docker-2&#34;&gt;&lt;/p&gt;
&lt;p&gt;Docker相比于传统虚拟机的优点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;更节约资源，同样的硬件可以运行更多的容器&lt;/li&gt;
&lt;li&gt;启动更快&lt;/li&gt;
&lt;li&gt;运行环境一致&lt;/li&gt;
&lt;li&gt;持续交付和部署&lt;/li&gt;
&lt;li&gt;更方便的迁移&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Docker完美贴合DevOps理解，适用于CI/CD流程。&lt;/p&gt;
&lt;h2 id=&#34;docker原理概述&#34;&gt;Docker原理概述&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1645299288/docker-3.png&#34; alt=&#34;docker-3&#34;&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;概念&lt;/th&gt;
&lt;th&gt;解释&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Docker Client（客户端）&lt;/td&gt;
&lt;td&gt;客户端通过命令行或者其他工具与Docker Host进行通信&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Docker Host（主机）&lt;/td&gt;
&lt;td&gt;用来执行Docker守护进程和容器的物理或者虚拟的机器&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Docker Registry&lt;/td&gt;
&lt;td&gt;保存镜像的代码仓库，类似github&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;docker三大概念&#34;&gt;Docker三大概念&lt;/h2&gt;
&lt;h3 id=&#34;镜像image&#34;&gt;镜像（image）&lt;/h3&gt;
&lt;p&gt;相当于一个特殊的root文件系统，比如&lt;code&gt;ubuntu:18.04&lt;/code&gt;官方镜像，就包含一套完整的Ubuntu18.04最小系统的root文件系统，image也可以是多个image堆叠在一起组成，比如在一个image里同时放centOS、MySQL、nginx、app等。&lt;/p&gt;
&lt;p&gt;image可以看成是container的模板，一个image可以生成多个同时运行的container。&lt;/p&gt;
&lt;p&gt;Image从哪里获得？&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;从Docker Hub pull下来&lt;/li&gt;
&lt;li&gt;从其他地方导出的image导入进来&lt;/li&gt;
&lt;li&gt;自行写Dockerfile&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;大部分情况下，为了节约时间，都是使用其他人的image或者在其他image上进行一些修改，很少会从0开始写。&lt;/p&gt;
&lt;p&gt;Dockerfile类似于一个创建container的脚本，因为Dockerfile的内容比较多，下一篇专门讲一下怎么写。&lt;/p&gt;
&lt;h3 id=&#34;容器container&#34;&gt;容器（container）&lt;/h3&gt;
&lt;p&gt;image是静态的定义，container是镜像运行时的实体，类似于跑起来的一个个虚拟机。镜像和容器的关系，类似于面向对象过程中的类与示例。容器通过镜像产生，并独立运行。&lt;/p&gt;
&lt;p&gt;container可以被创建、启动、停止、删除、暂停等。&lt;/p&gt;
&lt;p&gt;容器不应该向存成内写入数据，所有的文件写入操作应该使用数据卷（Volume），数据卷可以使得容器删除或者重新运行后数据不会丢失&lt;/p&gt;
&lt;h3 id=&#34;仓库repository&#34;&gt;仓库（repository）&lt;/h3&gt;
&lt;p&gt;Docker Registry是一个集中的存储、分发镜像的服务。可以包含多个repository，每个repository可以包含多个标签，一个标签对应一个image&lt;/p&gt;
&lt;p&gt;最主流的仓库是官方的Docker Hub&lt;/p&gt;
&lt;h2 id=&#34;docker安装&#34;&gt;Docker安装&lt;/h2&gt;
&lt;p&gt;Docker的安装很简单，一般直接去官网下载安装，然后运行Docker服务，命令行输入&lt;code&gt;docker version&lt;/code&gt;，出现版本即安装成功。&lt;/p&gt;
&lt;h2 id=&#34;docker命令&#34;&gt;Docker命令&lt;/h2&gt;
&lt;h3 id=&#34;build&#34;&gt;build&lt;/h3&gt;
&lt;p&gt;在含有Dockerfile的文件夹中执行：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;docker build -t &amp;lt;IMAGE&amp;gt;:&amp;lt;tag&amp;gt; .
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h3 id=&#34;run&#34;&gt;run&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 运行容器&lt;/span&gt;
docker run &lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;option&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt; &amp;lt;image&amp;gt; &lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;cmd&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;# 比如&lt;/span&gt;
docker run --name ubuntu -it --rm ubuntu:18.04 bash
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;其中&lt;code&gt;--name&lt;/code&gt;赋予一个名称，&lt;code&gt;-it&lt;/code&gt;表示交互模式[i]的终端[t]，&lt;code&gt;--rm&lt;/code&gt;表示运行完之后就删除这个container，最后的是在容器中执行的命令，这里是&lt;code&gt;bash&lt;/code&gt;表示打开命令行。&lt;/p&gt;
&lt;p&gt;这里docker run如果运行的是公用镜像，在本地找不到的话会自动去docker hub pull下来。&lt;/p&gt;
&lt;p&gt;或者先创建不进去，之后运行交互命令行：&lt;code&gt;docker exec -it &amp;lt;id/name&amp;gt; bash&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;docker run的一些参数如下：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;参数&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;-i&lt;/td&gt;
&lt;td&gt;交互式&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;-t&lt;/td&gt;
&lt;td&gt;终端&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;-p&lt;/td&gt;
&lt;td&gt;端口映射，比如 &lt;code&gt;-p 8000:3000&lt;/code&gt;指的就是本机的8000端口映射容器的3000端口&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;-P&lt;/td&gt;
&lt;td&gt;让容器的端口随机映射到本机上&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;-d&lt;/td&gt;
&lt;td&gt;后台运行容器&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;-v&lt;/td&gt;
&lt;td&gt;绑定一个卷&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;--name&lt;/td&gt;
&lt;td&gt;指定一个别名&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;--remove&lt;/td&gt;
&lt;td&gt;使用完就删除&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;--mount&lt;/td&gt;
&lt;td&gt;加载数据卷到容器的某个目录，比如&lt;code&gt;source=my-vol,target=/usr/share/nginx/html&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;多个可用一起使用，比如&lt;code&gt;-it&lt;/code&gt;表示运行容器的交互式终端&lt;/p&gt;
&lt;h3 id=&#34;image相关&#34;&gt;image相关&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 列出全部的image&lt;/span&gt;
docker image list
&lt;span class=&#34;c1&#34;&gt;# 或者简写为&lt;/span&gt;
docker image ls
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;比如&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;REPOSITORY        TAG       IMAGE ID       CREATED         SIZE
redis             latest    f1b6973564e9   &lt;span class=&#34;m&#34;&gt;3&lt;/span&gt; weeks ago     113MB
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 删除image&lt;/span&gt;
docker image rm &amp;lt;id&amp;gt;/&amp;lt;短id&amp;gt;/&amp;lt;lable&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h3 id=&#34;container相关&#34;&gt;container相关&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 列出所有正在运行的container&lt;/span&gt;
docker container list
&lt;span class=&#34;c1&#34;&gt;# 或者简写为&lt;/span&gt;
docker container ls
&lt;span class=&#34;c1&#34;&gt;# 或者进一步简写为&lt;/span&gt;
docker ps
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;比如&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;CONTAINER ID   IMAGE     COMMAND                  CREATED          STATUS          PORTS                    NAMES
29436842e21d   redis     &lt;span class=&#34;s2&#34;&gt;&amp;#34;docker-entrypoint.s…&amp;#34;&lt;/span&gt;   &lt;span class=&#34;m&#34;&gt;52&lt;/span&gt; minutes ago   Up &lt;span class=&#34;m&#34;&gt;52&lt;/span&gt; minutes   0.0.0.0:6379-&amp;gt;6379/tcp   my-redis
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;其中CONTAINER ID和NAME都能指代唯一的container，之后说的&amp;lt;container_id&amp;gt;可以用其中之一表示，ID取前五位即可，比如&lt;code&gt;29436&lt;/code&gt;和&lt;code&gt;my-redis&lt;/code&gt;都可以指定这个container。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 列出所有container，即使是已经停止运行的。&lt;/span&gt;
docker container ls --all

&lt;span class=&#34;c1&#34;&gt;# 停止某容器，只是停止容器运行，之后可以随时启动&lt;/span&gt;
docker stop &amp;lt;container_id&amp;gt;

&lt;span class=&#34;c1&#34;&gt;# 启动某容器，不会和run一样开一个新的，而是启动一个已经停止的container&lt;/span&gt;
docker start &amp;lt;container_id&amp;gt;

&lt;span class=&#34;c1&#34;&gt;# 进入容器，首先这个容器需要是running的&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;# 比如之前创建的时候后台运行了，就可以通过exec重新进入容器&lt;/span&gt;
docker &lt;span class=&#34;nb&#34;&gt;exec&lt;/span&gt; &amp;lt;option&amp;gt; &amp;lt;container_id&amp;gt; &lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;cmd&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt;

&lt;span class=&#34;c1&#34;&gt;# 重启某容器&lt;/span&gt;
docker restart &amp;lt;container_id&amp;gt;

&lt;span class=&#34;c1&#34;&gt;# 删除某容器，不同于停止，删除会从本地完全删掉&lt;/span&gt;
docker rm &amp;lt;container_id&amp;gt;

&lt;span class=&#34;c1&#34;&gt;# 结束对应container的进程（如果container还在运行的话）&lt;/span&gt;
docker kill/stop &lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;id&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt;

&lt;span class=&#34;c1&#34;&gt;# 列出所有被停止的container的id&lt;/span&gt;
docker container ls -aq

&lt;span class=&#34;c1&#34;&gt;# 删除这些停止的container，不再占本地空间，之后ls --all就不会显示了&lt;/span&gt;
docker container rm  &lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;docker container ls -aq&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;修改之后，如果要将container提交保存为image，使用commit命令：
&lt;code&gt;docker commit --author &amp;quot;engine&amp;quot; --message &amp;quot;msg&amp;quot; &amp;lt;name&amp;gt; &amp;lt;image:label&amp;gt;&lt;/code&gt;
会返回一个sha256，但是并不建议这样，因为每次改动一个小地方就可能会动到很多系统文件，会很臃肿&lt;/p&gt;
&lt;h3 id=&#34;其他&#34;&gt;其他&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 列出docker image、repository、container占用的系统空间&lt;/span&gt;
docker system df

&lt;span class=&#34;c1&#34;&gt;# 查看某容器的端口映射&lt;/span&gt;
docker port &amp;lt;container_id&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h2 id=&#34;数据管理&#34;&gt;数据管理&lt;/h2&gt;
&lt;p&gt;数据管理一般是通过数据卷或者挂载主机目录这两种方式：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1645299354/docker-4.png&#34; alt=&#34;types-of-mounts&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;数据卷volume&#34;&gt;数据卷Volume&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 创建一个数据卷&lt;/span&gt;
docker volume create &amp;lt;vol_name&amp;gt;

&lt;span class=&#34;c1&#34;&gt;# 查看所有数据卷&lt;/span&gt;
docker volume ls

&lt;span class=&#34;c1&#34;&gt;# 删除数据卷&lt;/span&gt;
docker volume rm &amp;lt;vol_name&amp;gt;

&lt;span class=&#34;c1&#34;&gt;# 清理无主的数据卷&lt;/span&gt;
docker volume prune
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;&lt;code&gt;docker run&lt;/code&gt;的时候可以通过&lt;code&gt;--mount&lt;/code&gt;来加载数据卷到容器的某个目录&lt;/p&gt;
&lt;h3 id=&#34;挂载主机目录&#34;&gt;挂载主机目录&lt;/h3&gt;
&lt;p&gt;或者挂载主机目录，通过&lt;code&gt;--mount type=bind,source=,target=&lt;/code&gt;来挂载&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;docker run -d -P &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;    --name web &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;# -v /src/webapp:/usr/share/nginx/html \&lt;/span&gt;
    --mount &lt;span class=&#34;nv&#34;&gt;type&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;bind,source&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;/src/webapp,target&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;/usr/share/nginx/html &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;    nginx:alpine
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h2 id=&#34;docker-compose&#34;&gt;Docker Compose&lt;/h2&gt;
&lt;p&gt;Docker Compose负责快速的部署分布式应用。
Compose允许用户通过一个单一的&lt;code&gt;docker-compose.yml&lt;/code&gt;文件来为一个项目创建一组容器。&lt;/p&gt;
&lt;p&gt;安装好doker后即可使用&lt;code&gt;docker-compose&lt;/code&gt;命令，具体的yaml文件写法见官方文档：https://docs.docker.com/compose/compose-file/&lt;/p&gt;
&lt;h2 id=&#34;docker-hub&#34;&gt;Docker Hub&lt;/h2&gt;
&lt;h3 id=&#34;search&#34;&gt;search&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 搜寻指定image，只看官方&lt;/span&gt;
docker search &amp;lt;image&amp;gt; -f is-official&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;true&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h3 id=&#34;pull&#34;&gt;pull&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;docker pull &lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;option&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt; Registry:port/name/label
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h3 id=&#34;push&#34;&gt;push&lt;/h3&gt;
&lt;p&gt;先去Docker Hub注册，可以本地命令行登录&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;docker login
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;在hub上创建好一个仓库，假设叫&lt;code&gt;&amp;lt;REPO&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;然后将image打tag：
&lt;code&gt;docker image tag &amp;lt;IMAGE_ID&amp;gt; &amp;lt;HUB_ID&amp;gt;/&amp;lt;REPO&amp;gt;:&amp;lt;version&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;push到repo中
&lt;code&gt;docker push &amp;lt;HUB_ID&amp;gt;/&amp;lt;REPO&amp;gt;:&amp;lt;version&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;参考：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.docker.com/&#34;&gt;https://docs.docker.com/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://ithelp.ithome.com.tw/users/20103456/ironman/1320&#34;&gt;https://ithelp.ithome.com.tw/users/20103456/ironman/1320&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://yeasy.gitbook.io/docker_practice/&#34;&gt;https://yeasy.gitbook.io/docker_practice/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.ruanyifeng.com/blog/2018/02/docker-tutorial.html&#34;&gt;https://www.ruanyifeng.com/blog/2018/02/docker-tutorial.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.runoob.com/docker/docker-container-usage.html&#34;&gt;https://www.runoob.com/docker/docker-container-usage.html&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://yichengme.site/categories/%E6%8A%80%E6%9C%AF/" term="技术" label="技术" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://yichengme.site/tags/docker/" term="Docker" label="Docker" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">Linux网络编程（三）高性能网络编程</title>
            <link rel="alternate" type="text/html" href="https://yichengme.site/posts/linux-network-programming-3/" />
            <id>https://yichengme.site/posts/linux-network-programming-3/</id>
            <updated>2022-02-27T15:21:46&#43;08:00</updated>
            <published>2022-02-12T14:51:32&#43;08:00</published>
            <author>
                    <name>王毅诚</name>
                    <uri>https://yichengme.site/</uri>
                    <email>engine74396@gmail.com</email>
                    </author>
            <rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">服务器模型 C/S模型 即传统的Client/Server模型，客户端通过访问服务器来获取所需的资源。 串行效率非常低下，服务器需要同时保持多个客户端的监听和提供请求……</summary>
            
                <content type="html">&lt;h2 id=&#34;服务器模型&#34;&gt;服务器模型&lt;/h2&gt;
&lt;h3 id=&#34;cs模型&#34;&gt;C/S模型&lt;/h3&gt;
&lt;p&gt;即传统的Client/Server模型，客户端通过访问服务器来获取所需的资源。&lt;/p&gt;
&lt;p&gt;串行效率非常低下，服务器需要同时保持多个客户端的监听和提供请求。&lt;/p&gt;
&lt;p&gt;比如通过&lt;code&gt;select&lt;/code&gt;系统调用的C/S模型工作流：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1644203796/linux-io-1.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;p2p模型&#34;&gt;P2P模型&lt;/h3&gt;
&lt;p&gt;C/S模型的缺点在于，如果访问量非常大，服务器会受到比较高的压力，并且如果主服务器宕机会影响整个服务，当然通过分布式可以解决这些问题，另一种解决的模型是Peer to Peer点对点模型，这种网络中每个主机的地位是等同的，每台机器在消耗服务的同时也在为他人提供服务，既是客户端也是服务端。&lt;/p&gt;
&lt;p&gt;当然需要有一台发现服务器，用于资源的发现，有些也可以提供内容，从而使得各个客户能够查找自己所需资源的位置。&lt;/p&gt;
&lt;h2 id=&#34;服务器编程框架&#34;&gt;服务器编程框架&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1644206009/linux-io-2.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;模块&lt;/th&gt;
&lt;th&gt;单服务器&lt;/th&gt;
&lt;th&gt;服务器集群&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;I/O处理单元&lt;/td&gt;
&lt;td&gt;处理客户连接，读写网络数据&lt;/td&gt;
&lt;td&gt;接入服务器，实现负载均衡&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;逻辑单元&lt;/td&gt;
&lt;td&gt;业务进程&lt;/td&gt;
&lt;td&gt;逻辑服务器&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;网络存储单元&lt;/td&gt;
&lt;td&gt;本地数据库、文件、缓存&lt;/td&gt;
&lt;td&gt;数据库服务器&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;请求队列&lt;/td&gt;
&lt;td&gt;单元之间的通信&lt;/td&gt;
&lt;td&gt;服务器之间的通信&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;对于I/O来说，非阻塞I/O和I/O多路复用技术是高性能网络编程的常见技术，下面聊一聊非常重要的I/O模型。&lt;/p&gt;
&lt;h2 id=&#34;阻塞io与非阻塞io&#34;&gt;阻塞I/O与非阻塞I/O&lt;/h2&gt;
&lt;p&gt;I/O分为阻塞I/O和非阻塞I/O，socket在创建的时候默认是阻塞的，可以通过设置&lt;code&gt;SOCK_NONBLOCK&lt;/code&gt;或者系统调用&lt;code&gt;F_SETFL&lt;/code&gt;来将其设置为非阻塞的。&lt;/p&gt;
&lt;h3 id=&#34;阻塞io&#34;&gt;阻塞I/O&lt;/h3&gt;
&lt;p&gt;阻塞I/O没有完成时会被系统挂起，直到等待的事件完成。可能会被阻塞的系统调用包括&lt;code&gt;accept&lt;/code&gt;、&lt;code&gt;send&lt;/code&gt;、&lt;code&gt;recv&lt;/code&gt;、&lt;code&gt;connect&lt;/code&gt;等，也就是在发送请求后没有收到返回，那么请求就会挂起，直到收到确认报文后才会唤醒该调用。&lt;/p&gt;
&lt;h3 id=&#34;非阻塞io&#34;&gt;非阻塞I/O&lt;/h3&gt;
&lt;p&gt;非阻塞I/O则总是立即返回，而不管事件是否已经发生。如果没有立即发生就返回error，需要通过errno来区别是没接收到立即的返回还是出错。如果只是单纯的使用非阻塞I/O是没有意义的，直接得到结果但是无法真正处理事件，所以非阻塞I/O需要配合I/O通知机制一起使用，等事件就绪了再处理，I/O通知机制包括I/O复用和SIGIO信号。在后面会详细介绍。&lt;/p&gt;
&lt;h2 id=&#34;同步io与异步io&#34;&gt;同步I/O与异步I/O&lt;/h2&gt;
&lt;h3 id=&#34;同步io&#34;&gt;同步I/O&lt;/h3&gt;
&lt;p&gt;同步I/O指的是I/O的读写操作都在I/O事件发生之后，应用程序完成。同步I/O需要由用户自己来执行I/O操作。向应用程序通知的是I/O就绪事件。&lt;/p&gt;
&lt;p&gt;前面提到的阻塞I/O、I/O复用、SIGIO信号都是同步I/O&lt;/p&gt;
&lt;h3 id=&#34;异步io&#34;&gt;异步I/O&lt;/h3&gt;
&lt;p&gt;异步I/O用户可以直接执行I/O读写，读写操作总是立即返回，而不管I/O是否是阻塞的。异步I/O直接由内核执行I/O操作。向应用程序通知的是I/O完成事件。&lt;/p&gt;
&lt;h2 id=&#34;事件处理模式&#34;&gt;事件处理模式&lt;/h2&gt;
&lt;p&gt;高效的事件处理模式包括Reactor和Proactor，其中同步I/O主要实现Reactor，异步I/O主要实现Proactor。&lt;/p&gt;
&lt;h3 id=&#34;reactor&#34;&gt;Reactor&lt;/h3&gt;
&lt;p&gt;主线程只负责监听I/O处理单元上是否有事件发生，有的话就通知逻辑单元上的工作线程，剩下的都交给工作线程来完成。&lt;/p&gt;
&lt;p&gt;工作流程如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1644212725/linux-io-3.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;同步I/O实现的Reactor模型流程如下：
（I/O复用以epoll为例）&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;主线程向epoll事件表中注册socket的读就绪事件&lt;/li&gt;
&lt;li&gt;主线程调用epoll_wait等待socket上有数据可读&lt;/li&gt;
&lt;li&gt;一旦socket上有数据可读，epool_wait就通知主线程，主线程将socket可读事件放入请求队列&lt;/li&gt;
&lt;li&gt;在请求队列上睡眠的某个对应工作线程会唤醒，然后从socket中读取数据并处理客户请求，然后向epoll事件表注册socket的写就绪事件&lt;/li&gt;
&lt;li&gt;主线程调用epoll_wait等待socket上有数据可写&lt;/li&gt;
&lt;li&gt;一旦socket上有数据可写，epool_wait就通知主线程，主线程将socket可写事件放入请求队列&lt;/li&gt;
&lt;li&gt;在请求队列上睡眠的某个对应工作线程会唤醒，然后从socket中写入用户请求的结果&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;对于一次请求流程来说，是先读取socket上的用户请求的数据，然后写回结果到socket。实际上对于主线程来说read和write也没有本质区别，只需要通过判断事件类型然后放入请求队列唤醒对应的工作线程即可。&lt;/p&gt;
&lt;h3 id=&#34;proactor&#34;&gt;Proactor&lt;/h3&gt;
&lt;p&gt;Proactor模式下，所有的I/O操作都交给主线程和内核来处理，工作线程只负责业务逻辑。主线程epoll_wait只监听socket的连接请求事件，不能用于检测socket的读写，之后的I/O处理都交给内核。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1644212725/linux-io-4.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;异步I/O实现Proactive的流程：&lt;/p&gt;
&lt;p&gt;1、 主线程调用aio_read向内核注册socket的读完成事件，并告诉内核用户读缓冲区的位置和读操作完成时的通知应用程序的方式
2. 主线程继续处理其他逻辑
3. socket数据读入用户缓冲区后，内核向应用程序发送信号，通知数据可用
4. 应用程序根据已经定义好的信号处理函数选择工作线程处理用户请求，工作线程处理完后调用aio_write向内核注册socket写完成事件，并告诉内核用户写缓冲区的位置和写操作完成时的通知应用程序的方式
5. 主线程继续处理其他逻辑
6. 用户缓冲区数据写入socket后，内核向应用程序发送信号，通知数据已发送完
7. 应用程序根据已经定义好的信号处理函数选择一个工作线程做善后处理，如是否关闭socket&lt;/p&gt;
&lt;h2 id=&#34;并发编程模式&#34;&gt;并发编程模式&lt;/h2&gt;
&lt;h3 id=&#34;半同步半异步模式&#34;&gt;半同步/半异步模式&lt;/h3&gt;
&lt;p&gt;这里和之前的同步异步I/O完全不同，这里的同步表示程序完全按照代码的顺序执行，异步表示程序执行需要由系统事件来驱动。&lt;/p&gt;
&lt;p&gt;同步线程逻辑简单，但是效率低、实时性差
异步线程执行效率高、实时性强，但是逻辑复杂、不适合大量的并发&lt;/p&gt;
&lt;p&gt;同时使用同步线程和异步线程，就能既做到有较好的实时性，也能同时处理多个客户端的请求。&lt;/p&gt;
&lt;p&gt;同步线程用来处理客户逻辑，异步线程用来处理I/O事件。异步线程监听到客户请求后，就封装为请求对象然后插入到请求队列中，请求队列会通知运行在同步模式的工作线程来处理这个请求。&lt;/p&gt;
&lt;p&gt;一个用的多的变体实例是半同步/半反应堆模式，主线程为唯一的异步线程，监听socket上的事件：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1644218925/linux-io-5.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;领导者追随者模式&#34;&gt;领导者/追随者模式&lt;/h3&gt;
&lt;p&gt;多个工作线程轮流获得事件源集合，进行轮流监听、分发和处理事件。&lt;/p&gt;
&lt;p&gt;同时只能有一个领导者线程来复杂监听I/O事件，其他的都是追随者，如果监听到了I/O事件，就先从追随者里选出新的领导者，此时新的领导者继续监听I/O事件，然后旧的领导者开始处理之前监听到的事件。&lt;/p&gt;
&lt;p&gt;线程的状态转移：（Processing表示正在处理事件）&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1644218925/linux-io-6.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;高性能编程的一些其他手段&#34;&gt;高性能编程的一些其他手段&lt;/h2&gt;
&lt;h3 id=&#34;池&#34;&gt;池&lt;/h3&gt;
&lt;p&gt;相比于空间，响应时间对于大多数服务来说更重要，池（Pool）就是通过空间换时间。&lt;/p&gt;
&lt;p&gt;池是一组资源的集合，服务器启动的时候就初始化好，完成静态资源分配，之后如果需要相关的资源可以直接从池中获取，而不需要重新创建，从而节约系统资源分配的时间。&lt;/p&gt;
&lt;p&gt;初始化时无法确定具体需要多少资源，所以就分配足够多的资源。&lt;/p&gt;
&lt;p&gt;根据不同的资源类型，池可以分为内存池、进程池、线程池、连接池。&lt;/p&gt;
&lt;h3 id=&#34;数据复制&#34;&gt;数据复制&lt;/h3&gt;
&lt;p&gt;高性能服务器需要避免不必要的复制，尤其是用户代码和内核之间的复制，比如ftp服务器不需要将文件读入到应用程序缓冲区然后调用send函数发送，而是直接可以通过调用sendfile从内核直接发送给客户端。&lt;/p&gt;
&lt;h2 id=&#34;io复用&#34;&gt;I/O复用&lt;/h2&gt;
&lt;p&gt;I/O复用是最常见的I/O通知机制，指的是应用程序通过I/O复用函数向内核注册一系列事件，内核通过I/O复用函数将就绪的事件返回给应用程序。&lt;/p&gt;
&lt;p&gt;I/O复用使得程序可以同时监听多个文件描述符（包括socket、用户IO等），从而提高程序性能，比如：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;同时处理多个socket&lt;/li&gt;
&lt;li&gt;同时处理用户输入和网络连接（比如聊天室）&lt;/li&gt;
&lt;li&gt;同时监听和连接socket（使用最多的场合）&lt;/li&gt;
&lt;li&gt;同时处理TCP和UDP连接&lt;/li&gt;
&lt;li&gt;同时监听多个端口&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;需要注意的是，I/O复用函数本身是阻塞的，多个文件描述符就绪时也只能串行处理，I/O复用依靠同时监听多个I/O事件来达到高效率。&lt;/p&gt;
&lt;p&gt;如果还要实现多个就绪文件描述符的并发处理，就只能采用多进程或多线程并发，这个后面再讲。&lt;/p&gt;
&lt;p&gt;Linux中最常见的I/O复用有select、poll和epoll。&lt;/p&gt;
&lt;h3 id=&#34;select&#34;&gt;select&lt;/h3&gt;
&lt;p&gt;I/O多路复用指的是一个线程处理多个IO流，也就是常说的selct/epoll机制。&lt;/p&gt;
&lt;p&gt;可以把标准输入、套接字都看作I/O的一路，多路复用就是在任何一路有I/O事件的地方通知程序去处理相应的I/O事件。
如果有标准输入，就直接从标准输入中读取数据，如果有套接字数据可以读，就直接读出数据。&lt;/p&gt;
&lt;p&gt;select是常见的一个I/O多路复用机制，采用事件轮询机制，最大的缺点就是，支持的文件描述符的最大个数是1024个。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;int select(int nfds, fd_set *readset, fd_set *writeset, fd_set *exceptset, const struct timeval *timeout)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;nfds：被监听的文件描述符的总数
readset：读描述符集合
writeset：写描述符集合
exceptset：异常描述符集合
timeout：select函数的超时时间&lt;/p&gt;
&lt;p&gt;描述符集合的作用是通知内核哪些数据可以读/写/异常等，理解为一个0/1构成的向量。fd_set结构体是一个整型数组，每个bit标记一个文件描述符。&lt;/p&gt;
&lt;p&gt;通过&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;FD_ZERO&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;fd_set&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;fdset&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;　　　　　　
&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;FD_SET&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;fd&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;fd_set&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;fdset&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;　　
&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;FD_CLR&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;fd&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;fd_set&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;fdset&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;　　　
&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;  &lt;span class=&#34;nf&#34;&gt;FD_ISSET&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;fd&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;fd_set&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;fdset&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;这几个宏进行设置，其中&lt;code&gt;FD_ZERO&lt;/code&gt;会将向量的所有元素设为0，&lt;code&gt;FD_SET&lt;/code&gt;会将对应fd的元素位置设为1, &lt;code&gt;FD_CLR&lt;/code&gt;将对应fd的元素位置设为0,&lt;code&gt;FD_ISSET&lt;/code&gt;会查找fd是0还是1。0代表不处理，1代表要处理。&lt;/p&gt;
&lt;p&gt;select的返回值：成功时返回就绪文件描述符综述，如果超时还没有任何一个就绪就返回0，失败则返回-1和errno。&lt;/p&gt;
&lt;h3 id=&#34;poll&#34;&gt;poll&lt;/h3&gt;
&lt;p&gt;poll和select类似，也是轮询一定数量的文件描述符，查看是否有就绪状态的。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;int poll(struct polld *fds, nfds_t nfds, int timeout)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;fds：pollfd结构的数组，包括文件描述符的可读可写异常等事件&lt;/p&gt;
&lt;p&gt;相比于select将三种事件描述符集合都分开作为三个参数，poll的pollfd放入了全部的文件描述符和事件，被统一处理，从而使得编程更简洁，用户通过pollfd.events传入感兴趣的事件，内核通过修改pollfd.revents反馈就绪的事件。&lt;/p&gt;
&lt;p&gt;返回值的含义和select一样，poll不是重点。&lt;/p&gt;
&lt;h3 id=&#34;-epoll&#34;&gt;★ epoll&lt;/h3&gt;
&lt;p&gt;epoll是Linux特有的I/O复用函数，在2.6的内核版本才引入，是目前Linux最优秀的多路复用机制，也是本篇的重点内容。&lt;/p&gt;
&lt;p&gt;epoll相比于select的改进：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;没有1024个线程的限制&lt;/li&gt;
&lt;li&gt;select采用轮询的方式，效率低下，epoll使用回调函数，效率更高&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;epoll使用一组函数来完成任务，将各个文件描述符的事件统一放在一个事件表里，而不是向select或者poll那样每次调用都要重复传入文件描述符或者事件集。&lt;/p&gt;
&lt;p&gt;不过epoll需要一个额外的文件描述符来标识内核中的事件表。&lt;/p&gt;
&lt;p&gt;首先通过&lt;code&gt;epoll_create&lt;/code&gt;来创建这个文件描述符：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;epoll_create&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;size&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;size是事件表的大小，返回的描述符将被用于其他所有epoll调用的第一个参数，从而能够定位这个事件表。&lt;/p&gt;
&lt;p&gt;通过&lt;code&gt;epoll_ctl&lt;/code&gt;函数修改事件表：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;n&#34;&gt;epoll_ctl&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;epfd&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;op&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;fd&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;epoll_event&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;event&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;其中第一个参数就是&lt;code&gt;epoll_create&lt;/code&gt;返回的事件表的文件描述符，因为需要对于每个文件描述符绑定响应事件。&lt;/p&gt;
&lt;p&gt;op有三种：
&lt;code&gt;EPOLL_CTL_ADD&lt;/code&gt;：往事件表注册fd上的事件
&lt;code&gt;EPOLL_CTL_MOD&lt;/code&gt;：修改fd上的注册事件
&lt;code&gt;EPOLL_CTL_DEL&lt;/code&gt;：删除fd上的注册事件&lt;/p&gt;
&lt;p&gt;fd就是要操作的文件描述符&lt;/p&gt;
&lt;p&gt;event是指定的事件&lt;/p&gt;
&lt;p&gt;epoll的核心调用接口是&lt;code&gt;epoll_wait&lt;/code&gt;：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;epoll_wait&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;epfd&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;epoll_event&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;events&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;maxevents&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;timeout&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;它在一段时间之内等待一组文件描述符的事件，maxevent指最多监听的事件个数。&lt;/p&gt;
&lt;p&gt;如果检测到事件，就将就绪的事件从epfd指定的事件表中复制到events指定的数组中。&lt;/p&gt;
&lt;p&gt;和前面采用轮询机制的的select和poll相比，epoll采用回调机制，轮询的复杂度是$O(n)$，回调是$O(1)$，不过如果活动连接较多，&lt;code&gt;epoll_wait&lt;/code&gt;的回调函数触发过于频繁，造成性能下降。所以epoll适用于连接数较多但是活动连接较少的情况。&lt;/p&gt;
</content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://yichengme.site/categories/%E6%8A%80%E6%9C%AF/" term="技术" label="技术" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://yichengme.site/tags/linux/" term="Linux" label="Linux" />
                            
                        
                            
                            
                            
                                <category scheme="https://yichengme.site/tags/tcp/ip/" term="TCP/IP" label="TCP/IP" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">Linux网络编程（二） socket网络编程基础</title>
            <link rel="alternate" type="text/html" href="https://yichengme.site/posts/linux-network-programming-2/" />
            <id>https://yichengme.site/posts/linux-network-programming-2/</id>
            <updated>2022-02-27T15:21:46&#43;08:00</updated>
            <published>2022-02-06T20:00:52&#43;08:00</published>
            <author>
                    <name>王毅诚</name>
                    <uri>https://yichengme.site/</uri>
                    <email>engine74396@gmail.com</email>
                    </author>
            <rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">概述 数据链路层、网络层和传输层的协议都是在操作系统内核中完成的，实现网络的系统调用的api目前最主流的就是socket。 socket是应用层与TCP/IP协议之……</summary>
            
                <content type="html">&lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;
&lt;p&gt;数据链路层、网络层和传输层的协议都是在操作系统内核中完成的，实现网络的系统调用的api目前最主流的就是socket。&lt;/p&gt;
&lt;p&gt;socket是应用层与TCP/IP协议之间的软件抽象，将复杂的TCP/IP协议隐藏在socket后面，用户只需要调用合适的socket api，socket就会组织对应的协议进行通信。&lt;/p&gt;
&lt;p&gt;最基本的客户端-服务器网络模型：
&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1643894720/client-server-1.png&#34; alt=&#34;client-server-1&#34;&gt;&lt;/p&gt;
&lt;p&gt;运行的单位都是进程。&lt;/p&gt;
&lt;p&gt;一个连接可以通过客户端-服务端的ip和端口号唯一确定，被称为套接字对：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;(clientAddr:clientPort, serverAddr, serverPort)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1643894720/client-server-2.png&#34; alt=&#34;client-server-2&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;tcp网络&#34;&gt;TCP网络&lt;/h2&gt;
&lt;p&gt;下图是客户端-服务端TCP网络的核心逻辑&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1643896619/socket-1.jpg&#34; alt=&#34;socket-1&#34;&gt;&lt;/p&gt;
&lt;p&gt;客户端和服务端建立TCP通信的过程：&lt;/p&gt;
&lt;p&gt;服务端：初始化socket，bind绑定到ip和port上然后listen等待
客户端：初始化socket，通过connect发起连接请求，与服务端通过&lt;strong&gt;TCP三次握手&lt;/strong&gt;建立连接。&lt;/p&gt;
&lt;p&gt;连接建立好之后，数据可以双向传输，之后通过客户端的close发起关闭连接请求。处于半关闭状态，服务器收到后也执行close，进入全关闭。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;socket是用来建立网络连接，传输数据的唯一途径&lt;/strong&gt;，成为网络互连的标准。&lt;/p&gt;
&lt;p&gt;可以将TCP的网络交互理解为打电话，socket是电话机，bind的过程就是把电话机连上线。listen的过程就是在家听到了铃响，accept的过程就是拿起听筒开始应答。&lt;/p&gt;
&lt;p&gt;TCP的三次握手相当于，客户端说：你好，我是客户端。服务器说：确实是你，我是服务端。客户端说：确实是你，服务器收到了。&lt;/p&gt;
&lt;p&gt;然后就进入了连接的过程，任意一方说话相当于write，接收到电话的相当于read，可以双向交流。&lt;/p&gt;
&lt;p&gt;拨打电话的结束之后，挂断电话，即close。&lt;/p&gt;
&lt;h2 id=&#34;udp网络&#34;&gt;UDP网络&lt;/h2&gt;
&lt;p&gt;UDP面向数据报，不基于连接，不保障顺序性、可靠性、没有拥塞控制、重传机制等。在IP协议的基础上增加的部分很有限。&lt;/p&gt;
&lt;p&gt;但是在很多不需要完全可靠和完全顺序性的场景，如DNS、多人聊天、直播等。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1643899709/socket-3.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;服务端创建和绑定socket之后，客户端和服务端之间直接通过&lt;code&gt;sendto&lt;/code&gt;和&lt;code&gt;recvfrom&lt;/code&gt;来传递数据，没有建立连接的过程。&lt;/p&gt;
&lt;h2 id=&#34;c语言补充&#34;&gt;C语言补充&lt;/h2&gt;
&lt;p&gt;这里只记录一些后面遇到的C语言相关的一些补充。&lt;/p&gt;
&lt;h3 id=&#34;环境搭建&#34;&gt;环境搭建&lt;/h3&gt;
&lt;p&gt;Linux需要安装编译环境：&lt;/p&gt;
&lt;p&gt;Ubuntu&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;sudo apt-get install gcc g++ make cmake
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;CentOS&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;sudo yum install gcc g++ make cmake
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;mac也可以，用clion的话，需要先安装Xcode command line developer tools（不需要完整的Xcode）&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;n&#34;&gt;xcode&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;select&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;--&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;install&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;表明安装成功&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&amp;gt; clang --version
Apple clang version 12.0.0 &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;clang-1200.0.32.29&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;
Target: x86_64-apple-darwin19.6.0
Thread model: posix
InstalledDir: /Library/Developer/CommandLineTools/usr/bin
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;然后去clion配置好gcc（C编译器）和g++（C++编译器）的路径即可&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://resources.jetbrains.com/help/img/idea/2021.3/cl_toolchain_detectok.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;一些c语言补充的内容&#34;&gt;一些C语言补充的内容&lt;/h3&gt;
&lt;p&gt;C语言中，uintx_t表示的是有x/8个字节的数据类型。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;kt&#34;&gt;uint8_t&lt;/span&gt;
&lt;span class=&#34;kt&#34;&gt;uint16_t&lt;/span&gt;
&lt;span class=&#34;kt&#34;&gt;uint32_t&lt;/span&gt;
&lt;span class=&#34;kt&#34;&gt;uint64_t&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;几个表示size的类型
&lt;code&gt;size_t&lt;/code&gt;就是unsigned long（64位）或者unsigned int （32位）
&lt;code&gt;ssize_t&lt;/code&gt;是long或者int，有符号&lt;/p&gt;
&lt;h2 id=&#34;socket数据结构&#34;&gt;socket数据结构&lt;/h2&gt;
&lt;p&gt;首先看一下socket的通用结构：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// 描述地址类型
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;typedef&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;unsigned&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;short&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;sa_family_t&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;cm&#34;&gt;/* 描述通用套接字地址  */&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;sockaddr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;sa_family_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;sa_family&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;  &lt;span class=&#34;cm&#34;&gt;/* 地址族.  16-bit*/&lt;/span&gt;
    &lt;span class=&#34;kt&#34;&gt;char&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;sa_data&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;14&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;];&lt;/span&gt;   &lt;span class=&#34;cm&#34;&gt;/* 具体的地址值 112-bit */&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;地址族就是说明这个socket是属于哪种类型的地址。比如IPv4、iPv6、本地地址等。&lt;/p&gt;
&lt;p&gt;包括AF_和PF_，其中AF_是地址族，PF_是协议族，一一对应，比如ipv4的就是AF_INET和PF_INET。ipv6的就是AF_INET6和PF_INET6，本地的就是AF_LOCAL和PF_LOCAL。它们也是互相对应相等的。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;8
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#define PF_LOCAL	1	&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt;/* Local to host (pipes and file-domain).  #define PF_FILE		PF_LOCAL /* Another non-standard name for PF_LOCAL
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt;#define PF_INET		2	/* IP protocol family.  */&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;#define PF_INET6	10	&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt;/* IP version 6.  */&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;&lt;/span&gt;
&lt;span class=&#34;cp&#34;&gt;#define AF_LOCAL	PF_LOCAL
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;#define AF_FILE		PF_FILE
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;#define AF_INET		PF_INET
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;#define AF_INET6	PF_INET6
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;IPv4套接字格式：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// 地址为4个字节，32个bit
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// 因为ipv4的ip形式最高是255.255.255.255，每一段需要8bit，1字节，总共需要4个字节，32bit
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;typedef&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;uint32_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;in_addr_t&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;in_addr&lt;/span&gt;
  &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;in_addr_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;s_addr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
  &lt;span class=&#34;p&#34;&gt;};&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;// port是两个字节，16bit，因为2^16=65526，所以port是从0-25535
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;typedef&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;uint16_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;in_port_t&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;

&lt;span class=&#34;cm&#34;&gt;/* 描述 IPV4 的套接字地址格式  */&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;sockaddr_in&lt;/span&gt;
  &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;sa_family_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;sin_family&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;cm&#34;&gt;/* 地址族 16-bit */&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;in_port_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;sin_port&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;     &lt;span class=&#34;cm&#34;&gt;/* 端口口  16-bit*/&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;in_addr&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;sin_addr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;    &lt;span class=&#34;cm&#34;&gt;/* Internet address. 32-bit */&lt;/span&gt;
  &lt;span class=&#34;p&#34;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;IPv6的地址结构：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;9
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;cm&#34;&gt;/* 描述 IPV6 的套接字地址格式  */&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;sockaddr_in6&lt;/span&gt;
  &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;sa_family_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;sin6_family&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;cm&#34;&gt;/*地址族 16-bit */&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;in_port_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;sin6_port&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;  &lt;span class=&#34;cm&#34;&gt;/* 传输端口号 # 16-bit */&lt;/span&gt;
    &lt;span class=&#34;kt&#34;&gt;uint32_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;sin6_flowinfo&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;cm&#34;&gt;/* IPv6 流控信息 32-bit 先不管*/&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;in6_addr&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;sin6_addr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;  &lt;span class=&#34;cm&#34;&gt;/* IPv6 地址 从32位升级到128位，提升非常巨大 128-bit */&lt;/span&gt;
    &lt;span class=&#34;kt&#34;&gt;uint32_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;sin6_scope_id&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;cm&#34;&gt;/* IPv6 域 ID 32-bit  先不管*/&lt;/span&gt;
  &lt;span class=&#34;p&#34;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;除了英特网套接字外，还有本地套接字&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;cm&#34;&gt;/* 描述本地套接字的￥地址格式  */&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;sockaddr_un&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;kt&#34;&gt;unsigned&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;short&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;sun_family&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;cm&#34;&gt;/* 固定为 AF_LOCAL */&lt;/span&gt;
    &lt;span class=&#34;kt&#34;&gt;char&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;sun_path&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;108&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;];&lt;/span&gt;   &lt;span class=&#34;cm&#34;&gt;/* 路径名 */&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;有一些保留端口，比如常见的ftp的21端口，ssh的22端口，http的80端口，一般来说大于5000的端口可以自己用。&lt;/p&gt;
&lt;p&gt;下图是各个地址族的结构&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1643894800/socket-2.png&#34; alt=&#34;socket-2&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;转换函数&#34;&gt;转换函数&lt;/h2&gt;
&lt;h3 id=&#34;ip地址转换&#34;&gt;IP地址转换&lt;/h3&gt;
&lt;p&gt;平常习惯使用十进制来描述ipv4的ip，用十六进制描述ipv6的ip，然而实际计算机都要转换为二进制。如果输出日志，为了可理解性又需要转换为合适的十进制或者十六进制。&lt;/p&gt;
&lt;p&gt;Linux内置了二者互相转换的函数：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;inet_aton&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;char&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;cp&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;in_addr&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;inp&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;char&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;inet_ntoa&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;in_addr&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;in&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;&lt;code&gt;inet_aton&lt;/code&gt;可以将点分十进制字符串表示的ipv4 ip转换为网络字节序表示的&lt;code&gt;in_addr&lt;/code&gt;结构&lt;/p&gt;
&lt;p&gt;&lt;code&gt;inet_ntoa&lt;/code&gt;则相反，将网络字节序表示的&lt;code&gt;in_addr&lt;/code&gt;结构转换为点分十进制字符串表示的ipv4 ip&lt;/p&gt;
&lt;p&gt;一对更好的函数是&lt;code&gt;inet_pton&lt;/code&gt;和&lt;code&gt;inet_ntop&lt;/code&gt;，这个对于ipv4和ipv6通用。以inet_pton为例：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;cp&#34;&gt;# 将string类型的十进制字符串表示的ip写成二进制的网络字节序作为server_address的sin_addr
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;inet_pton&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;AF_INET&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ip&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;server_address&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;sin_addr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h3 id=&#34;主机地址到网络地址&#34;&gt;主机地址到网络地址&lt;/h3&gt;
&lt;p&gt;计算机硬件有两种存储方式大端字节序和小端字节序，比如数值&lt;code&gt;0x1234&lt;/code&gt;，用大端字节序表示符合人类习惯，就是&lt;code&gt;0x1234&lt;/code&gt;，高位是&lt;code&gt;0x12&lt;/code&gt;，低位是&lt;code&gt;0x34&lt;/code&gt;，而用小端字节序的话，各个字节的顺序就要反过来，高位是&lt;code&gt;0x34&lt;/code&gt;，低位是&lt;code&gt;0x12&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1644291229/big-endian-little-endian-1.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;因为计算机电路先处理低位字节的效率比较高，所以计算机内部处理都是用的小端字节序，但是除了内部处理，其他场合比如网络传输、文件存储，还是使用的人类更容易理解的大端字节序。&lt;/p&gt;
&lt;p&gt;所以主机字节序采用小端字节序和网络字节序采用大端字节序，需要进行一个转换。&lt;/p&gt;
&lt;p&gt;转换函数如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;8
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;lt;arpa/inet.h&amp;gt;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// 16/32位的主机字节序转换为网络字节序
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// 其实就是字节的高低位互换
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;uint16_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;htons&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;uint16_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;hostlong&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;kt&#34;&gt;uint32_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;htonl&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;uint32_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;hostlong&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;// 16/32位的网络字节序转换为主机字节序
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;uint16_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ntohs&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;uint16_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;hostlong&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;kt&#34;&gt;uint32_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ntohs&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;uint32_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;hostlong&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h2 id=&#34;socket编程api&#34;&gt;socket编程api&lt;/h2&gt;
&lt;h3 id=&#34;socket的创建&#34;&gt;socket的创建&lt;/h3&gt;
&lt;p&gt;通过&lt;code&gt;socket()&lt;/code&gt;函数创建一个socket，具体参数如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;socket&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;domain&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;type&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;protocol&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;domain是地址族，指PF_INET、PF_INET6、PF_LOCAL这种
type指的是类型，比如&lt;code&gt;SOCK_STREAM&lt;/code&gt;表示字节流，对应TCP，&lt;code&gt;SOCK_DGRAM&lt;/code&gt;表示数据报，对应UDP，&lt;code&gt;SOCK_RAW&lt;/code&gt;表示原始套接字
第三个protocol现在已经废弃，默认填0即可，一般只需要前两个参数。&lt;/p&gt;
&lt;p&gt;这样要创建一个ipv4的TCP socket只需要：
&lt;code&gt;socket(PF_INET, SOCK_STREAM, 0)&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&#34;socket绑定bind&#34;&gt;socket绑定：bind&lt;/h3&gt;
&lt;p&gt;bind函数的作用是将套接字和套接字地址绑定，套接字只知道自己的具体结构类型等，并不知道具体的ip和地址。&lt;/p&gt;
&lt;p&gt;bind函数的定义如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;n&#34;&gt;bind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;fd&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;sockaddr&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;addr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;socklen_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;len&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;第一个参数是套接字，第二个参数是sockaddr结构的套接字地址，第三个参数是地址长度。&lt;/p&gt;
&lt;p&gt;需要将本地套接字格式转换为通用套接字格式。比如&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;sockaddr_in&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;bind&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;sock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;sockaddr&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;sizeof&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;比如把ipv4的sockaddr_in结构&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;sockaddr_in&lt;/span&gt;
  &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;__SOCKADDR_COMMON&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;sin_&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;in_port_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;sin_port&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;			&lt;span class=&#34;cm&#34;&gt;/* Port number.  */&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;in_addr&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;sin_addr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;		&lt;span class=&#34;cm&#34;&gt;/* Internet address.  */&lt;/span&gt;

    &lt;span class=&#34;c1&#34;&gt;// 占位符，无作用
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;kt&#34;&gt;unsigned&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;char&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;sin_zero&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;sizeof&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;sockaddr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
			   &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;__SOCKADDR_COMMON_SIZE&lt;/span&gt;
			   &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;sizeof&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;in_port_t&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
			   &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;sizeof&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;in_addr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)];&lt;/span&gt;
  &lt;span class=&#34;p&#34;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;转换为通用的sockaddr结构&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;sockaddr&lt;/span&gt;
  &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;__SOCKADDR_COMMON&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;sa_&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;	&lt;span class=&#34;cm&#34;&gt;/* Common data: address family and length.  */&lt;/span&gt;
    &lt;span class=&#34;kt&#34;&gt;char&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;sa_data&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;14&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;];&lt;/span&gt;		&lt;span class=&#34;cm&#34;&gt;/* Address data.  */&lt;/span&gt;
  &lt;span class=&#34;p&#34;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;地址可以设置为本机的地址，但是假如说程序部署到本机，地址是本机的局域网ip 192.168.x.x，之后假如程序部署到其他机子上，需要修改为公网ip，所以需要一种通配地址的机制，来让所有目标地址是本机的请求都接收到，ipv4通过&lt;code&gt;INADDR_ANY&lt;/code&gt;，ipv6通过&lt;code&gt;IN6ADDR_ANY&lt;/code&gt;来设置。&lt;/p&gt;
&lt;h3 id=&#34;socket监听listen&#34;&gt;socket监听：listen&lt;/h3&gt;
&lt;p&gt;bind函数让套接字和地址关联，但是还需要将套接字进行监听，通过调用listen让服务处于可接听的状态。&lt;/p&gt;
&lt;p&gt;初始化的套接字是主动套接字，可以主动发起请求，而通过listen函数之后会变成被动套接字，用来等待客户的请求。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;listen(int socket, int backlog)&lt;/code&gt;
第一个参数是套接字，第二个参数是未完成连接队列的大小，决定了可以接收的并发数目&lt;/p&gt;
&lt;h3 id=&#34;接受连接accept&#34;&gt;接受连接：accept&lt;/h3&gt;
&lt;p&gt;服务端的操作系统内核监听到了客户端的请求，类比于接电话就是此时听到了铃响，通过accept来接电话。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;accept&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;listensockfd&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;sockaddr&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;cliaddr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;socklen_t&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;addrlen&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;第一个参数是套接字，第二个参数是连接的客户端的socket地址，第三个参数是地址长度，第二和第三个参数都是传入空然后指针改变从而获取，accept会返回一个新的已连接套接字。因为不可能一个服务端只服务一个客户端。&lt;/p&gt;
&lt;h3 id=&#34;发起连接connect&#34;&gt;发起连接：connect&lt;/h3&gt;
&lt;p&gt;前面的是服务端的连接建立的方法，客户端的创建socket一样，不过之后要通过connect来主动连接服务端。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;connect&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;sockfd&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;sockaddr&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;servaddr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;socklen_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;addrlen&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;第一个参数是套接字，第二个参数是指向套接字地址结构的指针和结构的大小。套接字地址结构需要包含服务端的ip和端口。&lt;/p&gt;
&lt;p&gt;客户端不需要调用bind，在创建完socket后就可以直接调用connect，内核会随机分配一个端口给这次连接。&lt;/p&gt;
&lt;h3 id=&#34;关闭连接close-shutdown&#34;&gt;关闭连接：close, shutdown&lt;/h3&gt;
&lt;p&gt;关闭一个连接，实际上就是关闭连接对应的socket。&lt;/p&gt;
&lt;p&gt;可以通过&lt;code&gt;close&lt;/code&gt;来关闭连接：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;close&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;fd&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;但是close不是直接关闭，实际上只是把fd的引用计数-1，如果要完全关闭的话需要在子进程和父进程都调用close。&lt;/p&gt;
&lt;p&gt;立即终止连接则应该使用&lt;code&gt;shutdown&lt;/code&gt;：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;shutdown&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;sockfd&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;howto&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;&lt;code&gt;howto&lt;/code&gt;包括三种关闭方式：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;SHUT_RD：关闭读&lt;/li&gt;
&lt;li&gt;SHUT_WR：关闭写&lt;/li&gt;
&lt;li&gt;SHUT_RDWR：关闭读写&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;tcp的数据发送和接收write-send-sendmsg-read&#34;&gt;TCP的数据发送和接收：write, send, sendmsg, read&lt;/h3&gt;
&lt;p&gt;建立好连接后，接下来就是发送数据。常见的发送数据的函数有write, send, sendmsg&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;n&#34;&gt;ssize_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;write&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;socketfd&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;buffer&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;size_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;size&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;ssize_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;send&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;socketfd&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;buffer&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;size_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;size&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;flags&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;ssize_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;sendmsg&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;sockfd&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;msghdr&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;msg&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;flags&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;write就是普通的写文件，因为套接字也是文件
如果想发送袋外数据（一种基于TCP的紧急数据），可以用带flag的send
如果想指定多重缓冲区就需要用sendmsg，通过结构体msghdr传递数据&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;n&#34;&gt;ssize_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;read&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;socketfd&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;buffer&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;size_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;size&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;read将会从socket中读取最多size个字节，然后将结果存储到buffer中。&lt;/p&gt;
&lt;h3 id=&#34;udp的数据发送和接收sendto-recvfrom&#34;&gt;UDP的数据发送和接收：sendto, recvfrom&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;n&#34;&gt;ssize_t&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;recvfrom&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;sockfd&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;buff&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;size_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;nbytes&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;flags&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
　　　　　　　　　　&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;sockaddr&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;from&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;socklen_t&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;addrlen&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;

&lt;span class=&#34;n&#34;&gt;ssize_t&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;sendto&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;sockfd&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;buff&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;size_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;nbytes&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;flags&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
                &lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;sockaddr&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;to&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;socklen_t&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;addrlen&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;由于UDP不会保存上下文的信息，所以还额外传递对端的地址端口等信息。TCP在accept阶段就拿到了对端的信息。UDP的每次接收和发送都是独立的上下文。&lt;/p&gt;
</content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://yichengme.site/categories/%E6%8A%80%E6%9C%AF/" term="技术" label="技术" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://yichengme.site/tags/linux/" term="Linux" label="Linux" />
                            
                        
                            
                            
                            
                                <category scheme="https://yichengme.site/tags/tcp/ip/" term="TCP/IP" label="TCP/IP" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">Linux网络编程（一） 从TCP/IP协议开始</title>
            <link rel="alternate" type="text/html" href="https://yichengme.site/posts/linux-network-programming-1/" />
            <id>https://yichengme.site/posts/linux-network-programming-1/</id>
            <updated>2022-02-27T15:21:45&#43;08:00</updated>
            <published>2022-02-01T14:44:13&#43;08:00</published>
            <author>
                    <name>王毅诚</name>
                    <uri>https://yichengme.site/</uri>
                    <email>engine74396@gmail.com</email>
                    </author>
            <rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">重温计算机网络 TCP/IP协议是目前互联网的主流协议簇，早在计算机网络中我们就已经学习过大部分的内容，现在我们从协议的角度出发再次重温计算机网络的内容，作为后续……</summary>
            
                <content type="html">&lt;h2 id=&#34;重温计算机网络&#34;&gt;重温计算机网络&lt;/h2&gt;
&lt;p&gt;TCP/IP协议是目前互联网的主流协议簇，早在计算机网络中我们就已经学习过大部分的内容，现在我们从协议的角度出发再次重温计算机网络的内容，作为后续内容的基础。&lt;/p&gt;
&lt;p&gt;在物理传输媒介的基础上的四层网络模型，自底向上分别是数据链路层、网络层、传输层、应用层，各层包含的协议如图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1643112994/TCP-IP-1.png&#34; alt=&#34;tcp-ip-1&#34;&gt;&lt;/p&gt;
&lt;p&gt;实体通信用实线表示，逻辑通信用虚线表示。链路层封装了物理传输的细节，网络层封装了路由逐条通信的细节，传输层开始就是端到端的协议&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1643164972/TCP-IP-2.png&#34; alt=&#34;tcp-ip-2&#34;&gt;&lt;/p&gt;
&lt;p&gt;具体的内容在前面的计算机网络基础中已经做了详细的介绍，这里只讨论各层的一部分重要协议。&lt;/p&gt;
&lt;p&gt;ARP协议：链路层协议，完成IP地址到MAC地址的转换
IP协议：网络层协议，完成IP数据报的投递，确定通信路径
ICMP协议：网络层协议，IP协议的补充，用于检测网络连接
TCP协议：传输层协议，提供可靠的、面向连接的基于流的服务
UDP协议：传输层协议，提供不可靠的、无连接的基于数据报的服务
DNS协议：应用层协议，完成域名到IP地址的转换&lt;/p&gt;
&lt;h2 id=&#34;封装与分用&#34;&gt;封装与分用&lt;/h2&gt;
&lt;p&gt;封装指的是上层协议的数据沿协议栈往下传递，每经过一个协议栈就加上头部信息，最终合成以太网帧或令牌环帧在物理层上传递：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1643166755/TCP-IP-3.png&#34; alt=&#34;tcp-ip-2&#34;&gt;&lt;/p&gt;
&lt;p&gt;分用指的是帧到了目的地后的从底向上传递的过程，每个协议栈取出自己的头部，将信息往上传递。头部包含了具体的类型参数，根据头部信息递交给不同的上层。&lt;/p&gt;
&lt;p&gt;比如以太帧用2字节的类型字段来区分IP或ARP
IP数据报根据头部的16位协议编码区分TCP、UDP和ICMP
TCP和UDP通过头部的端口号来区分具体的应用&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1643167303/TCP-IP-4.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;对于顶层应用而言，好像封装和分用没有发生过。&lt;/p&gt;
&lt;h2 id=&#34;arp协议&#34;&gt;ARP协议&lt;/h2&gt;
&lt;p&gt;ARP实现的是网络层IP地址到物理网卡MAC地址的转换，原理是主机向网络广播一个ARP请求，包含目标主机的IP地址，只有被请求到的目标机器才会返回一个ARP应答，包含其物理地址。&lt;/p&gt;
&lt;p&gt;具体的请求和应答的报文格式就不详述，这里ARP会维护一个高速缓存，包含经常访问的机器的IP地址到MAC地址的映射，从而提高效率，避免重复请求。&lt;/p&gt;
&lt;p&gt;Unix（Linux、macOS）可以通过&lt;code&gt;arp&lt;/code&gt;相关命令来管理arp缓存。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;arp -a&lt;/code&gt;：查看所有arp缓存，左边括号内为IP地址，右边为MAC地址。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;? (169.254.72.54) at 60:6d:c7:c6:4c:e5 on en0 [ethernet]
? (169.254.100.233) at 94:e9:79:ff:aa:eb on en0 [ethernet]
file-center.lan (192.168.50.1) at f8:32:e4:84:16:60 on en0 ifscope [ethernet]
? (192.168.50.43) at 3e:cc:9e:13:e6:a4 on en0 ifscope [ethernet]
...
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;arp -d &amp;lt;ip&amp;gt;&lt;/code&gt;：删除某个ip的arp缓存
&lt;code&gt;arp -s &amp;lt;ip&amp;gt; &amp;lt;mac&amp;gt;&lt;/code&gt;：添加某个ip到mac的arp缓存&lt;/p&gt;
&lt;h2 id=&#34;dns协议&#34;&gt;DNS协议&lt;/h2&gt;
&lt;p&gt;DNS协议将域名转换为IP地址，它是一套分布式的域名服务系统，每个DNS服务器都存放大量的域名-IP地址映射，且动态更新。&lt;/p&gt;
&lt;p&gt;Unix下在&lt;code&gt;/etc/resolv.conf&lt;/code&gt;保存了DNS服务器的地址，该文件是随着网络连接状态自动更新的。&lt;/p&gt;
&lt;p&gt;比如连接wifi后，为&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;search lan
nameserver 192.168.50.1
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这里&lt;code&gt;192.168.50.1&lt;/code&gt;是路由器的ip，即依靠局域网的路由器搜索DNS&lt;/p&gt;
&lt;p&gt;而连接了热点之后就立刻变为了&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;nameserver 2409:8938:1610:7763::18
nameserver 192.168.109.2
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;断网之后该文件内容变为空。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;host -t A &amp;lt;host&amp;gt;&lt;/code&gt;：查询某个域名的IP地址，如&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;www.baidu.com is an alias for www.a.shifen.com.
www.a.shifen.com has address 36.152.44.96
www.a.shifen.com has address 36.152.44.95
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;ip协议&#34;&gt;IP协议&lt;/h2&gt;
&lt;p&gt;IP协议是网络层协议，是TCP/UDP的基础，它为上层提供无连接、不可靠、无状态的服务。&lt;/p&gt;
&lt;h3 id=&#34;ipv4的ip头部与分片传输&#34;&gt;ipv4的IP头部与分片传输&lt;/h3&gt;
&lt;p&gt;ipv4的IP头部：
&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1643256162/TCP-IP-5.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;IP的长度超过mtu时会被分片传输，然后在接收端整合，以太帧的mtu通常是1500字节，去掉20字节的头部，还有1480字节可以放数据，数据如果超过1480字节则必须分片传输。&lt;/p&gt;
&lt;p&gt;比如1481字节的ICMP报文，需要分两片来传输：
&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1643256162/TCP-IP-6.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;ip路由机制&#34;&gt;IP路由机制&lt;/h3&gt;
&lt;p&gt;IP协议的核心是路由，即从源机器如何通过网络转发给目标机器。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1643261497/TCP-IP-7.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;接受到了来自链路层的IP数据报后，先通过CRC校验，然后判断是否是发给本机网络或者广播的数据报，如果是的话就依据具体的头部信息传递给TCP/UDP/ICMP模块。如果不是的话就转发给下一跳，具体转发方式是路由协议的内容，比如RIP、OSPF算法等，这个在之前的计算机网络中已经学过了，就不在此细说了。&lt;/p&gt;
&lt;h2 id=&#34;tcp协议&#34;&gt;TCP协议&lt;/h2&gt;
&lt;p&gt;TCP的特征：一对一、全双工、先建立连接、字节流传输、可靠传输&lt;/p&gt;
&lt;p&gt;其他几个很简单，提一下字节流传输，TCP使用字节流传输，而UDP使用数据报传输，字节流的特点就是：发送端执行的写操作次数和接收端执行的读操作次数没有任何数量关系，因为发送缓冲区和接受缓冲区的存在。&lt;/p&gt;
&lt;h3 id=&#34;发送缓冲区与接收缓冲区&#34;&gt;发送缓冲区与接收缓冲区&lt;/h3&gt;
&lt;p&gt;TCP三次握手建立之后，内核会为每一个连接建立配套的基础设施，其中就包括发送缓冲区。&lt;/p&gt;
&lt;p&gt;发送缓冲区的大小可以通过套接字的选项来调整，假如客户端调用write，实际上是将数据从应用程序拷贝到内核中的发送缓冲区中，而不是通过socket。&lt;/p&gt;
&lt;p&gt;如果发送缓冲区足够大，那么write调用成功返回写入的字节数。
如果数据还没发送完，或者缓冲区不够大，内核并不会返回或者报错，而是被阻塞。直到发送完。&lt;/p&gt;
&lt;p&gt;缓冲区类似一条流水线，每次都能不断将数据封装打包为TCP的MSS和IP的MTU包然后从数据链路层打包出去，缓冲区就会空一部分，可以继续搬一部分数据到缓冲区，所以最终总能搬完所有的数据。然后write阻塞就会调用返回，write返回的时候，数据并不是已经发送过去了，而是还有一部分会在缓冲区里，之后会发过去。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1643272895/TCP-IP-9.png&#34; alt=&#34;TCP-IP-9&#34;&gt;&lt;/p&gt;
&lt;p&gt;缓冲区也是TCP字节流传输和UDP数据报传输的一个区别：&lt;/p&gt;
&lt;p&gt;TCP字节流传输：
&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1643272895/TCP-IP-10.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;UDP数据报传输：
&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1643272895/TCP-IP-11.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;tcp的建立三次握手&#34;&gt;TCP的建立：三次握手&lt;/h3&gt;
&lt;p&gt;著名的TCP三次握手：
&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1643272895/TCP-IP-8.png&#34; alt=&#34;tcp三次握手-1&#34;&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;客户端协议栈向服务端发送SYN包，并表明当前发送序列号为j，客户端进入SYN_SENT状态&lt;/li&gt;
&lt;li&gt;服务端的协议栈收到了这个包之后，对客户端的这个SYN进行应答，值为j+1，同时服务器也发送一个SYN包，内容是k，服务器进入SYNC_RCVD状态&lt;/li&gt;
&lt;li&gt;客户端协议栈收到了ACK之后，应用程序的connect调用返回，客户端到服务端的单向通信建立成功。并进入ESTABLISH状态，同时对服务端进行ACK应答，应答值为k+1&lt;/li&gt;
&lt;li&gt;应答包到达服务器，服务器协议端的accept阻塞调用返回，服务器到客户端的单向通信也建立成功。&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;思考一下为什么是三次。
我的理解是，如果A到B的传输连接要成功，至少需要两步，A尝试传一个信息到B，B再返回一个应答。这样就说明了A到B的单向没有问题。反过来也一样。正常来说应该需要四次握手，不过在服务端应答客户端的时候服务端顺便发送请求包，这样节省了一步。所以说最少是三次握手，两次必然不能保证一定连接成功，四次则多浪费了一次。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;tcp的关闭四次挥手与time_wait&#34;&gt;TCP的关闭：四次挥手与TIME_WAIT&lt;/h3&gt;
&lt;p&gt;TCP是全双工的，所以存在一种半关闭状态，也就是A可以接受B发送来的数据，但是A不再发送数据给B，也就是说一端可以告诉对方自己发送的数据已经发完了，但仍然可以接受对方发送的数据，进入半关闭状态，如果对方也发送完了，就进入关闭状态。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1643272895/TCP-IP-12.png&#34; alt=&#34;time_wait-1&#34;&gt;&lt;/p&gt;
&lt;p&gt;一个完整的建立和关闭的过程：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1643549232/TCP-IP-14.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;time_wait&#34;&gt;TIME_WAIT&lt;/h3&gt;
&lt;p&gt;这里提一下TIME_WAIT状态。假设是主机一发送FIN到主机二，在收到FIN n的时候，主机一会进入TIME_WAIT的状态，停留时间是固定的。Linux下是两个最长份节生命周期的时间（即2MSL）。只有发起连接终止的一方会进入TIME_WAIT状态。&lt;/p&gt;
&lt;p&gt;为什么有TIME_WAIT？因为TCP要考虑各种错误情况，假如最后一次挥手客户端的ACK没有传到服务端，那么服务端之后会重发FIN报文。此时如果客户端没有维护TIME_WAIT而是直接关闭，就会失去上下文。坚持2MSL，使得这次连接所有的迟到的报文来得及被丢弃&lt;/p&gt;
&lt;p&gt;但是TIME_WAIT过多，会导致端口资源被占用，有时候可能由于TIME_WAIT导致性能下降。&lt;/p&gt;
&lt;h3 id=&#34;tcp状态转移&#34;&gt;TCP状态转移&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1643273832/TCP-IP-13.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;虚线为服务端，粗实线为客户端。&lt;/p&gt;
&lt;h3 id=&#34;tcp超时重传策略&#34;&gt;TCP超时重传策略&lt;/h3&gt;
&lt;p&gt;每个TCP报文都维护了一个重传定时器，如果超过时间没有收到对方的应答，发送方就会重传TCP报文并reset定时器。&lt;/p&gt;
&lt;p&gt;一般每次重传都比之前的时间间隔更长（比如是上一次的两倍），并且设置最多重传次数，超过这个次数就放弃。&lt;/p&gt;
&lt;h3 id=&#34;tcp拥塞控制&#34;&gt;TCP拥塞控制&lt;/h3&gt;
&lt;p&gt;由于链路层的承载量有限，需要进行控制。&lt;/p&gt;
&lt;p&gt;SWND（Send WiNDow，发送窗口）：指的是发送端向网络一次性发送的数据量。&lt;/p&gt;
&lt;p&gt;如果RWND过小，则延迟会比较大。如果RWND过大，则容易网络拥塞。&lt;/p&gt;
&lt;p&gt;RWND（Receive WiNDow，接收窗口）：指的是接收端一次性能接收的数据量。&lt;/p&gt;
&lt;p&gt;CWND（Congestion WiNDow，拥塞窗口）：不造成拥塞的最大数据量&lt;/p&gt;
&lt;p&gt;实际的 $\text{SWND} = \min(\text{RWND}, \text{CWND})$&lt;/p&gt;
&lt;p&gt;启动阶段包括以下两种算法：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;慢启动&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;设置了一个慢启动门限ssthresh，最开始启动的时候CWND设置一个较小的值（2-4个SMSS），然后慢慢按照指数方式增大CWND的值，直到超过这个门限，然后进入拥塞避免控制。&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;拥塞避免&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;每经过一个轮次，线性增加其大小而不是加倍，让其缓慢增大，出现一次超时后（发生拥塞），就让慢开始门限等于当前cwnd的一半，cwnd重新设为1&lt;/p&gt;
&lt;p&gt;cwnd &amp;gt; ssthresh: 慢启动
cwnd &amp;lt; ssthresh: 拥塞避免&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1643557367/TCP-IP-15.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;拥塞处理包括以下两种算法：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;快重传&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;当发送方连续收到三个重复的ACK报文时，直接重传对方尚未收到的报文段，而不必等待那个报文段设置的重传计时器超时。&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;快恢复&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;快恢复前面和避免算法一样，不同之处是它把cwnd的值设置为慢开始门限ssthresh改变后的数值，然后开始执行拥塞避免算法&lt;/p&gt;
&lt;h2 id=&#34;代理服务器&#34;&gt;代理服务器&lt;/h2&gt;
&lt;p&gt;客户机和目标服务器之间通常需要一些中转服务器进行代理中转访问。&lt;/p&gt;
&lt;h3 id=&#34;正向代理&#34;&gt;正向代理&lt;/h3&gt;
&lt;p&gt;代理服务器的信息需要由客户端设置，每次请求都发送到代理服务器上，然后由代理服务器请求目标资源。
目标服务器并不清楚具体的客户端。
比如科学上网经典的shadowsocks就是这种方式。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1643610218/TCP-IP-17.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;反向代理&#34;&gt;反向代理&lt;/h3&gt;
&lt;p&gt;反向代理由服务端设置，代理服务器接收客户端的连接，然后转发给目标服务器，获得结果后返回给客户端，对外表现就像是目标服务器一样。
客户端并不清楚具体的服务器。很多大型网站都使用反向代理，用户访问该网站，会访问相同地域的反向代理服务器，从而节约时间。以及做负载均衡的nginx、CDN等等。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1643559177/TCP-IP-16.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;http通信&#34;&gt;HTTP通信&lt;/h2&gt;
&lt;h3 id=&#34;http请求&#34;&gt;HTTP请求&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1643611443/TCP-IP-18.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;tcp应答&#34;&gt;TCP应答&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1643698156/HTTP%E7%8A%B6%E6%80%81%E7%A0%81.png&#34; alt=&#34;HTTP状态码&#34;&gt;&lt;/p&gt;
</content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://yichengme.site/categories/%E6%8A%80%E6%9C%AF/" term="技术" label="技术" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://yichengme.site/tags/linux/" term="Linux" label="Linux" />
                            
                        
                            
                            
                            
                                <category scheme="https://yichengme.site/tags/tcp/ip/" term="TCP/IP" label="TCP/IP" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">RPC基础</title>
            <link rel="alternate" type="text/html" href="https://yichengme.site/posts/rpc-basics/" />
            <id>https://yichengme.site/posts/rpc-basics/</id>
            <updated>2022-02-27T15:21:45&#43;08:00</updated>
            <published>2022-01-20T13:29:14&#43;08:00</published>
            <author>
                    <name>王毅诚</name>
                    <uri>https://yichengme.site/</uri>
                    <email>engine74396@gmail.com</email>
                    </author>
            <rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">RPC的概念 RPC（Romote Procedure Call），全称是远程过程调用，作为分布式系统中不同节点之间的通信方式，是分布式系统的基石之一，RPC不是具体的方法，而是一种……</summary>
            
                <content type="html">&lt;h2 id=&#34;rpc的概念&#34;&gt;RPC的概念&lt;/h2&gt;
&lt;p&gt;RPC（Romote Procedure Call），全称是远程过程调用，作为分布式系统中不同节点之间的通信方式，是分布式系统的基石之一，RPC不是具体的方法，而是一种解决不同服务之间调用的设计。&lt;/p&gt;
&lt;p&gt;基于RPC开发的框架可以称为RPC框架，典型的有谷歌的gRPC、阿里的Dubbo、Facebook的Thrift等，当然成熟的RPC框架还会有服务注册与发现、服务治理、负载均衡等功能。&lt;/p&gt;
&lt;h2 id=&#34;为何需要rpc&#34;&gt;为何需要RPC&lt;/h2&gt;
&lt;p&gt;大公司的服务往往部署在不同的机器上，调用其他机器的服务如果每次都要走网络通信会给业务开发带来复杂，希望能够将网络通信进行封装，使得远程调用和本地调用一样简单，于是诞生了RPC。&lt;/p&gt;
&lt;p&gt;RPC对应的一个概念就是本地调用，比如最常见的函数调用，当然远程调用比本地调用复杂的多。我们最终的目的就是通过封装调用的底层过程，让远程调用和本地调用一样方便，请求方调用服务方的某个方法就像是调用本地方法一样。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;为什么不采用基于HTTP的Restful api而采用RPC呢？
实际上，广义的RPC也包括了基于HTTP的Restful api，不过默认指的是中间传输形式为二进制流的跨机器通信方式。基于HTTP协议的restful api更通用、可读性更好，但是报文比较冗余，性能不如二进制传输的RPC。RCP更接近直接调用，也更容易拓展和集成一些功能（如注册中心、负载均衡等）应该视具体情况选择，对性能要求非常高的场景可以使用RPC。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;rpc的核心问题&#34;&gt;RPC的核心问题&lt;/h2&gt;
&lt;h3 id=&#34;寻址问题&#34;&gt;寻址问题&lt;/h3&gt;
&lt;p&gt;如果是本地运行，直接可以获得函数的指针，但是远程的不行，一个方法是Server和Client分别维护一个函数&amp;lt;-&amp;gt;call id的映射表。服务器需要将提供的服务接口进行注册，从而让请求方可以获取到。&lt;/p&gt;
&lt;h3 id=&#34;编码方式&#34;&gt;编码方式&lt;/h3&gt;
&lt;p&gt;比如常见的可读性高的JSON、XML或者性能更好的protobuf。&lt;/p&gt;
&lt;h3 id=&#34;序列化和反序列化&#34;&gt;序列化和反序列化&lt;/h3&gt;
&lt;p&gt;Client：
① tcp/http连接
② 对象结构数据序列化
③ 发送json
④ 等待结果
⑤ 解析结果，反序列化为需要的对象结构&lt;/p&gt;
&lt;p&gt;Server：
① 监听对应端口
② 读取数据
③ 反序列化为需要的对象结构
④ 运行对应的函数处理
⑤ 序列化
⑥ 将结果传输返回&lt;/p&gt;
&lt;p&gt;实际上解决好了之后，语言也不重要了，都可以使用不同的语言。&lt;/p&gt;
&lt;h3 id=&#34;网络传输协议&#34;&gt;网络传输协议&lt;/h3&gt;
&lt;p&gt;比如考虑tcp是用长连接还是短连接，http1.0中，对方返回结果之后，会自动断开，下次连接会比较慢。http2.0可以保持长连接，所以gRPC直接用了http2.0。
可以走http，也可以自己基于tcp协议封装一个长连接。&lt;/p&gt;
&lt;h2 id=&#34;rpc的四个要素&#34;&gt;RPC的四个要素&lt;/h2&gt;
&lt;h3 id=&#34;client&#34;&gt;Client&lt;/h3&gt;
&lt;p&gt;服务调用的发起方&lt;/p&gt;
&lt;h3 id=&#34;client-stub&#34;&gt;Client Stub&lt;/h3&gt;
&lt;p&gt;用于存储要调用的服务器地址、以及将要请求的数据信息打包，通过网络请求发送给Server Stub，然后阻塞，直到接受到返回的数据，然后进行解析。&lt;/p&gt;
&lt;h3 id=&#34;server&#34;&gt;Server&lt;/h3&gt;
&lt;p&gt;Server，包含要调用的方法&lt;/p&gt;
&lt;h3 id=&#34;server-stub&#34;&gt;Server Stub&lt;/h3&gt;
&lt;p&gt;用于接受Client Stub发送的请求数据包并进行解析，完成功能调用，最后将结果进行打包并返回给Client Stub。在没有接受到请求数据包时则处于阻塞状态。&lt;/p&gt;
&lt;p&gt;封装了Client Stub和Server Stub后，从Client的角度来看，似乎和本地调用一样。从Server的角度看，似乎就是客户直接调用。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1643108079/rpc-1.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;rpc的具体通信步骤&#34;&gt;RPC的具体通信步骤&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;Client以类似本地调用的方式调Client Stub&lt;/li&gt;
&lt;li&gt;Client Stub序列化生成消息，然后调用本地操作系统的通信模块， Stub阻塞&lt;/li&gt;
&lt;li&gt;本地操作系统与远程Server进行通信，消息传输到远程操作系统&lt;/li&gt;
&lt;li&gt;远程操作系统将消息传递给Server Stub&lt;/li&gt;
&lt;li&gt;Server Stub进行反序列化，然后调用Server的对应方法&lt;/li&gt;
&lt;li&gt;Server程序执行方法，将结果传递给Server Stub&lt;/li&gt;
&lt;li&gt;Server Stub将结果进行序列化，然后传递给Server操作系统&lt;/li&gt;
&lt;li&gt;Server操作系统将结果传递给Client&lt;/li&gt;
&lt;li&gt;Client操作系统将其交给Client Stub， Stub从阻塞状态恢复&lt;/li&gt;
&lt;li&gt;Client Stub对结果进行反序列化，并将值返回给Client程序&lt;/li&gt;
&lt;li&gt;Client程序获得返回结果&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;RPC就是把2-10步进行了封装。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://pic1.zhimg.com/80/v2-619633f1a8ff09c38a0611b1a0d62afc_1440w.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;一些RPC框架可以通过一个接口定义语言（IDL）定义接口和数据类型，然后自动生成各种语言的stub代码。&lt;/p&gt;
&lt;h2 id=&#34;go的rpcnetrpc&#34;&gt;Go的RPC：net/rpc&lt;/h2&gt;
&lt;h3 id=&#34;使用&#34;&gt;使用&lt;/h3&gt;
&lt;p&gt;Go语言的标准库也提供了一个简单的RPC实现:&lt;code&gt;net/rpc&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Go的RPC规则：&lt;strong&gt;方法只能有两个序列化参数，其中第二个参数是指针类型，并且只能返回一个error类型，同时必须是公开的方法。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;即形式只能为：&lt;code&gt;func (t *T) MethodName(argType T1, replyType *T2) error&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;其中第一个参数是调用者收到的参数，第二个参数是方法返回的参数。如果&lt;/p&gt;
&lt;p&gt;RPC的Hello World：
（ip和端口可视情况调整，Server和Client可以在不同机器上运行）&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// Server.go
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// 先声明Service结构
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;helloService&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{}&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;// 定义一个方法，注意只能两个参数，第二个为指针，返回一个error
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;p&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;helloService&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;Hello&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;request&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;reply&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;error&lt;/span&gt;  &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;reply&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;Hello, &amp;#34;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;request&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;  &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;c1&#34;&gt;// 要注册一个名字
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;nx&#34;&gt;_&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;rpc&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;RegisterName&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;HelloService&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;new&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;helloService&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt;
	&lt;span class=&#34;c1&#34;&gt;// 采用tcp通信
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;nx&#34;&gt;listener&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;net&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Listen&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;tcp&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;:1234&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;log&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Fatal&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;conn&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;listener&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Accept&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;log&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Fatal&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;rpc&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;ServeConn&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;conn&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// Client.go
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;Client&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;rpc&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Dial&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;tcp&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;192.168.50.174:1234&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;log&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Fatal&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
	&lt;span class=&#34;kd&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;reply&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;Client&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Call&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;HelloService.Hello&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;engine&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;reply&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;log&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Fatal&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;fmt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Println&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;reply&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;做一些改进，一方面，Server应该是持续保持连接，并且支持多个Client共同连接，不能Client运行完就断开。另一方面，Client做一些封装，比较方便：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;9
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// Server.go
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;//...
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;nx&#34;&gt;conn&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;listener&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Accept&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
  &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;nx&#34;&gt;log&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Fatal&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
  &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
  &lt;span class=&#34;k&#34;&gt;go&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;rpc&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;ServeConn&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;conn&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;30
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;31
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// Client.go
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;HelloServiceName&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;HelloService&amp;#34;&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;HelloServiceClient&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;rpc&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Client&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;HelloServiceDial&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;network&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;address&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;HelloServiceClient&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;error&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;Client&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;rpc&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Dial&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;network&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;address&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;log&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Fatal&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;HelloServiceClient&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Client&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;Client&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;},&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;h&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;HelloServiceClient&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;Hello&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;request&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;reply&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;error&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;h&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Client&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Call&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;HelloServiceName&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;.Hello&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;request&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;reply&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;hs&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;HelloServiceDial&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;tcp&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;192.168.50.174:1234&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;log&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Fatal&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
	&lt;span class=&#34;kd&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;reply&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;hs&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Hello&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;engine&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;reply&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;log&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Fatal&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;fmt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Println&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;reply&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;标准库的rpc采用go语言特有的gob编码，如果需要跨语言的客户端，则可以采用一种通用的编码格式，比如json，Server端可以通过：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// go rpc.ServeConn(conn)
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;go&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;rpc&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;ServeCodec&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;jsonrpc&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;NewServerCodec&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;conn&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;而客户端可以使用：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;nx&#34;&gt;conn&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;net&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Dial&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;tcp&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;localhost:1234&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;log&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Fatal&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;dial error&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;nx&#34;&gt;client&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;rpc&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;NewClientWithCodec&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;jsonrpc&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;NewClientCodec&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;conn&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;</content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://yichengme.site/categories/%E6%8A%80%E6%9C%AF/" term="技术" label="技术" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://yichengme.site/tags/rpc/" term="RPC" label="RPC" />
                            
                        
                            
                            
                            
                                <category scheme="https://yichengme.site/tags/%E5%88%86%E5%B8%83%E5%BC%8F/" term="分布式" label="分布式" />
                            
                        
                            
                            
                            
                                <category scheme="https://yichengme.site/tags/golang/" term="Golang" label="Golang" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">无线网络基础</title>
            <link rel="alternate" type="text/html" href="https://yichengme.site/posts/wireless-network-basic/" />
            <id>https://yichengme.site/posts/wireless-network-basic/</id>
            <updated>2022-02-27T15:21:54&#43;08:00</updated>
            <published>2022-01-13T17:34:00&#43;08:00</published>
            <author>
                    <name>王毅诚</name>
                    <uri>https://yichengme.site/</uri>
                    <email>engine74396@gmail.com</email>
                    </author>
            <rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">信息论基础 信息是事物运动状态或存在方式的不确定性的描述 通信系统形式上传递的就是信息，需求来源于： ① 需要告知某信息给对方 ② 需要接受某种信息。通信的结果就是消除不确……</summary>
            
                <content type="html">&lt;h2 id=&#34;信息论基础&#34;&gt;信息论基础&lt;/h2&gt;
&lt;p&gt;信息是事物运动状态或存在方式的不确定性的描述&lt;/p&gt;
&lt;p&gt;通信系统形式上传递的就是信息，需求来源于：&lt;/p&gt;
&lt;p&gt;① 需要告知某信息给对方&lt;/p&gt;
&lt;p&gt;② 需要接受某种信息。通信的结果就是消除不确定性或者获得信息。&lt;/p&gt;
&lt;p&gt;信息论研究的目的在于：通过探索信息传输的规律，提高信息传输的有效性、可靠性和保密性，使得信息系统达到最优化。&lt;/p&gt;
&lt;p&gt;数据：传送信息的实体&lt;/p&gt;
&lt;p&gt;信号：数据的电气或电磁表现，数据在传输过程中的存在形式
（连续变化的称为模拟数据/信号，离散变化的数据称为数字数据/信号）&lt;/p&gt;
&lt;p&gt;码元：用一个固定时长的信号波形代表一位k进制数字&lt;/p&gt;
&lt;p&gt;信源：产生和发送数据的源头&lt;/p&gt;
&lt;p&gt;信道：信号的传输媒介
s
信宿：接收数据的终点&lt;/p&gt;
&lt;p&gt;速率：数据的传输速率，表示单位时间内传输的数据量，码元传输速率单位是波特（Baud），信息运输速率单位是 比特/秒 (b/s)&lt;/p&gt;
&lt;p&gt;$$比特/秒 = 波特 \times \log_2电平数$$&lt;/p&gt;
&lt;p&gt;波特：每秒内信息改变的次数，一波特就表示数字通道系统一秒钟传输一个码元&lt;/p&gt;
&lt;p&gt;带宽：指信号具有的频带宽度，单位是赫兹（Hz），表示单位时间内从网络某一点到另一点所能通过的最高数据率，此时单位是bit/s&lt;/p&gt;
&lt;h2 id=&#34;信息量&#34;&gt;信息量&lt;/h2&gt;
&lt;p&gt;信息量 = 不确定性的减少量 = 收信前的不确定性 - 收信后的不确定性&lt;/p&gt;
&lt;p&gt;某个事件发生的信息量是该事件发生的先验概率的函数：&lt;/p&gt;
&lt;p&gt;$$I(a_i) = f[P(a_i)]$$&lt;/p&gt;
&lt;p&gt;有$I(a_0 = 0) = \infty, I(a_0 = 1) = 0$&lt;/p&gt;
&lt;p&gt;独立事件的联合信息量等于各自的信息量之和&lt;/p&gt;
&lt;p&gt;自信息量的计算公式为：&lt;/p&gt;
&lt;p&gt;$$
I(a_i) = \log \frac{1}{P(a_i)}
$$&lt;/p&gt;
&lt;p&gt;以2为底，单位为比特；以e为底，单位为奈特；以10为底，单位为哈特。&lt;/p&gt;
&lt;h2 id=&#34;熵&#34;&gt;熵&lt;/h2&gt;
&lt;p&gt;反应了信源整体的不确定度&lt;/p&gt;
&lt;p&gt;$$
H(x) = -\sum_x p(x)\log p(x)
$$&lt;/p&gt;
&lt;p&gt;联合熵：
$$
H(X, Y) = -\sum_{x,y} p(x,y)\log p(x,y)
$$&lt;/p&gt;
&lt;p&gt;条件熵：
$$
H(X | Y) = - \sum_y H(X|Y=y) p(y) = -\sum_{y} \sum_{x} p(x \mid y) p(y) \log p(x \mid y)
$$&lt;/p&gt;
&lt;p&gt;互信息：
$$
I(X;Y) = \sum_{x,y} p(x,y) \log \frac{p(x,y)}{p(x)p(y)}
$$&lt;/p&gt;
&lt;p&gt;两个独立的随机变量的互信息等于0&lt;/p&gt;
&lt;h2 id=&#34;信源编码与信道编码&#34;&gt;信源编码与信道编码&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1641283110/xxl-1.png&#34; alt=&#34;xxl-1&#34;&gt;&lt;/p&gt;
&lt;p&gt;信号先经过信源编码，然后进入信道前经过信道编码。&lt;/p&gt;
&lt;p&gt;信源编码的作用：信息量的压缩，减少原信号的冗余&lt;/p&gt;
&lt;p&gt;信道编码的作用：信息量的增加，用于增加可靠性&lt;/p&gt;
&lt;p&gt;带宽受限且有高斯白噪声干扰的信道的极限、无差错的信息传输速率&lt;/p&gt;
&lt;h3 id=&#34;无线通信系统&#34;&gt;无线通信系统&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1641799607/transceiver-1.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;源信号依次经过信源编码、加密、信道编码、调制然后发送出去，接受时依次经过解调、信道解码、解密、信源解码然后接受。&lt;/p&gt;
&lt;h2 id=&#34;调制&#34;&gt;调制&lt;/h2&gt;
&lt;p&gt;调制：将某个信息嵌入到另一个信号的过程，比如模拟信号通过采样、量化、数字化编码到数字信号的过程。&lt;/p&gt;
&lt;p&gt;之所以要调制，是为了提高频率，从而让让信号客户要传播的更远，大气层对低频段的损耗非常高。&lt;/p&gt;
&lt;p&gt;信源的信号有很多低频或者直流成分，很多信道不能直接传输。一方面需要调制成高频信号便于天线发射，一方面可以通过多路传输不同的基带信号，如果频率一样可能会干扰（广播的频率不一样就可以同时发射互不干扰）。&lt;/p&gt;
&lt;p&gt;载波调制就是利用载波进行调制，把基带信号的频率搬移到较高的频段。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://img-blog.csdnimg.cn/img_convert/ba2f942c2de172e4e5e707738f3d08f4.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;码元调制&#34;&gt;码元调制&lt;/h2&gt;
&lt;p&gt;码间串扰：在接收端收到的信号波形就失去了码元和符号之间的清晰的界限。&lt;/p&gt;
&lt;p&gt;进行码元/符号调制的目的：用一个码元代表多个比特，在码元速率一定的情况下提高数据传输速率&lt;/p&gt;
&lt;h3 id=&#34;nyquist定理&#34;&gt;Nyquist定理&lt;/h3&gt;
&lt;p&gt;在绝对理想的信道中，极限码元传输速率为$2W$ &lt;em&gt;Baud&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;$W$是理想低通信道的带宽，单位为Hz
$V$是每个码元离散电平的数目，$V$个电平就需要$log_2V$个二进制位&lt;/p&gt;
&lt;p&gt;理想状态下的极限数据传输率 = $2Wlog_2V$ （单位 &lt;em&gt;b/s&lt;/em&gt;）&lt;/p&gt;
&lt;p&gt;超过这个界限就会出现严重的码间串扰&lt;/p&gt;
&lt;h3 id=&#34;香农定理&#34;&gt;香农定理&lt;/h3&gt;
&lt;p&gt;信道的极限数据传输速率 = $Wlog_2(1+S/N)$&lt;/p&gt;
&lt;p&gt;$S$是信道传输的平均功率
$N$为信道内部的高斯噪声功率&lt;/p&gt;
&lt;h3 id=&#34;例子&#34;&gt;例子&lt;/h3&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;带宽为6MHz，量化等级为4，无噪声，求最大传输速率&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;解：使用Nyquist定理，$C = 2 * W * log_2V = 2 * 6 * log_24 = 24Mbps$&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;带宽为3MHz，信噪比为20dB，二进制，求最大数据传输速率&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;解：使用香农定理&lt;/p&gt;
&lt;p&gt;先化$S/N$的单位，$10lg(S/N) = 20 \to S/N = 100 $&lt;/p&gt;
&lt;p&gt;$C= W * log_2{(1+S/N)} = 3 * log_2{(1+100)} \approx 20Kbps$&lt;/p&gt;
&lt;h2 id=&#34;无线信道&#34;&gt;无线信道&lt;/h2&gt;
&lt;p&gt;传播的时候会遇到很多复杂的情况，造成信号的衰弱，根据信号传播的距离分为大尺度衰弱和小尺度衰弱。&lt;/p&gt;
&lt;h3 id=&#34;大尺度衰弱&#34;&gt;大尺度衰弱&lt;/h3&gt;
&lt;p&gt;大尺度衰弱是发射和接受信号的距离较长，数百数千米&lt;/p&gt;
&lt;p&gt;大尺度衰弱包括路径损耗和阴影效应：&lt;/p&gt;
&lt;p&gt;路径损耗：随着路径长度的平方衰减，和方向等参数无关&lt;/p&gt;
&lt;p&gt;阴影损耗：遇到障碍物时，后面的阴影区信号场比较弱，会造成损耗&lt;/p&gt;
&lt;h3 id=&#34;小尺度衰弱&#34;&gt;小尺度衰弱&lt;/h3&gt;
&lt;p&gt;小尺度衰弱是数个或者数十个波长的距离&lt;/p&gt;
&lt;p&gt;小尺度衰弱更为重要，其中造成小尺度衰弱的主要原因有多径效应和多普勒效应&lt;/p&gt;
&lt;p&gt;包括频率选择性衰弱和时变特性&lt;/p&gt;
&lt;p&gt;多径效应：由于电波传递的过程中有各种反射散射等，会导致到达时的信号是由多个状态叠加的，随机分布的幅度、相位、入角等合成之后使得接收到的信号删除衰弱和失真，比如极端情况刚好差半个波长然后刚好抵消（实际基本不可能，但是能说明其影响）&lt;/p&gt;
&lt;p&gt;多普勒效应：是由于接收端和发射端之间的相对移动产生的&lt;/p&gt;
&lt;h3 id=&#34;蜂窝网络&#34;&gt;蜂窝网络&lt;/h3&gt;
&lt;p&gt;单基站覆盖：早期的移动通信是利用高塔上的天线大功率发射，但是业务通道很少&lt;/p&gt;
&lt;p&gt;蜂窝通信网络：减少单个基站的发射功率，多小区覆盖，不同小区之间频率复用（频率复用是蜂窝移动通信的基石）&lt;/p&gt;
&lt;p&gt;同频段小区之间可能会干扰，需要增加同频段小区之间的距离&lt;/p&gt;
&lt;p&gt;不同簇之间使用相同频率的小区的最小距离$D$称为频率再用比例（就是两个相同频率的，看最接近的路径是多大）&lt;/p&gt;
&lt;p&gt;小区切换，设定某个切换门限，低于门限值则进行切换，需要设定一个时间，持续低于这段时间再切换，从而避免乒乓球切换。&lt;/p&gt;
&lt;p&gt;同频组网&lt;/p&gt;
&lt;p&gt;单工：指的是只有一个方向的交互而没有反方向的交互
半双工：双方都可以发送信息，但是不能同时发送或者接受&lt;/p&gt;
&lt;p&gt;半双工分为FDD（频分双工）和TDD（时分双工），FDD就是在不同的频率上同时发送，TDD用时间片轮转。&lt;/p&gt;
&lt;p&gt;全双工：双方可以同时发送和接收消息&lt;/p&gt;
&lt;h3 id=&#34;多址接入方式&#34;&gt;多址接入方式&lt;/h3&gt;
&lt;p&gt;复用：同样的频谱如何重复使用
多址：同样的频谱如何分给不同用户&lt;/p&gt;
&lt;p&gt;多址其实就是要去找一种方式来分割为多个正交的数据流，从而将它们分开。&lt;/p&gt;
&lt;p&gt;频分多址（FDMA）：在频域复用多个数据流，用于多个用户
时分多址（TDMA）：在时域复用多个数据流，用于多个用户
&lt;strong&gt;码分多址（CDMA）&lt;/strong&gt;：在码域复用多个数据流，用于多个用户
空分多址（SDMA）：在空间上用于多个用户&lt;/p&gt;
&lt;p&gt;把每个频谱比作一个房间，FDMA就是不同的用户去不同的方向聊天，TDMA就是依次排队去房间聊天，CDMA就是一窝蜂的一起说话，但是说的语言不同，只要认准自己的语言就能分开从而交流。&lt;/p&gt;
&lt;p&gt;码片序列，将一个比特时间划分成m个短的间隔，称为码片。每个站被指派一个唯一的m bit码片序列，1则为自己的码片，0则发送自己的反码。&lt;/p&gt;
&lt;p&gt;每个站分配的码片序列必须各不相同且相互正交&lt;/p&gt;
&lt;p&gt;扩频技术，之前的一个bit变成了m个bit，发送的数据率是之前的m倍，宽度也提高到m倍&lt;/p&gt;
&lt;p&gt;扩频通信采用直接序列扩频或者跳频扩频
直接序列扩频DSSS是通过比特率高很多的伪码序列对信号进行二次调频的技术&lt;/p&gt;
&lt;p&gt;OFDM：正交频分复用，运行载波之间紧密相邻甚至部分重合，可以实现很高的频谱效率。通过IFFT，人为建立载波间正交性&lt;/p&gt;
&lt;p&gt;OFDM发射机的两个核心模块：IFFT和加入循环前缀CP&lt;/p&gt;
&lt;h3 id=&#34;mimo与波束赋型&#34;&gt;MIMO与波束赋型&lt;/h3&gt;
&lt;h2 id=&#34;传输途径的分类&#34;&gt;传输途径的分类&lt;/h2&gt;
&lt;p&gt;基站和终端的传输途径有SISO、MISO、SIMO、MIMO。&lt;/p&gt;
&lt;p&gt;MISO是基站多个天线发出相同信号，在终端合成一路，是发送分集技术。&lt;/p&gt;
&lt;p&gt;SIMO是一个天线通过两路路径发送信号，终端收到两个信号，数据也一样，是接受分集技术。
MIMO（Multiple Input Multiple Output，多进多出）
实现多路数据并行发送，获得空间复用增益。
实现多个字信号的有效合并，获得空间分集增益。&lt;/p&gt;
&lt;h2 id=&#34;分集与复用&#34;&gt;分集与复用&lt;/h2&gt;
&lt;h3 id=&#34;分集&#34;&gt;分集&lt;/h3&gt;
&lt;p&gt;分集就是把多个独立衰弱的副本提供给接收机，接受机将同一数据流的不同版本进行合并和恢复。减少深度衰弱的概率，从而提高性能。（提高鲁棒性）&lt;/p&gt;
&lt;p&gt;分为空间分集（同一个信息从多根天线上发射出去）、时间分集（同一个信号以超过相干时间间隔重复发送）&lt;/p&gt;
&lt;p&gt;频率分集就是在多个频域上对同一信号进行重复发送&lt;/p&gt;
&lt;p&gt;分集又分为简单分集（完全相同）、编码分集（不同的版本）、选择分集（选择一个信道较好的天线发送）、波束分集等&lt;/p&gt;
&lt;p&gt;空间分集的算法：
空时块码（STBC，Alamouti空时分组码），各个发射天线上的码字满足正交性。因为正交，所以接收端只需要简单处理。&lt;/p&gt;
&lt;p&gt;接收机是2路发送信号与噪声的线性叠加&lt;/p&gt;
&lt;h3 id=&#34;复用&#34;&gt;复用&lt;/h3&gt;
&lt;p&gt;空分复用就是在多条独立的路径上传输不同的数据，提高系统容量。（提高吞吐率）
高速流分为几个低速数据流分别进行编码和调制，然后在不同的天线发送，接收机将不同天线上接受到的数据流进行合并&lt;/p&gt;
</content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://yichengme.site/categories/%E6%8A%80%E6%9C%AF/" term="技术" label="技术" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://yichengme.site/tags/%E9%80%9A%E4%BF%A1/" term="通信" label="通信" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">凸优化（五）算法</title>
            <link rel="alternate" type="text/html" href="https://yichengme.site/posts/convex-5/" />
            <id>https://yichengme.site/posts/convex-5/</id>
            <updated>2022-02-27T15:21:55&#43;08:00</updated>
            <published>2022-01-11T01:09:12&#43;08:00</published>
            <author>
                    <name>王毅诚</name>
                    <uri>https://yichengme.site/</uri>
                    <email>engine74396@gmail.com</email>
                    </author>
            <rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">包括无约束优化问题、带等式约束和不等式约束的凸优化问题的求解 无约束优化问题 无约束优化问题： $$ \text { minimize } f_0(x) $$ 对于凸问题而言，只有一个条件 $$ \nabla f (x^{\star}) = 0 $$ 强凸性 存在一个……</summary>
            
                <content type="html">&lt;p&gt;包括无约束优化问题、带等式约束和不等式约束的凸优化问题的求解&lt;/p&gt;
&lt;h2 id=&#34;无约束优化问题&#34;&gt;无约束优化问题&lt;/h2&gt;
&lt;p&gt;无约束优化问题：&lt;/p&gt;
&lt;p&gt;$$
\text { minimize } f_0(x)
$$&lt;/p&gt;
&lt;p&gt;对于凸问题而言，只有一个条件&lt;/p&gt;
&lt;p&gt;$$
\nabla f (x^{\star}) = 0
$$&lt;/p&gt;
&lt;h3 id=&#34;强凸性&#34;&gt;强凸性&lt;/h3&gt;
&lt;p&gt;存在一个大于0的$m$，使得&lt;/p&gt;
&lt;p&gt;$$\forall x \in C, \nabla ^2 f(x) \geq mI$$
$$
f(y) = f(x) + \nabla f(x)^T (y-x) + \frac{m}2||x-y||_2^2 \newline
f(x) - p^{\star} \leq \frac{1}{2m} ||\nabla f(x)||_2^2
$$&lt;/p&gt;
&lt;p&gt;强凸性的性质：任何梯度足够小的点都是近似最优解（结束条件）&lt;/p&gt;
&lt;h3 id=&#34;下降法&#34;&gt;下降法&lt;/h3&gt;
&lt;p&gt;通用的求解方法都是迭代的下降方法，所谓下降，也就是每次迭代，后一个值都比前一个值对应的目标函数值要低，所以是下降。对于前一个值$x^{k}$，寻找一个方向$d^k$和步长$\alpha^k$，下一个值就是$x^{k+1} = x^k + \alpha^k d^k $，初始点、搜索方向、迭代步长也称为迭代搜索法的三要素。&lt;/p&gt;
&lt;p&gt;由于无约束条件，初始点满足以下两项即可：
① $x^0 \in dom f$
② 下水平集是一个闭集&lt;/p&gt;
&lt;p&gt;初始点确定之后，还需要选择下降方向、步长、终止条件等&lt;/p&gt;
&lt;h3 id=&#34;线搜索&#34;&gt;线搜索&lt;/h3&gt;
&lt;p&gt;$$
x^{k+1} = x^k + \alpha^k d^k
$$&lt;/p&gt;
&lt;p&gt;$d^{k}$是搜索方向。&lt;/p&gt;
&lt;p&gt;希望能在这个方向上有个最大的下降，也就是找到
$$
\alpha^k = \text{argmin}_{\alpha} f(x^k + \alpha^k d^k)
$$
但是实际上相当于每次下降都引入了一个新的优化问题，虽然效果好但是计算量很大。&lt;/p&gt;
&lt;h3 id=&#34;带backtracing的线搜索&#34;&gt;带Backtracing的线搜索&lt;/h3&gt;
&lt;p&gt;算法：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;令步长$t$为允许的最大步长&lt;/li&gt;
&lt;li&gt;如果$f(x^k + t \Delta x) &amp;gt; f(x^k) + \alpha t \nabla f(x^k) \Delta x$（也就是说步长太大了，导致下降的一段比$\alpha * $斜率的长度还小，那就减少步长，右式后面是负数）&lt;/li&gt;
&lt;li&gt;让$t = \beta t$&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;通常$\alpha $取0.5，$\beta$取一个0-1之间的数&lt;/p&gt;
&lt;p&gt;这样就能找到一个比较合适的步长，而不需要非常高的计算量。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1641534854/convex-12.png&#34; alt=&#34;convex-12&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;梯度下降法最速下降法&#34;&gt;梯度下降法（最速下降法）&lt;/h3&gt;
&lt;p&gt;思想很简单，沿着梯度（梯度方向是函数值增加的方向）的反方向走，就可以使目标函数不断减少。&lt;/p&gt;
&lt;p&gt;就像是下山，每次都沿着下降最快的方向走，最后一定能走到局部最低点（如果是凸函数就是全局最低点）&lt;/p&gt;
&lt;p&gt;至于搜索步长，则选择这个一维方向搜索的最佳步长，因此，最速下降法的两个相邻迭代点的函数梯度相互垂直&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1641534854/convex-13.png&#34; alt=&#34;convex-13&#34;&gt;&lt;/p&gt;
&lt;p&gt;优点是可以沿着最快的方向，缺点是关注不到全局的情况，不关注下一个点的情况。&lt;/p&gt;
&lt;p&gt;梯度下降法步骤：
输入：目标函数，目标函数梯度
输出：极小点&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;初始化$x^0$&lt;/li&gt;
&lt;li&gt;计算搜索方向$d^k = - \nabla f(x^{k})$&lt;/li&gt;
&lt;li&gt;如果小于$\epsilon$就停止迭代，否则就沿着$d^k$进行一维搜索，求最佳步长$\lambda^k$：
$$
f(x^k + \lambda^k d^k) = \min_{\lambda \geq 0} f(x^k + \lambda d^k)
$$&lt;/li&gt;
&lt;li&gt;令$x^{k+1} = x^k + \lambda^k d^k$，转步骤2&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;选择最优步长的计算代价比较高&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;用最速下降法求目标函数$f(x) = x_1^2 + 25x_2^2$在$[2,2]^T$处的最速下降方向和步长
解：取初始点$x^0 = [2,2]^T$
初始点函数值和梯度分别为：
$f(x^0) = 104$
$\nabla f(x^0) = [4, 100]^T$
沿负梯度方向进行一维搜索：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;$$x^1 = x^0 - \alpha^0 \nabla f(x^0) = [2-4\alpha^0, 2-100\alpha^0]^T$$&lt;/p&gt;
&lt;p&gt;$\alpha^0$需要满足极值条件：&lt;/p&gt;
&lt;p&gt;$$
\min_\alpha f(x^1) = \min_\alpha ((2-4\alpha)^2 + 25 (2-100\alpha)^2)
$$&lt;/p&gt;
&lt;p&gt;解得$\alpha_0 = 0.02003$&lt;/p&gt;
&lt;h3 id=&#34;牛顿法&#34;&gt;牛顿法&lt;/h3&gt;
&lt;p&gt;牛顿法（Newton&#39;s Method）是一个非常有效的非线性方差的求根方法，主要用于求方程的根和求解最优化问题。&lt;/p&gt;
&lt;p&gt;利用牛顿法，可以迭代求解非常复杂的方程的根：
$$
f(x) = f(x_0) + f&#39;(x_0)(x-x_0) + O((x-x_0)^2)\newline
$$
忽略截断误差后令$f(x)=0$可解得：
$$
x_1 = x_0 - \frac{f(x_0)}{f&#39;(x_0)}
$$
$x_1$一定比$x_0$更接近真实根，从而不断迭代&lt;/p&gt;
&lt;p&gt;对于最优化问题的求解&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;牛顿法的推导&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;当前点$v$，下降向量$v$，下降后的值为：&lt;/p&gt;
&lt;p&gt;$$
f(x+v) \approx f(x)+\nabla f(x)^{T} v+\frac{1}2 v^{T} \nabla^2 f(x) v
$$&lt;/p&gt;
&lt;p&gt;要使该值最小，且$x$已经固定，关于$v$求偏导：&lt;/p&gt;
&lt;p&gt;$$
\nabla f(x)+\nabla^2 f(x) v=0
$$&lt;/p&gt;
&lt;p&gt;得到：&lt;/p&gt;
&lt;p&gt;$$
\Delta x_{nt} = v=-\nabla^2 f(x)^{-1} \nabla f(x)
$$&lt;/p&gt;
&lt;p&gt;从而推出&lt;strong&gt;牛顿法的迭代公式：&lt;/strong&gt;
$$
x^{k+1} = x^k + \Delta x_{nt} = x^k -\nabla^2 f(x)^{-1} \nabla f(x)
$$&lt;/p&gt;
&lt;p&gt;$\nabla^2 f(x)$是$f(x)$的Hessian矩阵&lt;/p&gt;
&lt;p&gt;一维时有：
$$
x^{k+1} = x^k - \frac{f&#39;(x^k)}{f&#39;&#39;(x^k)}
$$&lt;/p&gt;
&lt;p&gt;多元函数保留到二次项得到：
$$
f(x) = f(x^k) + \nabla f(x^k)^T(x-x^k) + \frac{1}2 (x-x^k)^T \nabla^2 f(x^k)(x-x^k)
$$
其中$\nabla^2 f(x^k)$是点$x^k$处的海森矩阵
通过求导得到平稳点，解得
$$
x^{k+1} = x^k - [\nabla^2 f(x^k)]^{-1}\nabla f(x^k)
$$&lt;/p&gt;
&lt;p&gt;求解无约束优化问题&lt;/p&gt;
&lt;p&gt;牛顿法用二阶海森矩阵的逆矩阵求解，收敛更快但是每次迭代的计算时间更长&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;求目标函数$f(x) = x_1^2 + 25x_2^2$在$[2,2]^T$处的牛顿方向&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;解：初始点梯度$\nabla f(x_0) = [2x_1\ 50x_2]^T = [4\ 100]^T$
$$
\nabla^2 f(x^0)=\left[\begin{array}{cc}
2 &amp;amp; 0 \newline
0 &amp;amp; 50
\end{array}\right]
$$
$$
[\nabla^2 f(x^0)]^{-1}=\left[\begin{array}{cc}
\frac{1}2 &amp;amp; 0 \newline
0 &amp;amp; \frac{1}{50}
\end{array}\right]
$$
牛顿方向为
$$- [\nabla^2 f(x^k)]^{-1}\nabla f(x^k) = -\left[\begin{array}{cc}
\frac{1}2 &amp;amp; 0 \newline
0 &amp;amp; \frac{1}{50}
\end{array}\right] \left[\begin{array}{cc}
4 \newline
100
\end{array}\right] = \left[\begin{array}{cc}
-2 \newline
-2
\end{array}\right]$$&lt;/p&gt;
&lt;h3 id=&#34;阻尼牛顿法&#34;&gt;阻尼牛顿法&lt;/h3&gt;
&lt;p&gt;增加了沿牛顿方向的一维搜索，步长$\lambda_k$由一维搜索得到，每次迭代必然下降，不过会增大计算量&lt;/p&gt;
&lt;h3 id=&#34;共轭梯度法&#34;&gt;共轭梯度法&lt;/h3&gt;
&lt;p&gt;$A$是对称正定矩阵，如果有两个方向$d^i, d^j$满足$(d^{i})^T A d^j$，则称这组方向是$A$共轭的
（如果$A$是单位阵，则称两个方向正交）&lt;/p&gt;
&lt;p&gt;依次沿着$d^i$和$d^j$进行一维搜索，经过两次迭代必定到达极小点&lt;/p&gt;
&lt;h3 id=&#34;拟牛顿法&#34;&gt;拟牛顿法&lt;/h3&gt;
&lt;p&gt;计算海森矩阵的逆比较复杂，通过一个$n$阶矩阵来近似代替，就是拟牛顿法的思想。&lt;/p&gt;
&lt;p&gt;$p^k \approx \nabla^2 f(x^{k+1})^{-1}q^k$&lt;/p&gt;
&lt;h2 id=&#34;带等式约束的凸优化问题&#34;&gt;带等式约束的凸优化问题&lt;/h2&gt;
&lt;p&gt;对于带等式约束的凸优化问题：
$$
\begin{array}{ll}
\text{ minimize } &amp;amp; f_0(x) \newline
\text { subject to } &amp;amp; Ax = b
\end{array}
$$&lt;/p&gt;
&lt;p&gt;带等式约束的凸优化问题通常可以采用下面三种方法进行求解：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;消除等式约束&lt;/li&gt;
&lt;li&gt;利用无约束优化方法求解对偶问题&lt;/li&gt;
&lt;li&gt;拓展的Newton法&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;消除等式约束&#34;&gt;消除等式约束&lt;/h3&gt;
&lt;p&gt;等式约束为$Ax = b$&lt;/p&gt;
&lt;p&gt;满足此约束的$x$可以写为$Fy + \hat{x}$的形式，最后变成了：
$$
\text{ minimize } f_0(Fy + \hat{x})
$$&lt;/p&gt;
&lt;p&gt;的无约束优化问题，解得最优解$y^{\star}$之后，就可以通过$x^{\star} = Fy^{\star} + \hat{x}$计算出$x^{\star}$&lt;/p&gt;
&lt;p&gt;比如：
$$
\begin{array}{ll}
\text{ minimize } &amp;amp; f_{1}\left(x_{1}\right)+f_2\left(x_2\right)+\cdots+f_{n}\left(x_{n}\right) \newline
\text { subject to } &amp;amp; x_{1}+x_2+\cdots+x_{n}=b
\end{array}
$$&lt;/p&gt;
&lt;p&gt;可以通过 $x_n = b - x_1 - ... - x_{n-1}$
令$\hat{x} = b e_n$, $F = \left[\begin{array}{c}
I \newline
-\mathbf{1}^{T}
\end{array}\right] \in \mathbf{R}^{n \times(n-1)}$&lt;/p&gt;
&lt;p&gt;问题变为：&lt;/p&gt;
&lt;p&gt;$$
\text{minimize}\  f_{1}\left(x_{1}\right)+\cdots+f_{n-1}\left(x_{n-1}\right)+f_{n}\left(b-x_{1}-\cdots-x_{n-1}\right)
$$&lt;/p&gt;
&lt;h3 id=&#34;通过对偶的方式转换为无约束问题&#34;&gt;通过对偶的方式转换为无约束问题&lt;/h3&gt;
&lt;p&gt;也就是前面对偶的解法&lt;/p&gt;
&lt;p&gt;$$g(v) = -b^T + \inf_x (f(x) + v^T Ax) = -b^Tv - f^{\star} (-A^T v)$$&lt;/p&gt;
&lt;p&gt;其中$f^{\star}$是$f$的共轭，通过解对偶问题：&lt;/p&gt;
&lt;p&gt;$$
\text{maximize}\ -b^T v - f^{\star} (-A^T v)
$$&lt;/p&gt;
&lt;p&gt;就可以使用无约束的优化方法来求解&lt;/p&gt;
&lt;p&gt;通过KKT条件可以知道，最优解$x^{\star}$满足：
$$
Ax^{\star} = b \newline
\nabla f(x^{\star}) + A^T v^{\star} = 0
$$&lt;/p&gt;
&lt;h3 id=&#34;拓展newton法&#34;&gt;拓展Newton法&lt;/h3&gt;
&lt;p&gt;牛顿法除了求解无约束优化问题外，也可以用于求解带等式约束的凸优化问题。&lt;/p&gt;
&lt;p&gt;在此之前先讨论等式约束凸二次规划问题：
$$
\begin{array}{ll}
\text{ minimize } &amp;amp; f(x)=(1 / 2) x^{T} P x+q^{T} x+r \newline
\text { subject to } &amp;amp; A x=b,
\end{array}
$$&lt;/p&gt;
&lt;p&gt;其KKT条件是：
$Ax^{\star} = b, Px^{\star} + q + A^T v^{\star} = 0$&lt;/p&gt;
&lt;p&gt;可以写成矩阵形式：
$$
\left[\begin{array}{cc}
P &amp;amp; A^{T} \newline
A &amp;amp; 0
\end{array}\right]\left[\begin{array}{l}
x^{\star} \newline
\nu^{\star}
\end{array}\right]=\left[\begin{array}{c}
-q \newline
b
\end{array}\right]
$$&lt;/p&gt;
&lt;p&gt;也称为KKT矩阵&lt;/p&gt;
&lt;p&gt;这里有等式约束的拓展牛顿法与无约束的牛顿法不同的是需要保证牛顿方向$\Delta x_{nt}$是可行的，也就是：$A \Delta x_{nt} = 0$&lt;/p&gt;
&lt;p&gt;等式约束问题：
$$
\begin{array}{ll}
\text{ minimize } &amp;amp; f(x) \newline
\text { subject to } &amp;amp; Ax = b
\end{array}
$$&lt;/p&gt;
&lt;p&gt;在可行点$x$处的牛顿方向$\Delta x_{nt}$，目标函数转换为二阶近似：
$$
\begin{array}{ll}
\text{ minimize } &amp;amp; f(x+v) = f(x) + \nabla f(x)^T v + (1/2) v^T \nabla^2 f(x) v\newline
\text { subject to } &amp;amp; A(x+v) = b
\end{array}
$$&lt;/p&gt;
&lt;p&gt;这里的KKT矩阵是：&lt;/p&gt;
&lt;p&gt;$$
\left[\begin{array}{cc}
\nabla^2 f(x) &amp;amp; A^{T} \newline
A &amp;amp; 0
\end{array}\right]\left[\begin{array}{c}
\Delta x_{\mathrm{nt}} \newline
w
\end{array}\right]=\left[\begin{array}{c}
-\nabla f(x) \newline
0
\end{array}\right]
$$&lt;/p&gt;
&lt;p&gt;等式约束的牛顿减量定义为：
$$
\lambda(x)=\left(\Delta x_{\mathrm{nt}}^{T} \nabla^2 f(x) \Delta x_{\mathrm{nt}}\right)^{1 / 2}
$$&lt;/p&gt;
&lt;p&gt;等式约束优化问题的牛顿法：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;计算牛顿方向$\Delta x_{nt}$和牛顿减量$\lambda(x)$&lt;/li&gt;
&lt;li&gt;如果$\frac{\lambda^2}2 \leq \epsilon$就退出&lt;/li&gt;
&lt;li&gt;直线搜索确定步长&lt;/li&gt;
&lt;li&gt;$x = x+t \Delta x_{nt}$&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;带不等式约束的凸优化问题&#34;&gt;带不等式约束的凸优化问题&lt;/h2&gt;
&lt;p&gt;带不等式约束的凸优化问题，通过障碍法将不等式约束加入目标函数，从而把问题转换为带等式约束的优化问题，从而可以使用上一节的方法进行求解。&lt;/p&gt;
&lt;p&gt;对于凸优化问题：
$$
\begin{array}{ll}
\text{ minimize } &amp;amp; f_0(x) \newline
\text { subject to } &amp;amp; f_{i}(x) \leq 0, \quad i=1, \ldots, m \newline
&amp;amp; Ax = b
\end{array}
$$&lt;/p&gt;
&lt;p&gt;对数障碍法：&lt;/p&gt;
&lt;p&gt;将其转换为等式约束问题：
$$
\begin{array}{ll}
\text{ minimize } &amp;amp; f_0(x) + \sum_{i=0}^m I_-(f_i(x)) \newline
\text { subject to } &amp;amp; Ax = b
\end{array}
$$&lt;/p&gt;
&lt;p&gt;其中
$$I_- (x) = \left \{  \begin{array}{ll} 0 &amp;amp; \text{if } x \leq 0 \newline \infty &amp;amp; \text{otherwise} \end{array}   \right . $$&lt;/p&gt;
&lt;p&gt;也就是说不满足不等式约束的话，就让目标函数无限大，否则就没影响。
但是这个函数不可导，所以采用一个对数函数来近似：&lt;/p&gt;
&lt;p&gt;$$I_- (x) = -\frac{1}{t} log(-x)$$&lt;/p&gt;
&lt;p&gt;定义$\phi(x) =  - \sum_{i=1}^m \log(-f_i(x))$为对数障碍函数，其梯度为：
$$
\nabla \phi(x) = \sum_{i=1}^m \frac{1}{-f_i(x)} \nabla f_i(x)
$$
其Hessian矩阵为：
$$
\nabla^2 \phi(x)=\sum_{i=1}^{m} \frac{1}{-f_{i}(x)} \nabla^2 f_{i}(x)+\sum_{i=1}^{m} \frac{1}{f_{i}(x)^2} \nabla f_{i}(x) \nabla f_{i}(x)^{T}
$$&lt;/p&gt;
&lt;h2 id=&#34;例题&#34;&gt;例题&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;给定函数$f(x)=(6+x_1+x_2)^2+(2-3x_1-3x_2-x_1x_2)^2$，求在点$(\hat{X}=(-4,6)^T)$处的牛顿方向$d$&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;$$
\nabla^T f(x) = \left [ \begin{array}{cc} 2(6 + x_1 + x_2) + 2(2-3x_1 - 3x_2 - x_1 x_2 )(-3-x_2) \newline 2(6 + x_1 + x_2) + 2(2-3x_1 - 3x_2 - x_1 x_2 )(-3-x_2) \end{array} \right ] = \left [ \begin{array}{cc} -344 \newline 56 \end{array} \right ]
$$&lt;/p&gt;
&lt;p&gt;$$
\nabla^2 f(x) = \left [ \begin{array}{cc} 2 + 2(3+x_2)^2 &amp;amp; 2 + 2(3+x_1)(3+x_2) -2 (2-3x_1 - 3x_2 -x_1 x_2)\newline 2 + 2(3+x_2)(3+x_1) -2 (2-3x_1 - 3x_2 -x_1 x_2) &amp;amp; 2 + 2(3+x_1)^2 \end{array} \right ] = \left [ \begin{array}{cc} 164 &amp;amp; -56 \newline -56 &amp;amp; 4 \end{array} \right ]
$$&lt;/p&gt;
&lt;p&gt;$$
[\nabla^2 f(x)]^{-1} = -\frac{1}{2480} \left [ \begin{array}{cc} 4 &amp;amp; 56 \newline 56 &amp;amp; 164 \end{array} \right ]
$$&lt;/p&gt;
&lt;p&gt;$$
\begin{array}{ll}
\triangle x_{nt} &amp;amp;= -(\nabla^2 f(x))^{-1} \nabla f^T(x)\newline
&amp;amp;=\frac{1}{2480} \left [ \begin{array}{cc} 4 &amp;amp; 56 \newline 56 &amp;amp; 164 \end{array} \right ] \left [ \begin{array}{cc} -344 \newline 56 \end{array} \right ] = \left [ \begin{array}{cc} -0.709677 \newline 4.064516 \end{array} \right ]
\end{array}
$$&lt;/p&gt;
&lt;p&gt;牛顿方向为$d = \left [ \begin{array}{cc} -0.709677 \newline 4.064516 \end{array} \right ]$&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;利用牛顿法求解$\min f(x) = (x_1 - 4)^2 + x_2^4$并给出迭代过程，初始点为$[0\ 1]^T$&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;第一次迭代：
$$
\nabla^T f(x^0) = \left [ \begin{array}{cc} 2(x_1 -4)\newline 4x_2^3 \end{array} \right ] = \left [ \begin{array}{cc} -8 \newline 4 \end{array} \right ]
$$&lt;/p&gt;
&lt;p&gt;$$
\nabla^2 f(x^0) = \left [ \begin{array}{cc} 2 &amp;amp; 0\newline 0 &amp;amp; 12x_2^2 \end{array} \right ] = \left [ \begin{array}{cc} 2 &amp;amp; 0\newline 0 &amp;amp; 12 \end{array} \right ]
$$&lt;/p&gt;
&lt;p&gt;$$
[\nabla^2 f(x^0)]^{-1} = \left [ \begin{array}{cc} \frac{1}2 &amp;amp; 0 \newline 0 &amp;amp; \frac{1}{12} \end{array} \right ]
$$&lt;/p&gt;
&lt;p&gt;$$
\begin{array}{ll}
x^1 &amp;amp;= x^0 + \triangle x^0_{nt} = x^0 -(\nabla^2 f(x^0))^{-1} \nabla f^T(x^0)\newline
&amp;amp;=\left [ \begin{array}{cc} 0 \newline 1 \end{array} \right ] - \left [ \begin{array}{cc} \frac{1}2 &amp;amp; 0 \newline 0 &amp;amp; \frac{1}{12} \end{array} \right ]  \left [ \begin{array}{cc} -8 \newline 4 \end{array} \right ] = \left [ \begin{array}{cc} 4 \newline \frac2{3} \end{array} \right ]
\end{array}
$$&lt;/p&gt;
&lt;p&gt;第二次迭代：&lt;/p&gt;
&lt;p&gt;$$
\nabla^T f(x^1) = \left [ \begin{array}{cc} 2(x_1 -4)\newline 4x_2^3 \end{array} \right ] = \left [ \begin{array}{cc} 0 \newline \frac{32}{27} \end{array} \right ]
$$&lt;/p&gt;
&lt;p&gt;$$
\nabla^2 f(x^1) = \left [ \begin{array}{cc} 2 &amp;amp; 0\newline 0 &amp;amp; 12x_2^2 \end{array} \right ] = \left [ \begin{array}{cc} 2 &amp;amp; 0\newline 0 &amp;amp; \frac{16}{3} \end{array} \right ]
$$&lt;/p&gt;
&lt;p&gt;$$
[\nabla^2 f(x^1)]^{-1} = \left [ \begin{array}{cc} \frac{1}2 &amp;amp; 0 \newline 0 &amp;amp; \frac{3}{16} \end{array} \right ]
$$&lt;/p&gt;
&lt;p&gt;$$
\begin{array}{ll}
x^2 &amp;amp;= x^1 + \triangle x^1_{nt} = x^1 -(\nabla^2 f(x^1))^{-1} \nabla f^T(x^1)\newline
&amp;amp;=\left [ \begin{array}{cc} 4 \newline \frac2{3} \end{array} \right ] - \left [ \begin{array}{cc} \frac{1}2 &amp;amp; 0 \newline 0 &amp;amp; \frac{3}{16} \end{array} \right ]  \left [ \begin{array}{cc} 0 \newline \frac{32}{27} \end{array} \right ] = \left [ \begin{array}{cc} 4 \newline \frac{4}{9} \end{array} \right ]
\end{array}
$$&lt;/p&gt;
&lt;p&gt;第三次迭代：
同理
$$
\begin{array}{ll}
x^3 &amp;amp;= x^2 + \triangle x^2_{nt} = x^2 -(\nabla^2 f(x^2))^{-1} \nabla f^T(x^2)\newline
&amp;amp;=\left [ \begin{array}{cc} 4 \newline \frac{4}{9} \end{array} \right ] - \left [ \begin{array}{cc} \frac{1}2 &amp;amp; 0 \newline 0 &amp;amp; \frac{27}{64} \end{array} \right ]  \left [ \begin{array}{cc} 0 \newline \frac{256}{729} \end{array} \right ] = \left [ \begin{array}{cc} 4 \newline \frac{8}{27} \end{array} \right ]
\end{array}
$$&lt;/p&gt;
&lt;p&gt;之后同理&lt;/p&gt;
</content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://yichengme.site/categories/%E6%8A%80%E6%9C%AF/" term="技术" label="技术" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://yichengme.site/tags/%E5%87%B8%E4%BC%98%E5%8C%96/" term="凸优化" label="凸优化" />
                            
                        
                            
                            
                            
                                <category scheme="https://yichengme.site/tags/%E6%95%B0%E5%AD%A6/" term="数学" label="数学" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">凸优化（四）对偶</title>
            <link rel="alternate" type="text/html" href="https://yichengme.site/posts/convex-4/" />
            <id>https://yichengme.site/posts/convex-4/</id>
            <updated>2022-02-27T15:21:55&#43;08:00</updated>
            <published>2022-01-09T21:25:05&#43;08:00</published>
            <author>
                    <name>王毅诚</name>
                    <uri>https://yichengme.site/</uri>
                    <email>engine74396@gmail.com</email>
                    </author>
            <rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">Lagrange函数 原优化问题： $$ \begin{array}{ll} \text{ minimize } &amp;amp; f_0(x) \newline \text { subject to } &amp;amp; f_{i}(x) \leq 0, \quad i=1, \ldots, m \newline &amp;amp; h_i(x) = 0, \quad i=1, \ldots, p \end{array} $$ Lagrange函数是在优化目标中考虑约束条件，添加约束条件的加……</summary>
            
                <content type="html">&lt;h2 id=&#34;lagrange函数&#34;&gt;Lagrange函数&lt;/h2&gt;
&lt;p&gt;原优化问题：&lt;/p&gt;
&lt;p&gt;$$
\begin{array}{ll}
\text{ minimize } &amp;amp; f_0(x) \newline
\text { subject to } &amp;amp; f_{i}(x) \leq 0, \quad i=1, \ldots, m \newline
&amp;amp; h_i(x) = 0, \quad i=1, \ldots, p
\end{array}
$$&lt;/p&gt;
&lt;p&gt;Lagrange函数是在优化目标中考虑约束条件，添加约束条件的加权和：&lt;/p&gt;
&lt;p&gt;$$L(x, \lambda, v) = f_0(x) + \sum^m_{i=1}\lambda_if_i(x) + \sum^p_{i=1}v_i h_i(x)$$&lt;/p&gt;
&lt;p&gt;其中包含三个自变量，$x$是原来优化问题的自变量，$\lambda$对应不等式约束，向量维度和不等式约束个数相同，$v$对应等式约束，向量维度和等式约束个数相同&lt;/p&gt;
&lt;p&gt;如果$x$确定了，对于$\lambda$和$v$相当于线性函数&lt;/p&gt;
&lt;h2 id=&#34;拉格朗日对偶函数&#34;&gt;拉格朗日对偶函数&lt;/h2&gt;
&lt;p&gt;拉格朗日对偶函数的形式为：&lt;/p&gt;
&lt;p&gt;$$g(\lambda, v) = \inf_{x \in \mathcal{D}} L(x, \lambda, v) = \inf_{x \in \mathcal{D}}(f_0(x) + \sum^m_{i=1}\lambda_if_i(x) + \sum^p_{i=1}v_i h_i(x))$$&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. 不管原问题是什么问题，对偶函数一定是凹函数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;因为是取inf的分段线性函数&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2. 对偶函数构成了原优化问题的下界，也就是$g(\lambda, v) \leq p^\star $&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;$p^\star $是原优化问题的最优值&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;证明：
假设最优解为$x^\star $，对应的最优值是$f_0(x^\star ) = p^\star $，最优解必然满足约束：
$$
f_i(x) \leq 0, g_i(x) = 0 \to
\sum^m_{i=1}\lambda_if_i(x) + \sum^p_{i=1}v_i h_i(x) \leq 0
$$
将最优解$x^\star $代入拉格朗日函数：
$$
\begin{array}{ll}
L(x^\star , \lambda, v) &amp;amp;=  f_0(x^\star ) + \sum^m_{i=1}\lambda_if_i(x^\star ) + \sum^p_{i=1}v_i h_i(x^\star ) \newline &amp;amp;\leq p^\star  g(\lambda, v) \leq L(x^\star , \lambda, v) \leq p^\star
\end{array}
$$&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;为了获得最大的下界，可以对$g$求极大，极大化凹函数也是一个凸问题。也就是将原问题转变为求解它的对偶函数：&lt;/p&gt;
&lt;p&gt;$$
\begin{array}{ll}
\text{ maximize } &amp;amp; g(\lambda, v) \newline
\text { subject to } &amp;amp; \lambda \geq 0
\end{array}
$$&lt;/p&gt;
&lt;p&gt;拉格朗日对偶问题的最优解$d^\star $，对应的解称为最优拉格朗日乘子$\lambda^\star , v^\star $
原问题的最优解$p^\star $，有以下式子成立：&lt;/p&gt;
&lt;p&gt;$$
\begin{array}{ll}
d^\star  \leq p^\star
\end{array}
$$&lt;/p&gt;
&lt;h3 id=&#34;例&#34;&gt;例&lt;/h3&gt;
&lt;p&gt;$$
\begin{array}{ll}
\text { minimize } &amp;amp; x^T x \newline
\text { subject to } &amp;amp; Ax = b
\end{array}
$$&lt;/p&gt;
&lt;p&gt;其拉格朗日函数为：（这里没有不等式约束，所以没有$\lambda$只有$v$）
$$
L(x, v) = x^T x + v^T(Ax - b )
$$&lt;/p&gt;
&lt;p&gt;拉格朗日对偶函数为
$$
g(v) = \inf_{x \in \mathcal{D}} L(x, v) = \inf_{x \in \mathcal{D}} x^T x + v^T Ax - v^T b
$$&lt;/p&gt;
&lt;p&gt;求极小值有：&lt;/p&gt;
&lt;p&gt;$$\frac{\partial L(x, v)}{\partial x} = 2x + A^T v = 0 \to x = - \frac{A^T v}2$$&lt;/p&gt;
&lt;p&gt;代入$x$有&lt;/p&gt;
&lt;p&gt;$$
\frac{v^T AA^Tv}{4} - \frac{v^T AA^Tv}2 - v^Tb = -\frac{v^T AA^Tv}{4} - bv^T
$$&lt;/p&gt;
&lt;p&gt;变成了一个关于$v$的凹二次函数&lt;/p&gt;
&lt;h3 id=&#34;例-1&#34;&gt;例&lt;/h3&gt;
&lt;p&gt;$$
\begin{array}{ll}
\text { minimize } &amp;amp; c^T x \newline
\text { subject to } &amp;amp; Ax = b \newline
&amp;amp; x \geq 0
\end{array}
$$&lt;/p&gt;
&lt;p&gt;先转换为标准形式：
$$
\begin{array}{ll}
\text { minimize } &amp;amp; c^T x \newline
\text { subject to } &amp;amp; Ax - b = 0 \newline
&amp;amp;  -x \leq 0
\end{array}
$$&lt;/p&gt;
&lt;p&gt;拉格朗日函数为：
$$
L(x, \lambda, v) = c^T x - \lambda^T x + v^T(Ax-b) = -b^Tv + (c + A^T v - \lambda)x
$$&lt;/p&gt;
&lt;p&gt;是$x$的线性函数，如果$x$系数是0，那么极小值就是$-b^Tv$，如果不是0，那么就是$-\infty$&lt;/p&gt;
&lt;p&gt;拉格朗日对偶函数为：
$$
g(\lambda, v) = \inf_x L(x, \lambda, v) = \begin{cases}
-b^T v , &amp;amp; \text{if } A^Tv + c - \lambda = 0\newline
-\infty, &amp;amp; \text{otherwise } \end{cases} $$&lt;/p&gt;
&lt;p&gt;上面是仿射函数，加上其他情况的负无穷拓展是凹函数&lt;/p&gt;
&lt;p&gt;要求它的极大值，负无穷的情况可以直接不考虑，也就是原问题转换为：
$$
\begin{array}{ll}
\text { max } &amp;amp; -b^T v \newline
\text { subject to } &amp;amp; \lambda \geq 0 \newline
&amp;amp; A^Tv + c - \lambda = 0
\end{array}
$$&lt;/p&gt;
&lt;p&gt;即：
$$
\begin{array}{ll}
\text { max } &amp;amp; -b^T v \newline
\text { subject to } &amp;amp; A^Tv + c \geq 0
\end{array}
$$&lt;/p&gt;
&lt;p&gt;和原问题的最优解相同，最优值不同&lt;/p&gt;
&lt;h3 id=&#34;例-2&#34;&gt;例&lt;/h3&gt;
&lt;p&gt;$$
\begin{array}{ll}
\text { minimize } &amp;amp; f_0(x) \newline
\text { subject to } &amp;amp; Ax \leq b \newline
&amp;amp; cx = d
\end{array}
$$&lt;/p&gt;
&lt;p&gt;拉格朗日函数为：
$$
L(x, \lambda, v) = f_0(x) + \lambda^T(Ax-b) + v^T(cx-d)
$$&lt;/p&gt;
&lt;p&gt;对$x$求极小&lt;/p&gt;
&lt;p&gt;$$
g(\lambda, v) = \inf_{x\in dom f} L(x, \lambda, v) = \inf_{x\in dom f} f_0(x) + \lambda^T(Ax-b) + v^T(cx-d)
$$&lt;/p&gt;
&lt;p&gt;之后可以使用共轭函数（略）&lt;/p&gt;
&lt;h2 id=&#34;强对偶与弱对偶&#34;&gt;强对偶与弱对偶&lt;/h2&gt;
&lt;p&gt;之前说，对偶问题的最优解$d^\star $必然小于等于原问题的最优解$p^\star $&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;弱对偶&lt;/strong&gt;：满足$p^\star  \geq d^\star $，原问题不管是否为凸，该式总成立
&lt;strong&gt;强对偶&lt;/strong&gt;：满足$p^\star  = d^\star $，需要满足一些条件才能达到强对偶&lt;/p&gt;
&lt;p&gt;在凸优化问题中，能够保证强对偶成立的条件被称为constraint qualiﬁcations&lt;/p&gt;
&lt;p&gt;其中一种就是Slater条件&lt;/p&gt;
&lt;h2 id=&#34;slater条件&#34;&gt;Slater条件&lt;/h2&gt;
&lt;p&gt;有时简称为SCQ，该条件表述为：&lt;/p&gt;
&lt;p&gt;对于凸优化问题：
$$
\begin{array}{ll}
\text{ minimize } &amp;amp; f_0(x) \newline
\text { subject to } &amp;amp; f_{i}(x) \leq 0, \quad i=1, \ldots, m \newline
&amp;amp; Ax = b
\end{array}
$$&lt;/p&gt;
&lt;p&gt;如何存在可行解$x \in int \mathcal{D}$，使得：
$$
Ax = b, f_i(x) &amp;lt; 0, i = 1, ...m
$$
那么就能保证强对偶性&lt;/p&gt;
&lt;h2 id=&#34;kkt条件&#34;&gt;KKT条件&lt;/h2&gt;
&lt;p&gt;KKT条件给出了最优解需要满足的必要条件，是求解优化问题最优解的一个重要方式。&lt;/p&gt;
&lt;p&gt;对偶问题是：
$$
d^\star  = \sup_{\lambda, v} \inf_{x} L(x,\lambda, v)
$$&lt;/p&gt;
&lt;p&gt;原问题是：
$$
p^\star  = \inf_x \sup_{\lambda, v} L(x, \lambda, v)
$$&lt;/p&gt;
&lt;p&gt;弱对偶性实际上就是max-min不等式：
$$
\sup_{\lambda, v} \inf_{x} L(x,\lambda, v) \leq \inf_x \sup_{\lambda, v} L(x, \lambda, v)
$$&lt;/p&gt;
&lt;p&gt;强对偶性就是：
$$
\sup_{\lambda, v} \inf_{x} L(x,\lambda, v) = \inf_x \sup_{\lambda, v} L(x, \lambda, v) = L(x^\star , \lambda^\star , v^\star )
$$&lt;/p&gt;
&lt;p&gt;$x^\star , \lambda^\star , v^\star $也就是拉格朗日函数的鞍点，强对偶性下，$f_0(x^\star ) = g(\lambda^\star , v^\star )$&lt;/p&gt;
&lt;p&gt;有：&lt;/p&gt;
&lt;p&gt;$$
f_0(x^\star ) = g(\lambda^\star , v^\star ) = \inf_x (f_0(x) + \lambda^{\star T}f(x) + v^{\star T}h(x)) \leq f_0(x) + \lambda^{\star T}f(x) + v^{\star T}h(x) \leq f_0(x^\star )
$$&lt;/p&gt;
&lt;p&gt;也就是要让这两个$\leq$都变成$=$&lt;/p&gt;
&lt;p&gt;第一个不等号取等号的条件是：
$$
\nabla_{x}\left(f_0(x)+\lambda^{\star T} f(x)+\nu^{\star T} h(x)\right)=0
$$&lt;/p&gt;
&lt;p&gt;第二个不等式取等号的条件是：
$$
\lambda_i^{\star T} f_i(x) = 0, \forall i
$$&lt;/p&gt;
&lt;p&gt;上面一个条件共同构成了KKT条件：&lt;/p&gt;
&lt;h3 id=&#34;1-原始约束&#34;&gt;1. 原始约束&lt;/h3&gt;
&lt;p&gt;$f_i(x) \leq 0, i = 0, ..., m$
$h_i(x) = 0, i = 1, ..., p$&lt;/p&gt;
&lt;h3 id=&#34;2-对偶约束&#34;&gt;2. 对偶约束&lt;/h3&gt;
&lt;p&gt;$\lambda \geq 0$&lt;/p&gt;
&lt;h3 id=&#34;3-互补松弛性&#34;&gt;3. 互补松弛性&lt;/h3&gt;
&lt;p&gt;$\lambda_i f_i(x) = 0, i, ..., m$&lt;/p&gt;
&lt;h3 id=&#34;4-极值条件稳定性条件&#34;&gt;4. 极值条件（稳定性条件）&lt;/h3&gt;
&lt;p&gt;$\nabla_{x}\left(f_0(x)+\lambda_i f_i(x)+\nu_i h_i(x)\right)=0$&lt;/p&gt;
&lt;p&gt;对于一般情况而言，KKT条件只是必要条件。
但对于凸优化问题而言，如果有强对偶性，即满足Slater条件，则KKT条件是最优化性的&lt;strong&gt;充要条件&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;例题&#34;&gt;例题&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;注水问题，将值为1的总功率分配给不同的信道，使得总的通信功率最大，即考虑如下优化问题：
$$
\begin{array}{ll}
\text { minimize } &amp;amp; -\sum_{i=1}^{n} \log (x_{i}+\alpha_{i}) \newline
\text { subject to } &amp;amp; x \succcurlyeq 0 \newline
&amp;amp; 1^{T} x=1
\end{array}
$$&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;拉格朗日函数为：
$$
L(x, \lambda, v) = -\sum_{i=1}^{n} \log s(x_{i}+\alpha_{i}) - \lambda^T x + v^T(1^T x - 1)
$$
拉格朗日对偶函数为：
$$
g(\lambda, v) = \inf_{x\in D} L(x, \lambda, v) = \inf_{x\in D} (-\sum_{i=1}^{n} \log s(x_{i}+\alpha_{i}) - \lambda^T x + v^T(1^T x - 1))
$$
KKT条件为：
$$
x \succcurlyeq 0 \newline
1^{T} x=1 \newline
\lambda \succcurlyeq 0 \newline
\lambda_i^T x_i = 0, i = 1, ... ,n \newline
\frac{1}{x_i + \alpha_i} + \lambda_i = v, i = 1, ... ,n \newline
$$
如果$v \geq \frac{1}{\alpha_i}$，那么只有可能$x_i = 0$
如果$v &amp;lt; \frac{1}{\alpha_i}$，那么$\lambda_i = 0$，$x = \frac{1}{v} - \alpha_i$
最后有：
$$
x^{\star}=\left\{\begin{array}{l}
1 / v^{\star}-\alpha_{i} \quad v^{\star}&amp;lt;1 / \alpha_{i} \newline
0 \quad v^{\star} \geq 1 / \alpha_{i}
\end{array}\right.
$$&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;考虑问题：
$$
\begin{array}{ll}
\underset{\boldsymbol{x} \in \mathbb{R}^{n}}{\operatorname{minimize}} &amp;amp; f(\boldsymbol{x})=\boldsymbol{c}^{T} \boldsymbol{x} \newline
\text { subject to } &amp;amp; \boldsymbol{A} \boldsymbol{x} \geq \boldsymbol{b} \newline
&amp;amp; \boldsymbol{x} \geq \mathbf0
\end{array}
$$
分别基于集合约束$x \in X=\left\{\boldsymbol{x} \in \mathbb{R}^{n} \mid \boldsymbol{x} \geq \mathbf0\right\}$和$x \in X=\mathbb{R}^{n}$写出该问题的对偶问题。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;首先看第一个集合约束，此时第二个约束因为已经在集合约束里了，不需要单独考虑了，拉格朗日函数为：
$$
L(x, \lambda) = c^T x + \lambda(b - Ax) = (c^T - \lambda^T A)x + \lambda^T b
$$
对偶函数$$
g(\lambda) = \inf_x L(x, \lambda)
$$&lt;/p&gt;
&lt;p&gt;因为$x \geq 0$，如果$c^T - \lambda^T A &amp;lt; 0$的话，只要取$x = + \infty$，就会使得对偶函数为$- \infty$，因此对偶问题要增加约束$c^T - \lambda^T A \geq 0$，在此约束下，需要取$x=0$使得$g(\lambda)$最小，值为$\lambda^T b$&lt;/p&gt;
&lt;p&gt;对偶问题为：
$$\begin{array}{ll}\underset{\boldsymbol{\lambda} \in \mathbb{R}^m}{\operatorname{maximize}} &amp;amp; \boldsymbol{b}^{T} \boldsymbol{\lambda} \newline \text { subject to } &amp;amp; \boldsymbol{\lambda}^{T} \boldsymbol{A} \leq \boldsymbol{c}^{T} \newline &amp;amp; \boldsymbol{\lambda} \geq \mathbf0\end{array}$$&lt;/p&gt;
&lt;p&gt;第二个集合约束，没有对$x$的限制，拉格朗日函数为：
$$
c^T x + \lambda_1(b-Ax) - \lambda_2 x = (c^T - \lambda_1^T A -\lambda_2)x +\lambda_1^T b
$$
对偶函数$$
g(\lambda_1, \lambda_2) = \inf_x L(x, \lambda_1, \lambda_2)
$$&lt;/p&gt;
&lt;p&gt;如果$c \neq 0$，那么$g(\lambda_1, \lambda_2)$就是$- \infty$，所以对偶问题为：
$$\begin{array}{ll}\underset{\boldsymbol{\lambda_1, \lambda_2} \in \mathbb{R}^m}{\operatorname{maximize}} &amp;amp; \boldsymbol{b}^{T} \boldsymbol{\lambda_1} \newline \text { subject to } &amp;amp; \boldsymbol{c^T} - \boldsymbol{\lambda_1^T A} -\boldsymbol{\lambda_2} = 0\newline &amp;amp; \boldsymbol{\lambda_1, \lambda_2} \geq \mathbf0\end{array}$$&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;一般线性规划的对偶，求解线性规划
$$
\begin{array}{ll}
\operatorname{minimize} &amp;amp; c^{T} x \newline
\text { subject to } &amp;amp; G x \preceq h \newline
&amp;amp; A x=b
\end{array}
$$
的对偶函数，并将隐式等式约束显式表达&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;拉格朗日函数：
$$
L(x, \lambda, v) = c^T x + \lambda^T(Gx - h) + v^T(Ax - b)
$$&lt;/p&gt;
&lt;p&gt;对偶函数：&lt;/p&gt;
&lt;p&gt;$$
g(\lambda, v) = \inf_{x \in D} L(x, \lambda, v) = \inf_{x \in D} (c^T x + \lambda^T(Gx - h) + v^T(Ax - b)) $$&lt;/p&gt;
&lt;p&gt;$$= \left \{ \begin{array}{ll} -\lambda^T h - v^T b &amp;amp; \text{if}\ c+G^T \lambda + A^T v = 0\newline -\infty &amp;amp; \text{otherwise}  \end{array} \right .
$$&lt;/p&gt;
&lt;p&gt;对偶问题变为：&lt;/p&gt;
&lt;p&gt;$$
\begin{array}{ll}
\text { maximize } &amp;amp; g(\lambda, \nu) \newline
\text { subject to } &amp;amp; \lambda \geq 0
\end{array}
$$&lt;/p&gt;
&lt;p&gt;由于不能取负无穷的其他情况，所以增加的约束为：&lt;/p&gt;
&lt;p&gt;$$
\begin{array}{ll}
\text { maximize} &amp;amp; -\lambda^{T} h-\nu^{T} b \newline
\text { subject to } &amp;amp; c+G^{T} \lambda+A^{T} \nu=0 \newline
&amp;amp; \lambda \geq 0
\end{array}
$$&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;解析中心，考虑优化问题：
$$
\text {minimize} -\sum_{i=1}^m \log(b_i - a_i^T x)
$$
其定义域为${ x | a_i^T x &amp;lt; b_i, i = 1, ..., m }$，推导其对偶问题&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;代入$y_i = b_i - a_i^T x$ 得：&lt;/p&gt;
&lt;p&gt;$$
\begin{array}{ll}
\text { maximize} &amp;amp; -\sum_{i=1}^m \log y_i \newline
\text { subject to } &amp;amp; y_i = b_i - a_i^T x , i = 1, ... m\newline
\end{array}
$$&lt;/p&gt;
&lt;p&gt;拉格朗日函数为：&lt;/p&gt;
&lt;p&gt;$$
L(x, y, v) = -\sum_{i=1}^m \log y_i + \sum_{i=1}^n v^T(y_i - b_i + a_i x)
$$&lt;/p&gt;
&lt;p&gt;对偶函数为：
$$
g(v) = \inf_{x, y}(-\sum_{i=1}^m \log y_i + \sum_{i=1}^n v^T(y_i - b_i + a_i x))
$$&lt;/p&gt;
&lt;p&gt;如果$\sum_{i=1}^m v^T a_i \neq 0$，那么$x$可以让$g(v)$取$-\infty$，如果$v \leq 0$，那么$y$可以让$g(v)$取$-\infty$，取最大时$y_i = \frac{1}{v_i}$&lt;/p&gt;
&lt;p&gt;有：&lt;/p&gt;
&lt;p&gt;$$
g(v) = \left \{ \begin{array}{ll} \sum_{i=1}^m (\log v_i) -v^T b + m &amp;amp; \sum_{i=1}^m v^T a_i = 0, v &amp;gt; 0\newline -\infty &amp;amp; \text{otherwise}  \end{array} \right .
$$&lt;/p&gt;
&lt;p&gt;对偶问题为：
$$
\begin{array}{ll}
\text { maximize} &amp;amp; \sum_{i=1}^m (\log v_i) -v^T b + m \newline
\text { subject to } &amp;amp; \sum_{i=1}^m v_i^T a_i = 0 , i = 1, ... m\newline
&amp;amp; v &amp;gt; 0, i = 1, ... m\newline
\end{array}
$$&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;写出下面优化问题的KKT条件，并求出最优解
$$
\begin{array}{ll}
\text { minimize } &amp;amp; -3 x_{1}^2+x_2^2+2 x_{3}^2+2\left(x_{1}+x_2+x_{3}\right) \newline
\text { subject to } &amp;amp; x_{1}^2+x_2^2+x_{3}^2=1
\end{array}
$$&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;KKT条件：&lt;/p&gt;
&lt;p&gt;1、原始约束：$x_{1}^2+x_2^2+x_{3}^2=1$&lt;/p&gt;
&lt;p&gt;2、对偶约束：无&lt;/p&gt;
&lt;p&gt;3、互补松弛性约束：无&lt;/p&gt;
&lt;p&gt;4、稳定性条件：$(-3+v)x_1 + 1 = 0, (1+v)x_2 + 1 = 0, (2+v)x_3 + 1 = 0$&lt;/p&gt;
&lt;p&gt;通过稳定性条件将$x_1, x_2, x_3$全部替换成$v$然后代入原始约束，解出四个解：
$v = -3.15, v = 0.22, v = 1.89, v = 4.04$&lt;/p&gt;
&lt;p&gt;代入，最大的是$(v, x_1, x_2, x_3) = (-3.15, 0.16, 0.47, -0.87)$，$f_0^\star(x^\star) = 1.17$&lt;/p&gt;
</content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://yichengme.site/categories/%E6%8A%80%E6%9C%AF/" term="技术" label="技术" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://yichengme.site/tags/%E5%87%B8%E4%BC%98%E5%8C%96/" term="凸优化" label="凸优化" />
                            
                        
                            
                            
                            
                                <category scheme="https://yichengme.site/tags/%E6%95%B0%E5%AD%A6/" term="数学" label="数学" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">凸优化（三）凸优化问题</title>
            <link rel="alternate" type="text/html" href="https://yichengme.site/posts/convex-3/" />
            <id>https://yichengme.site/posts/convex-3/</id>
            <updated>2022-02-27T15:21:55&#43;08:00</updated>
            <published>2022-01-06T21:25:05&#43;08:00</published>
            <author>
                    <name>王毅诚</name>
                    <uri>https://yichengme.site/</uri>
                    <email>engine74396@gmail.com</email>
                    </author>
            <rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">基本形式 一般的优化问题的形式： $$ \begin{array}{ll} \text { minimize } &amp;amp; f_0(x) \newline \text { subject to } &amp;amp; f_{i}(x) \leq 0, \quad i=1, \ldots, m \newline &amp;amp; h_{i}(x)=0, \quad i=1, \ldots, p \end{array} $$ 其中$x$是优化变量，$f_0(x)$是目标函数 ，$f_i(x)\l……</summary>
            
                <content type="html">&lt;h2 id=&#34;基本形式&#34;&gt;基本形式&lt;/h2&gt;
&lt;p&gt;一般的优化问题的形式：
$$
\begin{array}{ll}
\text { minimize } &amp;amp; f_0(x) \newline
\text { subject to } &amp;amp; f_{i}(x) \leq 0, \quad i=1, \ldots, m \newline
&amp;amp; h_{i}(x)=0, \quad i=1, \ldots, p
\end{array}
$$&lt;/p&gt;
&lt;p&gt;其中$x$是优化变量，$f_0(x)$是目标函数 ，$f_i(x)\leq 0$是不等式约束，$h_i(x) = 0$是等式约束。如果$m=p=0$，就是无约束问题。&lt;/p&gt;
&lt;p&gt;定义域为
$$
\mathcal{D}=\bigcap_{i=0}^{m} \operatorname{dom} f_{i} \cap \bigcap_{i=1}^{p} \operatorname{dom} h_{i}
$$&lt;/p&gt;
&lt;p&gt;如果满足目标函数是凸函数，不等式约束也是凸函数，等式约束函数是仿射函数。就是凸优化问题。
$$
\begin{array}{ll}
\text{ minimize } &amp;amp; f_0(x) \newline
\text { subject to } &amp;amp; f_{i}(x) \leq 0, \quad i=1, \ldots, m \newline
&amp;amp; a_{i}^{T} x=b_{i}, \quad i=1, \ldots, p
\end{array}
$$&lt;/p&gt;
&lt;p&gt;定义域为：
$$
\mathcal{D}=\bigcap_{i=0}^{m} \operatorname{dom} f_{i}
$$&lt;/p&gt;
&lt;p&gt;可行解集（feasible set），即在目标函数的定义域中的满足所有约束的解集：
$$
X_f = \{x | x满足所有约束\}
$$&lt;/p&gt;
&lt;p&gt;问题的最优值（optimal value），如果可行解集不是空集，总能在可行解集中找到一个值，使目标函数最小，这个解就是最优解：
$$p^\star  = inf\{f_0(x)|x \in X_f\}$$&lt;/p&gt;
&lt;p&gt;这里inf是下确界的意思，和min类似但是不完全相同。有可能有下确界但是无限趋近取不到，也就是有inf没有min。&lt;/p&gt;
&lt;p&gt;凸优化问题的最重要性质（为什么要研究凸优化，为什么要转换为凸优化问题）：&lt;strong&gt;局部最优 = 全局最优&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;证明凸优化问题的局部最优=全局最优：
$$\newline$$
一句话说明就是反证法假设在局部最优之外还能找到一个全局最优，根据凸函数的性质，就可以在局部最优的领域内找到更低的点，从而与局部最优矛盾，具体过程如下：
$$\newline$$
反证法：假设局部最优解x不是全局最优解y。
$$\newline$$
因为局部最优，所以一定能找到一个正数$R$，使得在$R$的范围内，$f_0(x)$是最小的，即：
$$ \exists R &amp;gt; 0 , f_0(x) = inf { f_0(z), ||x-z||_2\leq R }$$
假设全局最优解是$y$
$$y \neq x, f_0(y) &amp;lt; f_0(x), ||y-x||_2 &amp;gt; R$$
由于是凸函数，在$x、y$中间的一点$ z= (1-\theta) x + \theta y$，有:
$$f_0(z) \leq (1-\theta)f_0(x) + \theta f_0(y)$$
令$\theta = \frac{R}{2||y-x||_2}$
因为可行域是凸集，z一定是可行解。
计算得$||z-x||_2 = \frac{R}2$（实际上前面取$\theta$等于那个的目的就是为了让这里 z在x的邻域内）
因为在邻域内x一定最优，所以$f_0(z) &amp;gt; f_0(x)$。最优点y的$f_0(y) &amp;lt; f_0(x)$
结合前面的式子，有$f_0(z) \leq (1-\theta)f_0(x) + \theta f_0(y) &amp;lt; f_0(z) $，矛盾了，找不到z，也就是说局部最优就是全局最优。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;可微的目标函数的最优解x，当且仅当：
$$\triangledown f_0(x)^T (y-x) \geq 0\ \ \ \text{for all feasible}\ y$$&lt;/p&gt;
&lt;p&gt;用凸函数的一阶等价定义$f(y) \geq f(x) + \triangledown f^T(x) (y-x)$即可直接证明&lt;/p&gt;
&lt;h2 id=&#34;等价问题&#34;&gt;等价问题&lt;/h2&gt;
&lt;h3 id=&#34;box-constraint&#34;&gt;Box constraint&lt;/h3&gt;
&lt;p&gt;例：
$$
\begin{array}{ll}
\text { minimize } &amp;amp; f_0(x) \newline
\text { subject to } &amp;amp; l_i \leq x \leq u_i, i = 1, ... ,n
\end{array}
$$&lt;/p&gt;
&lt;p&gt;改写为标准形式为&lt;/p&gt;
&lt;p&gt;$$
\begin{array}{ll}
\text { minimize } &amp;amp; f_0(x) \newline
\text { subject to } &amp;amp; l_i - x \leq 0, i = 1, ... ,n \newline
&amp;amp; x - u_i \leq 0, i = 1, ... ,n
\end{array}
$$&lt;/p&gt;
&lt;h3 id=&#34;函数等价变换&#34;&gt;函数等价变换&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;$\psi_0$&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;$R \to R$&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;单增&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;$\psi_1, \dots \psi_m$&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;$R \to R$&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;$\psi_{i}(u) \leq 0 \Leftrightarrow u \leq 0$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;$ϱ_1,\dots ϱ_p$&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;$R \to R$&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;$ϱ_{i}(u) = 0 \Leftrightarrow u = 0$&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;变为：
$$
\begin{array}{lll}
\min &amp;amp; \psi_0\left(f_0(x)\right) &amp;amp; \newline
\text { s.t. } &amp;amp; \psi_{i}\left(f_{i}(x)\right) \leq 0 &amp;amp; i=1, \ldots, m \newline
&amp;amp; \varrho_{i}\left(h_{i}(x)\right)=0 &amp;amp; i=1, \ldots, p
\end{array}
$$&lt;/p&gt;
&lt;p&gt;比如
$$
\min |A x-b|_2 \Leftrightarrow|A x-b|_2^2
$$&lt;/p&gt;
&lt;h3 id=&#34;消除或引入等式约束&#34;&gt;消除或引入等式约束&lt;/h3&gt;
&lt;p&gt;比如
$$
\begin{array}{ll}
\text { minimize } &amp;amp; f_0(x) \newline
\text { subject to } &amp;amp; f_i (x) \leq 0, i = 1, ... ,m \newline
&amp;amp; Ax = b
\end{array}
$$&lt;/p&gt;
&lt;p&gt;可以等价于：
$$
\begin{array}{ll}
\text { minimize } &amp;amp; f_0(Fz + x_0) \newline
\text { subject to } &amp;amp; f_i (Fz + x_0) \leq 0, i = 1, ... ,m
\end{array}
$$&lt;/p&gt;
&lt;p&gt;从而消除一个等式约束，也可以从下往上，增加一个等式约束&lt;/p&gt;
&lt;h3 id=&#34;松弛变量&#34;&gt;松弛变量&lt;/h3&gt;
&lt;p&gt;将不等号通过松弛变量变为等号
比如
$$
\begin{array}{ll}
\text { minimize } &amp;amp; f_0(x) \newline
\text { subject to } &amp;amp; a^T_i (x) \leq b, i = 1, ... ,m \newline
\end{array}
$$&lt;/p&gt;
&lt;p&gt;可以等价于：
$$
\begin{array}{ll}
\text { minimize } &amp;amp; f_0(Fz + x_0) \newline
\text { subject to } &amp;amp; a^T_i (x) + s_i = b, i = 1, ... ,m \newline
&amp;amp; s_i \geq 0, i = 1, ... ,m
\end{array}
$$&lt;/p&gt;
&lt;h2 id=&#34;如何把实际问题转换为标准凸优化问题形式&#34;&gt;如何把实际问题转换为标准凸优化问题形式&lt;/h2&gt;
&lt;p&gt;极大化一个凹目标函数，实际上就是凸优化问题&lt;/p&gt;
&lt;h2 id=&#34;典型的凸优化问题&#34;&gt;典型的凸优化问题&lt;/h2&gt;
&lt;h3 id=&#34;线性规划&#34;&gt;线性规划&lt;/h3&gt;
&lt;p&gt;目标函数、等式约束、不等式约束均为线性&lt;/p&gt;
&lt;p&gt;$$
\begin{array}{ll}
\text{ minimize } &amp;amp; c^{T} x+d \newline
\text { subject to } &amp;amp; G x \preceq h \newline
&amp;amp; A x=b
\end{array}
$$&lt;/p&gt;
&lt;p&gt;至少有一个最优解在顶点上&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1641474386/convex-10.png&#34; alt=&#34;convex-10&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;二次规划&#34;&gt;二次规划&lt;/h3&gt;
&lt;p&gt;目标是二次凸函数，约束函数均为线性&lt;/p&gt;
&lt;p&gt;$$
\begin{array}{ll}
\text{ minimize } &amp;amp; (1 / 2) x^{T} P x+q^{T} x+r \newline
\text { subject to } &amp;amp; G x \preceq h \newline
&amp;amp; A x=b
\end{array}
$$&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1641474386/convex-11.png&#34; alt=&#34;convex-11&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;例题&#34;&gt;例题&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;考虑优化问题：
$$
\begin{array}{ll}
\text { minimize} &amp;amp; f_0\left(x_{1}, x_2\right) \newline
\text { subject to } &amp;amp; 2 x_{1}+x_2 \geqslant 1 \newline
&amp;amp; x_{1}+3 x_2 \geqslant 1 \newline
&amp;amp; x_{1} \geqslant 0, \quad x_2 \geqslant 0
\end{array}
$$
对下面每个目标函数给出最优解和最优值&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;（a）
最优解$x^* = (\frac2{5}, \frac{1}{5})$
最优值$f(x^*) = \frac{3}{5}$&lt;/p&gt;
&lt;p&gt;（b）
目标函数没有下界&lt;/p&gt;
&lt;p&gt;（c）
最优解为$x^* = (0, x_2), x_2 \geq 1$
最优值$f(x^*) = 0$&lt;/p&gt;
&lt;p&gt;（d）
最优解$x^* = (\frac{1}{3}, \frac{1}{3})$
最优值$f(x^*) = \frac{1}{3}$&lt;/p&gt;
&lt;p&gt;（e）
最优解$x^* = (\frac{1}2, \frac{1}{6})$
最优值$f(x^*) = \frac{1}2$&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;考虑线性规划
$$
\begin{array}{ll}
\text { minimize } &amp;amp; c^{T} A^{-1} y \newline
\text { subject to } &amp;amp; y \preceq b
\end{array}
$$
A是方阵且不奇异，说明其最优值由：
$$
p^{\star}= \begin{cases}c^{T} A^{-1} b &amp;amp; A^{-T} c \preceq 0 \newline -\infty &amp;amp; \text { 其他情况 }\end{cases}
$$
给出&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;令$Ax = y$，则有$x = A^{-1}y$&lt;/p&gt;
&lt;p&gt;$$
\begin{array}{ll}
\text { minimize } &amp;amp; c^{T} A^{-1} y \newline
\text { subject to } &amp;amp; y \preceq b
\end{array}
$$&lt;/p&gt;
&lt;p&gt;如果$A^{-T} c \preceq 0$，最优解即为$y=b$，否则y取$- \infty$，函数无下界。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;网络流问题，网络总费用为$C = \sum_{1,j=1}^n c_{ij}x_{ij}$，每个边流量$x_{ij}$同时收到下界$l_{ij}$和上界$u_{ij}$的约束，流出和流入的流量守恒。建模成一个线性规划问题&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;目标函数为：
$$
\text{minimize}\ C = \sum_{1,j=1}^n c_{ij}x_{ij}
$$
约束有：
$$
\left \{  \begin{array}{ll}
l_{ij} \leq x_{ij} \leq u_{ij} \newline
b_i + \sum_{j=1}^n x_{ij} - \sum_{j=1}^n x_{ji} = 0
\end{array} \right .
$$&lt;/p&gt;
&lt;p&gt;线性规划即为：
$$
\begin{array}{ll}
\text { minimize } &amp;amp; C = \sum_{1,j=1}^n c_{ij}x_{ij} \newline
\text { subject to } &amp;amp; l_{ij} \leq x_{ij} \leq u_{ij} \newline
&amp;amp; b_i + \sum_{j=1}^n x_{ij} - \sum_{j=1}^n x_{ji} = 0， i = 1, ... n
\end{array}
$$&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Gauss广播信道的最优功率与带宽配置，建模为凸优化问题&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;目标函数为：
$$
\sum_{i=1}^{n} u_{i}\left(R_{i}\right) = \sum_{i=1}^{n} u_{i}(\alpha_{i} W_{i} \log \left(1+\beta_{i} P_{i} / W_{i}\right))
$$&lt;/p&gt;
&lt;p&gt;约束有：
$$
\left \{ \begin{array}{ll}
\sum P_{i=1}^n = P_{tol}\newline
\sum W_{i=1}^n = W_{tol}\newline
\end{array} \right .
$$&lt;/p&gt;
&lt;p&gt;R的Hassain矩阵为$$
\nabla^2 R_{i}=\frac{-\alpha_{i} \beta_{i}^2}{W_{i}\left(1+\beta_{i} P_{i} / W_{i}\right)^2}\left[\begin{array}{c}
1 \newline
-P_{i}
\end{array}\right]\left[\begin{array}{c}
1 \newline
-P_{i}
\end{array}\right]^{T}$$
是负定的，说明$R_i$是凹的。总效用是凹函数的和，也是凹函数。&lt;/p&gt;
</content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://yichengme.site/categories/%E6%8A%80%E6%9C%AF/" term="技术" label="技术" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://yichengme.site/tags/%E5%87%B8%E4%BC%98%E5%8C%96/" term="凸优化" label="凸优化" />
                            
                        
                            
                            
                            
                                <category scheme="https://yichengme.site/tags/%E6%95%B0%E5%AD%A6/" term="数学" label="数学" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">凸优化（二）凸函数</title>
            <link rel="alternate" type="text/html" href="https://yichengme.site/posts/convex-2/" />
            <id>https://yichengme.site/posts/convex-2/</id>
            <updated>2022-02-27T15:21:55&#43;08:00</updated>
            <published>2022-01-03T20:22:23&#43;08:00</published>
            <author>
                    <name>王毅诚</name>
                    <uri>https://yichengme.site/</uri>
                    <email>engine74396@gmail.com</email>
                    </author>
            <rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">凸函数的定义 定义一（基本定义） 函数$f: R^n \to R$是凸函数，当且仅当： $f$的定义域是凸集 $\forall x_1, x_2 \in dom(f), \forall \theta \in [0,1]$ $f(\theta x_1+(1-\theta)x_2) \leq \theta f(x_1) + (1-\theta)f(x_2)$ 该式也叫Jenson不等式： $$f(\theta x + (1-\theta) y) \leq……</summary>
            
                <content type="html">&lt;h2 id=&#34;凸函数的定义&#34;&gt;凸函数的定义&lt;/h2&gt;
&lt;h3 id=&#34;定义一基本定义&#34;&gt;定义一（基本定义）&lt;/h3&gt;
&lt;p&gt;函数$f: R^n \to R$是凸函数，当且仅当：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;$f$的定义域是凸集&lt;/li&gt;
&lt;li&gt;$\forall x_1, x_2 \in dom(f), \forall \theta \in [0,1]$
$f(\theta x_1+(1-\theta)x_2) \leq \theta f(x_1) + (1-\theta)f(x_2)$&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;该式也叫Jenson不等式：
$$f(\theta x + (1-\theta) y) \leq \theta f(x) + (1-\theta)f(y)$$&lt;/p&gt;
&lt;p&gt;拓展，对于任意随机变量z，有
$$f(Ez) \leq Ef(z)$$&lt;/p&gt;
&lt;p&gt;通俗来讲，就是函数上任取两点，它们之间的连线都在函数的上面&lt;/p&gt;
&lt;p&gt;如果2的$\leq$换成$&amp;lt;$就是严格凸函数&lt;/p&gt;
&lt;h3 id=&#34;定义二降至一维&#34;&gt;定义二（降至一维）&lt;/h3&gt;
&lt;p&gt;函数$f: R^n \to R$是凸函数，当且仅当：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;$f$的定义域是凸集&lt;/li&gt;
&lt;li&gt;$\forall x \in dom\ f, \forall v, g(t) = f(x+tv)$为凸函数，$dom\ g \in dom\ f$&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;相当于从高维降到一维，可以通过证明一维的函数$g(t)$来反证原函数$f(x)$，当然这个定义用的不多&lt;/p&gt;
&lt;h3 id=&#34;定义三凸函数的一阶条件&#34;&gt;定义三（凸函数的一阶条件）&lt;/h3&gt;
&lt;p&gt;若$f: R^n \to R$一阶可微，则它是凸函数，当且仅当：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;$f$的定义域是凸集&lt;/li&gt;
&lt;li&gt;$\forall x, y \in dom(f), f(y) \geq f(x) + \triangledown f(x)^T (y-x)$&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;通俗来讲，就是任何一点的切线，切线上的任何一点都小于等于函数&lt;/p&gt;
&lt;p&gt;证明定义三：&lt;/p&gt;
&lt;p&gt;充分性：首先因为是凸函数，定义域为凸集。代入$y \to x+$即可
必要性：构造$z = \theta x + (1-\theta)y$，然后代入f(x)和f(y)的一阶不等式到$\theta f(x) + (1-\theta) f(y)$中即可得到结果。&lt;/p&gt;
&lt;h3 id=&#34;定义四凸函数的二阶条件&#34;&gt;定义四（凸函数的二阶条件）&lt;/h3&gt;
&lt;p&gt;实际上用的最多，前提是二阶可微&lt;/p&gt;
&lt;p&gt;若$f: R^n \to R$二阶可微，则它是凸函数，当且仅当：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;$f$的定义域是凸集&lt;/li&gt;
&lt;li&gt;$\forall x \in dom(f), \triangledown f^2(x) \geq 0$，即$f$的Hessian矩阵半正定（特征值均$\geq 0$）&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;如何判断矩阵的正定或负定？
$$\newline$$
方法一、正定矩阵的顺序主子式均为正
$$\newline$$
例：
$$
\begin{array}{ccc}
\end{array}
\left |
\begin{array}{ccc}
6 &amp;amp; -3 &amp;amp; 1 \newline
-3 &amp;amp; 2 &amp;amp; 0 \newline
1 &amp;amp; 0 &amp;amp; 4 \newline
\end{array}
\right |
$$
三个顺序主子式依次为：
$$
\left |
\begin{array}{ccc}
6 \newline
\end{array}
\right | = 6 &amp;gt; 0
$$
$$
\left |
\begin{array}{ccc}
6 &amp;amp; -3 \newline
-3 &amp;amp; 2 \newline
\end{array}
\right | = 3 &amp;gt; 0
$$
$$
\left |
\begin{array}{ccc}
6 &amp;amp; -3 &amp;amp; 1 \newline
-3 &amp;amp; 2 &amp;amp; 0 \newline
1 &amp;amp; 0 &amp;amp; 4 \newline
\end{array}
\right | = 10 &amp;gt; 0
$$
所以为正定矩阵
$$\newline$$
方法二：$x^T H x \geq 0$
（一般用来求二阶的情况，高阶不好求。）
$$\newline$$
例：
$$
H =
\begin{array}{ccc}
\end{array}
\left [
\begin{array}{ccc}
3 &amp;amp; 2 \newline
2 &amp;amp; 1 \newline
\end{array}
\right ]
$$
对于任意$x$，构造
$$
x^T \begin{array}{ccc}
\end{array}
\left [
\begin{array}{ccc}
3 &amp;amp; 1 \newline
1 &amp;amp; 1 \newline
\end{array}
\right ] x = 3x_1^2 + 2x_1 x_2 + x_2^2 = 2x_1^2 + (x_1+x_2)^2 \geq 0
$$
所以是半正定的&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;注意，使用该方法时需要定义域是凸集，且二阶可微&lt;/strong&gt;，比如$f(x)=\frac{1}{x^2}$，即使二阶导数$\geq0$，因为在0不连续，定义域不是凸集，所以不是凸函数。&lt;/p&gt;
&lt;p&gt;第一个要判断的就是定义域是否为凸集。然后看定义域内是否可导，比如某分段函数的某点是尖不可导，当然不能说一定凸/非凸，只是说不能用这个定义判断，要用基本定义来求。&lt;/p&gt;
&lt;p&gt;如果取$&amp;gt;$，那么是严格凸的，但是并不是凸函数都能取$&amp;gt;$，比如$x^4$在0处的二阶导就是0&lt;/p&gt;
&lt;h3 id=&#34;凸函数拓展&#34;&gt;凸函数拓展&lt;/h3&gt;
&lt;p&gt;如果$f(x)$是凸函数，那么凸函数的拓展&lt;/p&gt;
&lt;p&gt;$$
\bar{f}(x)= \begin{cases}f(x) &amp;amp; x \in \operatorname{dom}(f) \newline \infty &amp;amp; x \notin \operatorname{dom}(f)\end{cases}
$$&lt;/p&gt;
&lt;p&gt;也是凸函数，比较直观&lt;/p&gt;
&lt;h2 id=&#34;常见的凸函数&#34;&gt;常见的凸函数&lt;/h2&gt;
&lt;h3 id=&#34;仿射函数&#34;&gt;仿射函数&lt;/h3&gt;
&lt;p&gt;$ f(x) = Ax + b$&lt;/p&gt;
&lt;p&gt;$\nabla^{2} f(x) = 0$
仿射函数既是凸函数，又是凹函数&lt;/p&gt;
&lt;h3 id=&#34;指数函数&#34;&gt;指数函数&lt;/h3&gt;
&lt;p&gt;$f(x) = e^{ax}$&lt;/p&gt;
&lt;p&gt;$\nabla^{2} f(x) = a^2 e^{ax} &amp;gt; 0$&lt;/p&gt;
&lt;h3 id=&#34;幂函数&#34;&gt;幂函数&lt;/h3&gt;
&lt;p&gt;$f(x) = x^a$&lt;/p&gt;
&lt;p&gt;分情况讨论&lt;/p&gt;
&lt;p&gt;$$\nabla^{2} f(x)=a(a-1) x^{a-2}=\left\{\begin{array}{ll}\geq 0 &amp;amp; a \geq 1, a \leq 0 &amp;amp; 凸\newline \leq 0 &amp;amp; a \in[0,1]&amp;amp; 凹\end{array}\right.$$&lt;/p&gt;
&lt;h3 id=&#34;绝对值幂函数&#34;&gt;绝对值幂函数&lt;/h3&gt;
&lt;p&gt;$f(x) = |x|^p$&lt;/p&gt;
&lt;p&gt;$$
f^{\prime \prime}(x)= \begin{cases}p(p-1) x^{p-2} &amp;amp; x \geq 0 \newline -p(p-1)(-x)^{p-2} &amp;amp; x&amp;lt;0\end{cases}
$$&lt;/p&gt;
&lt;p&gt;情况比较复杂，需要对$p$分类讨论。&lt;/p&gt;
&lt;h3 id=&#34;范数&#34;&gt;范数&lt;/h3&gt;
&lt;p&gt;$R^n$空间的范数$P(x)$&lt;/p&gt;
&lt;p&gt;有如下性质：
① $P(ax) = |a|P(x)$
② $P(x+y) \leq P(x) + P(y)$
③ $P(x) = 0 \Leftrightarrow x = 0$&lt;/p&gt;
&lt;p&gt;范数是凸函数，按照定义用性质②即可证明（零范数除外，零范数不满足①）&lt;/p&gt;
&lt;h3 id=&#34;极大值函数&#34;&gt;极大值函数&lt;/h3&gt;
&lt;p&gt;$f(x) = max\{x_1, x_2, ...x_n\}$&lt;/p&gt;
&lt;p&gt;极大值函数是凸函数，所以会有极小极大问题，即极小化一个极大值函数&lt;/p&gt;
&lt;h3 id=&#34;共轭函数&#34;&gt;共轭函数&lt;/h3&gt;
&lt;h2 id=&#34;保凸运算&#34;&gt;保凸运算&lt;/h2&gt;
&lt;h3 id=&#34;非负加权和&#34;&gt;非负加权和&lt;/h3&gt;
&lt;p&gt;$f_1, ..., f_m$为凸，$\omega_i \geq 0$，则$f = \sum_{i=1}^{m} \omega_i f_i$为凸&lt;/p&gt;
&lt;h3 id=&#34;仿射映射&#34;&gt;仿射映射&lt;/h3&gt;
&lt;p&gt;$f: R^n \to R$为凸，则$g(x) = f(Ax+b)$为凸&lt;/p&gt;
&lt;h3 id=&#34;凸函数的逐点最大&#34;&gt;凸函数的逐点最大&lt;/h3&gt;
&lt;p&gt;$f_1, f_2$为凸，则$f = \max{{f_1(x), f_2(x)}}$为凸&lt;/p&gt;
&lt;p&gt;可以用定义一证明，可以推广到无数个&lt;/p&gt;
&lt;p&gt;比如分段线性函数就是凸函数&lt;/p&gt;
&lt;h3 id=&#34;复合函数&#34;&gt;复合函数&lt;/h3&gt;
&lt;p&gt;$f(x) = h(g(x))$&lt;/p&gt;
&lt;p&gt;$
f^{\prime \prime}(x)=h^{\prime \prime}(g(x)) g^{\prime 2}(x)+h^{\prime}(g(x)) g^{\prime \prime}(x)
$&lt;/p&gt;
&lt;p&gt;然后分情况讨论&lt;/p&gt;
&lt;h2 id=&#34;拟凸函数与拟凹函数&#34;&gt;拟凸函数与拟凹函数&lt;/h2&gt;
&lt;p&gt;$\alpha$-下水平集：$$
C_{\alpha}={x \in \operatorname{dom} f \mid f(x) \leq \alpha}
$$&lt;/p&gt;
&lt;p&gt;指的是&lt;strong&gt;定义域&lt;/strong&gt;是凸集！&lt;/p&gt;
&lt;p&gt;如果作一条水平线，交点数&amp;gt;2，必然不是拟凸&lt;/p&gt;
&lt;p&gt;考虑函数的$\alpha-$下水平集，凸函数的所有$\alpha$-下水平集是凸集，但是$\alpha$-下水平集是凸集的函数不一定是凸函数&lt;/p&gt;
&lt;p&gt;拟凸有时候也称为单模态函数，如下图左图为拟凸函数，右图则不是拟凸函数
&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1640604308/convex-7.png&#34; alt=&#34;convex-7&#34;&gt;&lt;/p&gt;
&lt;p&gt;定义函数$f: R^n \to n$是拟凸函数，如果其定义域和所有$\alpha$-下水平集都是凸集：
$$S_\alpha = { x\in dom f | f(x) \leq \alpha }$$&lt;/p&gt;
&lt;p&gt;对于拟凸函数$f$，有：（Jensen不等式）
$$f(\theta x + (1-\theta)y) \leq max{ f(x), f(y)}, 0 \leq \theta \leq 1$$&lt;/p&gt;
&lt;p&gt;凸函数一定是拟凸函数，但是拟凸函数不一定是凸函数。&lt;/p&gt;
&lt;p&gt;拟凹函数同理，即为上水平集均为凸的函数。&lt;/p&gt;
&lt;h2 id=&#34;例题&#34;&gt;例题&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;假设$f :R \to R$是凸函数，$$a,b \in \textbf{dom} f, a &amp;lt; b$$
（a）证明对于任意$x\in [a,b]$，下式成立：
$$
f(x) \leq \frac{b-x}{b-a} f(a)+\frac{x-a}{b-a} f(b)
$$
（b）证明对于任意$x \in (a,b)$，下式成立（并画一个草图说明）：
$$
\frac{f(x)-f(a)}{x-a} \leq \frac{f(b)-f(a)}{b-a}\leq \frac{f(b)-f(x)}{b-x}
$$
（c）假设$f$可微，利用（b）的结论证明：
$$
f&#39;(a) \leq \frac{f(b)-f(a)}{b-a} \leq f&#39;(b)
$$
（d）假设$f$二次可微，利用（c）的结论证明$f&#39;&#39;(a)\geq 0$和$f&#39;&#39;(b)\geq 0$&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;（a）
由凸函数的定义可知，定义域上任意两点$x, y$，对任意$\theta \in [0,1]$有：
$f(\theta x + (1-\theta)y) \leq \theta f(x) + (1-\theta)f(y)$&lt;/p&gt;
&lt;p&gt;$a, b \in dom f, x\in[a,b]$
取$\theta = \frac{b-x}{b-a} \in dom f$
有$f(x) = f(\frac{b-x}{b-a}a + \frac{x-a}{b-a}b) \leq \frac{b-x}{b-a} f(a)+\frac{x-a}{b-a} f(b)$&lt;/p&gt;
&lt;p&gt;（b）
（a）中的式子左右两边都减去$f(a)$，即可得到$\frac{f(x)-f(a)}{x-a} \leq \frac{f(b)-f(a)}{b-a}$，左右两边都减去$f(b)$，即可得到$\frac{f(b)-f(a)}{b-a} \leq \frac{f(b)-f(x)}{b-x}$
草图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1641472076/convex-homework-1.png&#34; alt=&#34;convex-homwork-1&#34;&gt;&lt;/p&gt;
&lt;p&gt;不等式描述了斜率：$\overline{ax} \leq \overline{ab} \leq \overline{xb}$&lt;/p&gt;
&lt;p&gt;（c）
取$x \to a+$，代入（b）的前半部分即有$f&#39;(a) = \lim_{x\to a+} \frac{f(x)-f(a)}{x-a} \leq \frac{f(b)-f(a)}{b-a}$，同理，取$x \to b-$，代入（b）的后半部分即有$\frac{f(b)-f(a)}{b-a} \leq \lim_{x\to b-} = f&#39;(b)$&lt;/p&gt;
&lt;p&gt;（d）&lt;/p&gt;
&lt;p&gt;（c）的结果为：
$f&#39;(a) \leq \frac{f(b)-f(a)}{b-a} \leq f&#39;(b)$&lt;/p&gt;
&lt;p&gt;在此基础上令$b \to a+$
$f&#39;&#39;(a) = \lim_{b\to a+} \frac{f&#39;(b) - f&#39;(a)}{b-a} \geq 0 $&lt;/p&gt;
&lt;p&gt;同理可得$f&#39;&#39;(b) \geq 0$&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;证明连续函数$f: R^n \to R$是凸函数的充要条件是，对于任意线段，函数在线段上的平均值不大于线段端点函数值的平均，也就是对于任意$x, y \in R^n$，下式成立：
$$
\int_{0}^{1} f(x+\lambda(y-x)) d \lambda \leqslant \frac{f(x)+f(y)}{2}
$$&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;先证明必要性，如果连续函数$f$是凸函数，即任取两点$x,y$，任取$\theta \in [0,1]$，必然有：
$$\theta f(x) + (1-\theta) f(y) \geq f(\theta x + (1-\theta) y)$$&lt;/p&gt;
&lt;p&gt;即：&lt;/p&gt;
&lt;p&gt;$$\int_{0}^{1} f(x+\lambda(y-x)) d \lambda \leq \int_{0}^{1}(f(x)+\lambda(f(y)-f(x))) d \lambda=\frac{f(x)+f(y)}{2}$$&lt;/p&gt;
&lt;p&gt;然后是充分性，即满足后式，必然能保证是凸函数，使用凸函数的第一定义证明：
任取两点$x,y$，任取$\theta \in [0,1]$，需要证明$\theta f(x) + (1-\theta) f(y) \geq f(\theta x + (1-\theta y))$&lt;/p&gt;
&lt;p&gt;用反证法，也就是说函数不是凸函数，至少能找到一个$x, y \in dom f $和$\theta \in [0,1]$，使得
$$\theta f(x) + (1-\theta) f(y) &amp;lt; f(\theta x + (1-\theta) y)$$
也就是说存在$x^*, y^*, \theta^*$关于$\theta$的函数：
$$g(\theta) = f(\theta x + (1-\theta) y) - \theta f(x) - (1-\theta) f(y) &amp;gt;0$$&lt;/p&gt;
&lt;p&gt;由于$\theta = 0$和$1$时上式均为0。所以一定在 $\theta^*$的左右存在两点$p,q$，使得$g(p) = 0, g(q) = 0, g(i)_{p \leq i \leq q} &amp;gt; 0$&lt;/p&gt;
&lt;p&gt;取$x = p, y =q$，在原函数上有$\int_{0}^{1} f(p+\theta(p-q)) d \theta&amp;gt;\int_{0}^{1}(f(p)+\theta(f(p)-f(q))) d \theta=\frac{f(p)+f(q)}{2}$，与初始矛盾，所以反证法成立。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;判断下列函数是否为凸函数、凹函数、拟凸函数与拟凹函数：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;（a）$f(x) = e^x - 1, \textbf{dom}\ f = R$&lt;/p&gt;
&lt;p&gt;（b）$f(x_1,x_2) = x_1 x_2, \textbf{dom}\ f = R_{++}^2$&lt;/p&gt;
&lt;p&gt;（c）$f(x_1,x_2) = 1/(x_1 x_2), \textbf{dom}\ f = R_{++}^2$&lt;/p&gt;
&lt;p&gt;（d）$f(x_1,x_2) = x_1 / x_2, \textbf{dom}\ f = R_{++}^2$&lt;/p&gt;
&lt;p&gt;（e）$f(x_1,x_2) = x_1^2/ x_2, \textbf{dom}\ f = R \times R_{++}$&lt;/p&gt;
&lt;p&gt;（f）$f(x_1,x_2) = x_1^{\alpha} x_2^{1-\alpha}, 0 \leq \alpha \leq 1, \textbf{dom}\ f = R_{++}^2$&lt;/p&gt;
&lt;p&gt;（a）
由于原函数二阶可导
$f&#39;&#39;(x) = e^x &amp;gt; 0$
为凸函数，凸函数也一定是拟凸函数，同时还是拟凹函数&lt;/p&gt;
&lt;p&gt;（b）&lt;/p&gt;
&lt;p&gt;Hessain矩阵为：$$
\nabla^{2} f(x)=\left[\begin{array}{ll}
0 &amp;amp; 1 \newline
1 &amp;amp; 0
\end{array}\right]
$$
既非正定，又非负定，所以不是凸函数也不是凹函数。&lt;/p&gt;
&lt;p&gt;$\alpha$-上水平集为凸集，是拟凹函数，下水平集不是凸集，所以不是拟凸函数&lt;/p&gt;
&lt;p&gt;（c）
Hessain矩阵为：
$$
\nabla^{2} f(x)=\frac{1}{x_{1} x_{2}}\left[\begin{array}{cc}
2 /\left(x_{1}^{2}\right) &amp;amp; 1 /\left(x_{1} x_{2}\right) \newline
1 /\left(x_{1} x_{2}\right) &amp;amp; 2 / x_{2}^{2}
\end{array}\right] \geq 0
$$
是正定的，所以是凸函数，也是拟凸函数。不是凹函数，也不是拟凹函数。&lt;/p&gt;
&lt;p&gt;（d）
Hessain矩阵为：
$$
\nabla^{2} f(x)=\left[\begin{array}{cc}
0 &amp;amp; -1 / x_{2}^{2} \newline
-1 / x_{2}^{2} &amp;amp; 2 x_{1} / x_{2}^{3}
\end{array}\right]
$$
既非正定，又非负定，所以不是凸函数也不是凹函数。
上水平集和下水平集均为半空间，所以既是拟凸的又是拟凹的。&lt;/p&gt;
&lt;p&gt;（e）
$$
\nabla^{2} f(x)=\left[\begin{array}{cc}
2 / x_{2} &amp;amp; -2 x_{1} / x_{2}^{2} \newline
-2 x_{1} / x_{2}^{2} &amp;amp; 2 x_{1}^{2} / x_{2}^{3}
\end{array}\right] \geq 0
$$
是凸函数，也是拟凸函数，不是拟凹函数&lt;/p&gt;
&lt;p&gt;（f）
$$
\nabla^{2} f(x)=\left[\begin{array}{cc}
\alpha(\alpha-1) x_{1}^{\alpha-2} x_{2}^{1-\alpha} &amp;amp; \alpha(1-\alpha) x_{1}^{\alpha-1} x_{2}^{-\alpha} \newline
\alpha(1-\alpha) x_{1}^{\alpha-1} x_{2}^{-\alpha} &amp;amp; (1-\alpha)(-\alpha) x_{1}^{\alpha} x_{2}^{-\alpha-1}
\end{array}\right] \leq 0
$$&lt;/p&gt;
&lt;p&gt;是凹函数，也是拟凹函数。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;函数的积或比，证明以下结论：
$$\newline$$
（a）在某区间上的函数$f$和$g$都是凸函数，且都非减（或者都非增），二者都大于0，则函数$fg$在此区间上也是凸函数
$$\newline$$
（b）函数$f$和$g$都是凹函数，一个非减，一个非增，二者都大于0，则函数$fg$是凹函数
$$\newline$$
（c）函数$f$是凸函数，非减且大于0，$g$是凹函数，非增且大于0，那么函数$f/g$是凸函数&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;要证明$fg$的凹凸性，根据定义，则要证明：
$$\theta f(x)g(x) + (1-\theta) f(y)g(y) 和 f(\theta x + (1-\theta)y)g(\theta x + (1-\theta)y) 的关系$$&lt;/p&gt;
&lt;p&gt;要证明$f/g$的凹凸性，根据定义，则要证明：
$$\theta f(x)/g(x) + (1-\theta) f(y)/g(y) 和 f(\theta x + (1-\theta)y)/g(\theta x + (1-\theta)y) 的关系$$&lt;/p&gt;
&lt;p&gt;（a）&lt;/p&gt;
&lt;p&gt;都凸，所以对于$x, y \in dom$， $\theta \in [0,1]$
$$\begin{array}{ll} f(\theta x + (1-\theta)y)g(\theta x + (1-\theta)y) &amp;amp;\leq (\theta f(x)+(1-\theta) f(y))(\theta g(x)+(1-\theta) g(y)) \newline &amp;amp; = \theta^2 f(x) g(x) + (1-\theta)^2 f(y) g(y) + \theta(1-\theta)(f(y)-f(x))(g(x)-g(y)) \end{array}$$&lt;/p&gt;
&lt;p&gt;且非减且大于0，即$\theta(1-\theta)(f(y)-f(x))(g(x)-g(y)) \leq 0$，有：
$$
\theta(1-\theta)(f(y)-f(x))(g(x)-g(y)) \leq 0
$$
有
$$\theta f(x)g(x) + (1-\theta) f(y)g(y) \geq f(\theta x + (1-\theta)y)g(\theta x + (1-\theta)y)$$&lt;/p&gt;
&lt;p&gt;即$fg$为凸函数&lt;/p&gt;
&lt;p&gt;（b）&lt;/p&gt;
&lt;p&gt;都凹，所以对于$x, y \in dom$， $\theta \in [0,1]$
$$\begin{array}{ll} f(\theta x + (1-\theta)y)g(\theta x + (1-\theta)y) &amp;amp;\geq (\theta f(x)+(1-\theta) f(y))(\theta g(x)+(1-\theta) g(y)) \newline &amp;amp; = \theta^2 f(x) g(x) + (1-\theta)^2 f(y) g(y) + \theta(1-\theta)(f(y)-f(x))(g(x)-g(y)) \end{array}$$&lt;/p&gt;
&lt;p&gt;一个非减一个非增，有
$$
\theta(1-\theta)(f(y)-f(x))(g(x)-g(y)) \geq 0
$$
有
$$\theta f(x)g(x) + (1-\theta) f(y)g(y) \leq f(\theta x + (1-\theta)y)g(\theta x + (1-\theta)y)$$&lt;/p&gt;
&lt;p&gt;$fg$为凹函数&lt;/p&gt;
&lt;p&gt;（c）&lt;/p&gt;
&lt;p&gt;因为$f$为凸，非减且大于0，$g$为凹，非增且大于0，有
$$\begin{array}{ll} f(\theta x + (1-\theta)y)/g(\theta x + (1-\theta)y) &amp;amp;\leq (\theta f(x)+(1-\theta) f(y))/(\theta g(x)+(1-\theta) g(y)) \newline &amp;amp; \leq \theta f(x)/g(x) + (1-\theta) f(y)/g(y) \end{array}$$&lt;/p&gt;
&lt;p&gt;有
$$\theta f(x)/g(x) + (1-\theta) f(y)/g(y) \geq f(\theta x + (1-\theta)y)/g(\theta x + (1-\theta)y)$$&lt;/p&gt;
&lt;p&gt;$f/g$为凸函数&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;证明凸函数的二阶条件，也就是凸函数的充要条件是Hessian矩阵半正定&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;先证充分性，即凸函数可以推导出Hessain矩阵半正定：&lt;/p&gt;
&lt;p&gt;根据凸函数的一阶定义
$$
f(y) \geq f(x) + \nabla f(x)(y-x) \newline
f(x) \geq f(y) + \nabla f(y)(x-y)
$$&lt;/p&gt;
&lt;p&gt;有：&lt;/p&gt;
&lt;p&gt;$$\nabla f(x) (y-x) \leq f(y) - f(x) \leq \nabla f(y)(y-x)$$&lt;/p&gt;
&lt;p&gt;可得&lt;/p&gt;
&lt;p&gt;$$\frac{\nabla f(y) - \nabla f(x)}{y-x} \geq 0$$&lt;/p&gt;
&lt;p&gt;取$y \to x^+$，得：&lt;/p&gt;
&lt;p&gt;$$\nabla^2 f(x) \geq 0$$&lt;/p&gt;
&lt;p&gt;证明必要性，这里先考虑$n=1$的情况&lt;/p&gt;
&lt;p&gt;取$x &amp;lt; y$，根据分部积分法，有：&lt;/p&gt;
&lt;p&gt;$$
\begin{array}{ll}
0 &amp;amp; \leq \int_{x}^{y} f^{\prime \prime}(z)(y-z) dz \newline
&amp;amp;= \left.\left(f^{\prime}(z)(y-z)\right)\right|_{z=x} ^{z=y} + \int_x^y f^{\prime}(z) dz \newline
&amp;amp;=-f^{\prime}(x)(y-x)+f(y)-f(x),
\end{array}
$$&lt;/p&gt;
&lt;p&gt;注： 第一个等号是分部积分法，即
$$f(x)g(x) = \int( f&#39;(x)g(x) + f(x)g&#39;(x)) \newline
\int f&#39;(x)g(x) = f(x)g(x) - \int f(x)g&#39;(x)
$$&lt;/p&gt;
&lt;p&gt;有$$
f(y) \geq f(x) + f&#39;(x)(y-x)
$$
通过一阶条件可知是凸函数&lt;/p&gt;
&lt;p&gt;然后拓展到$n&amp;gt;1$的情况，根据凸函数的第二定义，如果$g(t) = f(x_0 + vt)$对于每个$x_0$和$v$而言都是凸函数的话，就可以得到$f(x)$是凸函数。&lt;/p&gt;
&lt;p&gt;$g(t)$是凸函数也就是说它的二阶导大于等于0：&lt;/p&gt;
&lt;p&gt;$$
g^{\prime \prime}(t)=v^{T} \nabla^{2} f\left(x_{0}+t v\right) v \geq 0
$$&lt;/p&gt;
&lt;p&gt;因为有$\nabla^{2} f \geq 0$，所以上式成立，也就是说$f$是凸函数&lt;/p&gt;
</content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://yichengme.site/categories/%E6%8A%80%E6%9C%AF/" term="技术" label="技术" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://yichengme.site/tags/%E5%87%B8%E4%BC%98%E5%8C%96/" term="凸优化" label="凸优化" />
                            
                        
                            
                            
                            
                                <category scheme="https://yichengme.site/tags/%E6%95%B0%E5%AD%A6/" term="数学" label="数学" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">凸优化（一）绪论与凸集</title>
            <link rel="alternate" type="text/html" href="https://yichengme.site/posts/convex-1/" />
            <id>https://yichengme.site/posts/convex-1/</id>
            <updated>2022-02-27T15:21:55&#43;08:00</updated>
            <published>2021-12-27T21:10:31&#43;08:00</published>
            <author>
                    <name>王毅诚</name>
                    <uri>https://yichengme.site/</uri>
                    <email>engine74396@gmail.com</email>
                    </author>
            <rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">凸优化的笔记专栏，预计会分为五个部分，分别是： 绪论与凸集 凸函数 凸优化问题 对偶 算法 参考： Stanford《convex optimization》 中科大 凌青 凸优化 优……</summary>
            
                <content type="html">&lt;p&gt;凸优化的笔记专栏，预计会分为五个部分，分别是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;绪论与凸集&lt;/li&gt;
&lt;li&gt;凸函数&lt;/li&gt;
&lt;li&gt;凸优化问题&lt;/li&gt;
&lt;li&gt;对偶&lt;/li&gt;
&lt;li&gt;算法&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;参考：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Stanford《convex optimization》&lt;/li&gt;
&lt;li&gt;中科大 凌青 凸优化&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;优化问题&#34;&gt;优化问题&lt;/h2&gt;
&lt;p&gt;优化问题：从一系列可行解集合中，寻找出最优的元素&lt;/p&gt;
&lt;p&gt;优化问题的形式：&lt;/p&gt;
&lt;p&gt;$$
\begin{array}{ll}
\text{ minimize } &amp;amp; f_0(x) \newline
\text { subject to } &amp;amp; f_{i}(x) \leq b_i
\end{array}
$$&lt;/p&gt;
&lt;p&gt;$f_0$是目标函数（$R^n \to R$）&lt;/p&gt;
&lt;p&gt;优化问题在现实生活中各个领域都非常常见，深度学习中也是要使Loss最小，也是优化问题。&lt;/p&gt;
&lt;h2 id=&#34;优化问题的分类&#34;&gt;优化问题的分类&lt;/h2&gt;
&lt;h3 id=&#34;线性优化非线性优化&#34;&gt;线性优化/非线性优化&lt;/h3&gt;
&lt;p&gt;（有时候也叫规划，和优化是一个意思）&lt;/p&gt;
&lt;p&gt;目标函数由多个线性函数组合成，就是线性优化问题，否则就是非线性优化问题。&lt;/p&gt;
&lt;p&gt;线性优化问题，最优解不是在顶点就是在整条边上&lt;/p&gt;
&lt;h3 id=&#34;凸优化非凸优化&#34;&gt;凸优化/非凸优化&lt;/h3&gt;
&lt;p&gt;凸优化：&lt;/p&gt;
&lt;p&gt;$$
\begin{array}{ll}
\text{ minimize } &amp;amp; f_0(x) \newline
\text { subject to } &amp;amp; f_{i}(x) \leq 0, \quad i=1, \ldots, m \newline
&amp;amp; a_{i}^{T} x=b_{i}, \quad i=1, \ldots, p
\end{array}
$$&lt;/p&gt;
&lt;p&gt;优化问题里面，比较好求解的是凸优化问题，非凸优化问题难解决&lt;/p&gt;
&lt;h3 id=&#34;光滑非光滑&#34;&gt;光滑/非光滑&lt;/h3&gt;
&lt;p&gt;目标函数每个点都可微就是光滑的，否则是非光滑的&lt;/p&gt;
&lt;h3 id=&#34;连续离散&#34;&gt;连续/离散&lt;/h3&gt;
&lt;p&gt;按照可行域连续或者离散分类&lt;/p&gt;
&lt;h3 id=&#34;单目标多目标&#34;&gt;单目标/多目标&lt;/h3&gt;
&lt;p&gt;对多个目标进行优化&lt;/p&gt;
&lt;p&gt;这门课只研究单目标连续光滑的凸优化问题&lt;/p&gt;
&lt;p&gt;判断是否为凸问题的一个关键，就是看约束集合、目标函数是否是凸集。所以凸集是凸优化问题最基本的一个概念。&lt;/p&gt;
&lt;h2 id=&#34;仿射集-affine-set&#34;&gt;仿射集 Affine set&lt;/h2&gt;
&lt;p&gt;集合中任取两个点，形成的&lt;strong&gt;直线&lt;/strong&gt;，如果整条线上的点也都在集合中，那么称该集合为仿射集
要求任意两点连成的直线在集合中，也就是说&lt;/p&gt;
&lt;p&gt;$$x_1, x_2 \in C, \theta\in R \to \theta x_1 + (1- \theta)x_2 \in C$$&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1640604307/convex-1.png&#34; alt=&#34;convex-1&#34;&gt;&lt;/p&gt;
&lt;p&gt;仿射组合：不仅限两个点，而是多个点：
$$x_1,...x_k \in C , \theta_1 + ... \theta_k = 1 \to \theta_1 x_1 + ... \theta_k x_k \in C$$&lt;/p&gt;
&lt;p&gt;利用
$$
(\theta_1 + \theta_2)(\frac{\theta_1}{\theta_1 + \theta_2}x_1 + \frac{\theta_2}{\theta_1 + \theta_2}x_2) + (1-\theta_1 - \theta_2)x_3 \in C
$$即可证明&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;任意线性方程组$Ax = b$的解集都是仿射集，任意仿射集都可以写成线性方程组的解集&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;假设该线性方程组有两个解$x_1, x_2$，则直线上的任意一点$\theta x_1+(1-\theta)x_2$代入得$A(\theta x_1+(1-\theta)x_2) = b$，说明也是该线性方程组的解&lt;/p&gt;
&lt;p&gt;仿射包：从非仿射集合中构造一个最小的仿射集&lt;/p&gt;
&lt;p&gt;比如两个点的集合不是仿射集，构造一个经过它们的直线，就是仿射集了，这条直线就是仿射包。三个不同直线的点，它们的最小的仿射包就是经过它们的二维平面。如果本身就是仿射集，那么仿射包就是它自己。&lt;/p&gt;
&lt;h2 id=&#34;凸集-convex-set&#34;&gt;凸集 convex set&lt;/h2&gt;
&lt;p&gt;凸集相比于仿射集条件放松，要求任意两点连成的&lt;strong&gt;线段&lt;/strong&gt;在集合中。凸集的定义为：&lt;/p&gt;
&lt;p&gt;$$x_1, x_2 \in C, \theta\in[0,1] \to \theta x_1 + (1- \theta_2)x_2 \in C$$&lt;/p&gt;
&lt;p&gt;仿射集必然是凸集，可以认为是一种特殊的凸集，凸集包含的更广。&lt;/p&gt;
&lt;p&gt;凸组合：不仅限两个点，而是多个点：
$$x_1,...x_k \in C , \theta_1 + ... \theta_k = 1, \theta_i\in[0,1] \to \theta_1 x_1 + ... \theta_k x_k \in C$$&lt;/p&gt;
&lt;p&gt;凸包：包含集合S的最小凸集&lt;/p&gt;
&lt;p&gt;下图2.2，只有左边的凸多边形是凸集。不过如果右图只少了角点，是凸集，少了边上或者内部的点就不是凸集了。&lt;/p&gt;
&lt;p&gt;下图2.3是凸包，包括一组离散点的凸包，以及非凸形状的凸包。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1640604308/convex-2.png&#34; alt=&#34;convex-2&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;典型凸集&#34;&gt;典型凸集&lt;/h2&gt;
&lt;h3 id=&#34;凸锥-convex-cone&#34;&gt;凸锥 Convex cone&lt;/h3&gt;
&lt;p&gt;锥：$\forall x \in C, \theta \geq 0, \theta x \in C$（锥尖需要在原点）&lt;/p&gt;
&lt;p&gt;凸锥：$x_1, x_2 \in C, \theta_1 x_1 + \theta_2 x_2 \in C, \theta_1 &amp;gt; 0, \theta_2 &amp;gt; 0$&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1640604308/convex-cone-1.png&#34; alt=&#34;convex-cone-1&#34;&gt;&lt;/p&gt;
&lt;p&gt;图形理解，任取两点$x_1, x_2$，如果$x_1,x_2,o$不在一条直线上，那么在$\overset{\frown}{x_1 o x_2}$的扇形区域内的所有的点都在凸锥集上&lt;/p&gt;
&lt;p&gt;过原点的直线和原点发出的射线是凸锥&lt;/p&gt;
&lt;p&gt;凸锥组合：$x_1,... x_k \in C, \theta_1 x_1 + ... \theta_k x_k \in C, \theta_1 &amp;gt; 0, ...  \theta_k &amp;gt; 0$&lt;/p&gt;
&lt;p&gt;凸锥包：和前面一样，如下图所示&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1640604308/convex-cone-2.png&#34; alt=&#34;convex-cone-2&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;对比一下前面几种组合：&lt;/strong&gt;
仿射组合：$\theta_1 + ... + \theta_k = 1$
凸组合：$\theta_1 + ... + \theta_k = 1, \theta_1, ... , \theta_k &amp;gt; 0$
凸锥组合：$\theta_1, ... , \theta_k \geq 0$&lt;/p&gt;
&lt;h3 id=&#34;超平面-hyperplane&#34;&gt;超平面 Hyperplane&lt;/h3&gt;
&lt;p&gt;${x|a^T x = b}$&lt;/p&gt;
&lt;p&gt;是仿射集，也是凸集，不一定凸锥（除非过原点）&lt;/p&gt;
&lt;h3 id=&#34;半空间-halfspace&#34;&gt;半空间 Halfspace&lt;/h3&gt;
&lt;p&gt;${ x|a^T x \leq b }$&lt;/p&gt;
&lt;p&gt;半空间是凸集，不是仿射集，不一定凸锥（除非过原点）&lt;/p&gt;
&lt;p&gt;下图分别为超平面和半空间：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1640604308/convex-5.png&#34; alt=&#34;convex-5&#34;&gt;&lt;/p&gt;
&lt;p&gt;证明：
假设$x_1, x_2$在空间上：
$a^T x_1 \leq b$
$a^T x_2 \leq b$
对于$x_1,x_2$上的任意一点$\theta x_1 + (1-\theta) x_2$有：
$a^T(\theta x_1 + (1-\theta) x_2) = \theta (a^T x_1 -b) + (1-\theta) (a^T x_2 - b) +b \leq b$，也在集合中，所以半空间是凸集&lt;/p&gt;
&lt;p&gt;法线的反方向&lt;/p&gt;
&lt;h3 id=&#34;空间球-euclidean-ball&#34;&gt;空间球 Euclidean Ball&lt;/h3&gt;
&lt;p&gt;欧几里得球，就是一个空间球&lt;/p&gt;
&lt;p&gt;$$
B\left(x_{c}, r\right)=\newline{x |\ ||x-x_{c}||_2\leq r \newline} $$&lt;/p&gt;
&lt;p&gt;$$=\newline{x |\ (x-x_{c})^{T}(x-x_{c} ) \leq r^2\newline}
$$&lt;/p&gt;
&lt;p&gt;证明：
假设$x_1, x_2$在空间上：
$|| x_1 - x_c ||_2 \leq r$
$|| x_2 - x_c ||_2 \leq r$
对于$x_1,x_2$上的任意一点$\theta x_1 + (1-\theta) x_2 $，（其中$\theta \in [0,1]$），有：
$$|| \theta x_1 + (1-\theta) x_2 - x_c ||_r = || \theta (x_1 - x_c) + (1-\theta)(x_2 - x_c)||\newline
\leq \theta ||x_1 - x_c||_2 + (1-\theta) ||x_2 - x_c||_2 \leq r
$$
这里用到了范数的三角不等式&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;范数性质
假设$x$的范数是$f(x)$，$f(x)\geq 0$，满足下面三条性质：
$\text{if}\ f(x)=0 \to x=0$
$kf(x) = |k|f(x)$
$f(x+y) \leq f(x) + f(y)$（三角不等式）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;椭球-ellipsoids&#34;&gt;椭球 Ellipsoids&lt;/h3&gt;
&lt;p&gt;$$\mathcal{E} = \{ x \mid\left(x-x_{c}\right)^{T} P^{-1}\left(x-x_{c}\right) \leq 1 \}$$&lt;/p&gt;
&lt;p&gt;矩阵P是一个 $n\times n$ 的对称正定矩阵&lt;/p&gt;
&lt;p&gt;（特征值，奇异值）&lt;/p&gt;
&lt;h3 id=&#34;多面体-polyhedra&#34;&gt;多面体 Polyhedra&lt;/h3&gt;
&lt;p&gt;多面体：有限个线性等式和不等式的解集
多面体是有限个半空间和超平面的交集&lt;/p&gt;
&lt;p&gt;$$
\mathcal{P}=\newline{x \mid a_{j}^{T} x \leq b_{j}, j=1, \ldots, m, c_{j}^{T} x=d_{j}, j=1, \ldots, p\newline}
$$&lt;/p&gt;
&lt;h3 id=&#34;范数球-norm-ball--范数锥-norm-cone&#34;&gt;范数球 Norm Ball &amp;amp; 范数锥 Norm Cone&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;范数：满足以下条件的函数$||\cdot||$
1、$||x||\geq 0$，$||x||=0$当且仅当$x=0$
2、$||tx|| = t||x||$，对于任何$t\in R$成立
3、$||x+y|| \leq ||x|| + ||y||$&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;$$
C={(x, t) \mid|x| \leq t} \subseteq \mathbf{R}^{n+1}
$$&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1640604308/convex-6.png&#34; alt=&#34;convex-6&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;其他的例子&#34;&gt;其他的例子&lt;/h3&gt;
&lt;p&gt;n*n的对称矩阵组成的集合，是凸锥，也是凸集&lt;/p&gt;
&lt;p&gt;n*n的半正定矩阵组成的集合，是凸集&lt;/p&gt;
&lt;p&gt;n*n的正定矩阵组成的集合不是凸集（取值只能&amp;gt;=0，不属于正定了）&lt;/p&gt;
&lt;p&gt;线性矩阵不等式的解集也是凸集&lt;/p&gt;
&lt;h2 id=&#34;保凸运算&#34;&gt;保凸运算&lt;/h2&gt;
&lt;p&gt;如果要证明是凸集可以用定义法，不过复杂情况会很难证明。
另一种方法是证明集合是多个凸集的保凸运算的简单组合，保凸运算包括以下几个：&lt;/p&gt;
&lt;h3 id=&#34;交集-intersection&#34;&gt;交集 Intersection&lt;/h3&gt;
&lt;p&gt;$C_1$, $C_2$是凸集，其交集$C = C_1 \cap C_2$也一定是凸集。&lt;/p&gt;
&lt;p&gt;拓展到n个也是。&lt;/p&gt;
&lt;h3 id=&#34;仿射函数-affine&#34;&gt;仿射函数 Affine&lt;/h3&gt;
&lt;p&gt;$f$是仿射变换：$\mathbf{R}^{n} \rightarrow \mathbf{R}^{m}$&lt;/p&gt;
&lt;p&gt;如果有$S \in R^n$是凸集，那么$f(S)=\newline{f(x) \mid x \in S\newline}$也是凸集，用定义证明即可。
逆函数$f^{-1}(S)=\newline{x \mid f(x) \in S\newline}$也是凸集。&lt;/p&gt;
&lt;h3 id=&#34;透视函数-perspective-functions&#34;&gt;透视函数 Perspective functions&lt;/h3&gt;
&lt;p&gt;透视函数 $P: \mathbf{R}^{n+1} \rightarrow \mathbf{R}^{n}$，相当于通过变换（所有元素除以最后一个元素）将最后一个维度的元素变为1，然后去掉这个维度的一种变换。降低一个维度。&lt;/p&gt;
&lt;p&gt;$P(\mathbf{X}, t) = \mathbf{X}/t, dom P = \newline{(\mathbf{X}, t), t &amp;gt; 0\newline}$
这里t是一个标量，X是矩阵，相当于P是dom(X)+1维度的，去掉最后一个维度t，X里的每一个元素除以t。&lt;/p&gt;
&lt;p&gt;类比于针孔相机，3维的点$(x_1, x_2, x_3)$会通过孔映射到二维的平面 $-(x_1/x_3, x_2/x_3, 1)$ 上，就是一个透视函数的过程。&lt;/p&gt;
&lt;p&gt;任意凸集的反透视映射也是凸集&lt;/p&gt;
&lt;h3 id=&#34;线性分段函数-linear-fractional&#34;&gt;线性分段函数 Linear-fractional&lt;/h3&gt;
&lt;p&gt;一个Linear-fractional function是由perspective function和一个affine function组成的&lt;/p&gt;
&lt;p&gt;$g(x)=\left[\begin{array}{c}A \newline c^{T}\end{array}\right] x+\left[\begin{array}{l}b \newline d\end{array}\right]$&lt;/p&gt;
&lt;h2 id=&#34;超平面分离定理与支撑超平面&#34;&gt;超平面分离定理与支撑超平面&lt;/h2&gt;
&lt;h3 id=&#34;超平面分离定理&#34;&gt;超平面分离定理&lt;/h3&gt;
&lt;p&gt;如果$C$和$D$是两个不相交的凸集，那么必然存在一个超平面$\newline{x|a^Tx = b\newline}$能够分离$C$和$D$，这超平面被称为分割超平面&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1641388051/convex-8.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;支撑超平面&#34;&gt;支撑超平面&lt;/h3&gt;
&lt;p&gt;集合C边界上的点$x_0$的支撑超平面：$\newline{x | a^Tx = a^T x_0\newline}$&lt;/p&gt;
&lt;p&gt;其中$a \neq 0$，对于所有的$x \in C$满足$a^Tx \leq a^T x_0$&lt;/p&gt;
&lt;p&gt;如果$C$是凸的，那么C边界上的每一个点都存在一个支撑超平面。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1641388051/convex-9.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;例题&#34;&gt;例题&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;设$C \subseteq R^n$是一个凸集，证明对于任意$k$的情况，满足$\theta_i \geq 0, \theta_1 + ... \theta_k = 1$的情况下，有$\theta_1 x_1 + ... + \theta_k x_k \in C$。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;证明：使用数学归纳法，
$k=2$时，根据凸集的定义性质可知，任取$\theta_1, \theta_2$，满足$\theta_1+\theta_2=1$，有$\theta_1 x_1 + \theta_2 x_2 \in C$&lt;/p&gt;
&lt;p&gt;假设$k=n-1$时上式成立，即满足$\theta_1+ ... +\theta_{n-1}=1$，有$\theta_1 x_1 + ... +  \theta_{n-1} x_{n-1} \in C$&lt;/p&gt;
&lt;p&gt;下面考虑$k=n$的情况，构造下面的式子：&lt;/p&gt;
&lt;p&gt;$$
(\sum_{i=1}^{k-1} \theta_i) \frac{\sum_{i=1}^{k-1} \theta_i x_i}{\sum_{i=1}^{k-1}\theta_i} + (1-\sum_{i=1}^{k-1} \theta_i)x_i
$$&lt;/p&gt;
&lt;p&gt;其中$\frac{\sum_{i=1}^{k-1} \theta_i x_i}{\sum_{i=1}^{k-1}\theta_i}$完全符合$n-1$的条件，所以$\frac{\sum_{i=1}^{k-1} \theta_i x_i}{\sum_{i=1}^{k-1}\theta_i} \in C$，整个式子又满足$k=2$的凸集的定义，所以有：
$$
(\sum_{i=1}^{k-1} \theta_i) \frac{\sum_{i=1}^{k-1} \theta_i x_i}{\sum_{i=1}^{k-1}\theta_i} + (1-\sum_{i=1}^{k-1} \theta_i)x_i \in C
$$&lt;/p&gt;
&lt;p&gt;即证明了只要$k=n-1$时成立，就有$k=n$时成立，数学归纳法得证&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;判断下面的哪些集合是凸集&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;（a）平板，形如$\newline{x \in \mathbf{R}^{n} \mid \alpha \leqslant a^{T} x \leqslant \beta\newline}\newline$&lt;/p&gt;
&lt;p&gt;（b）矩形，形如$\newline{x \in \mathbf{R}^{n} \mid \alpha_i \leqslant x_i \leqslant \beta_i\ , i = 1, ..., n \newline}$&lt;/p&gt;
&lt;p&gt;（c）楔形，形如$\newline{x \in \mathbf{R}^{n} \mid \alpha_1^T x \leqslant b_1 , \alpha_2^T x \leqslant b_2, i = 1, ..., n \newline}$&lt;/p&gt;
&lt;p&gt;（d）距离给定点比距离给定集合近的点构成的集合：
$ \newline{ x \mid ||x-x_0||_2 \leq ||x-y||_2, \forall y \in S \newline}$&lt;/p&gt;
&lt;p&gt;（e）距离一个集合比另一个集合更近的点的集合：$\newline{x \mid \operatorname{dist}(x, S) \leqslant \operatorname{dist}(x, T)\newline}$&lt;/p&gt;
&lt;p&gt;（f）集合$\newline{x \mid x + S_2 \subseteq S_1 \newline}$，其中$S_1, S_2 \subseteq R^n$，并且$S_1$是凸集&lt;/p&gt;
&lt;p&gt;（g）到 $a$ 的距离与到 $b$ 的距离之比不超过到某一固定分数$\theta$的点的集合，即集合$\newline{x \mid|x-a|_2 \leqslant \theta |x-b|_2\newline}$&lt;/p&gt;
&lt;p&gt;（a）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用定义证明：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;任取$x_1, x_2 \in C$，有$\alpha \leqslant a^{T} x_1 \leqslant \beta, \alpha \leqslant a^{T} x_2 \leqslant \beta$&lt;/p&gt;
&lt;p&gt;对于$\theta \in [0, 1]$，对于$ (\theta x_1 + (1-\theta) x_2)$，有：
$$\alpha = \theta \alpha + (1-\theta) \alpha \leq \alpha^T (\theta x_1 + (1-\theta) x_2) \leq \theta  \beta + (1-\theta) \beta = \beta$$&lt;/p&gt;
&lt;p&gt;即$ (\theta x_1 + (1-\theta) x_2) \in C$，是凸集&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用保凸性证明：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因为平板是两个半空间的交集，半空间是凸集，交集是保凸运算，所以平板也是凸集&lt;/p&gt;
&lt;p&gt;（b）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用定义证明：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;任取$x_1, x_2 \in C$，有$\alpha_i \leqslant x_1 \leqslant \beta_i, \alpha_i \leqslant x_2 \leqslant \beta_i$&lt;/p&gt;
&lt;p&gt;对于$\theta \in [0, 1]$，对于$ (\theta x_1 + (1-\theta) x_2)$，有：
$$\alpha_i \leq (\theta x_1 + (1-\theta) x_2) \leq \beta_i$$&lt;/p&gt;
&lt;p&gt;即$ (\theta x_1 + (1-\theta) x_2) \in C$，是凸集&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用保凸性证明：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;矩形是多个半空间的交集，半空间是凸集，交集是保凸运算，所以矩形也是凸集&lt;/p&gt;
&lt;p&gt;（c）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用定义证明：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;任取$x_1, x_2 \in C$，有$a_1^{T} x_1 \leqslant b_1, a_2^{T} x_1 \leqslant b_2$、$a_1^{T} x_2 \leqslant b_1, a_2^{T} x_2 \leqslant b_2$&lt;/p&gt;
&lt;p&gt;对于$\theta \in [0, 1]$，对于$ (\theta x_1 + (1-\theta) x_2)$，有：
$$a_1^T (\theta x_1 + (1-\theta) x_2) \leq \theta b_1 + (1-\theta) b_1 = b_1\newline
a_2^T (\theta x_1 + (1-\theta) x_2) \leq \theta b_2 + (1-\theta) b_2 = b_2$$&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用保凸性证明：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;楔形是多个半空间的交集，半空间是凸集，交集是保凸运算，所以楔形也是凸集&lt;/p&gt;
&lt;p&gt;（d）
对于固定的$y$而言，有：
$$
\begin{array}{ll}
&amp;amp;||x-x_0||_2 \leqslant ||x-y||_2\newline
\Leftrightarrow &amp;amp; (x-x_0)^T(x-x_0) \leqslant (x-y)^T (x-y)\newline
\Leftrightarrow &amp;amp; x^T x - 2x_0^T x + x_0^T x_0 \leqslant x^T x - 2y^T x + y^T y\newline
\Leftrightarrow &amp;amp; 2(y^T - x_0^T)x \leqslant y^T y - x_0^T x_0 \newline
\end{array}
$$
s
说明该集合是多个半空间的交集，交集为保凸运算，所以该集合为凸集&lt;/p&gt;
&lt;p&gt;（e）
不是凸集，可以举反例，比如$S = {(x, y)|x^2 + y^2 = 1}$，$T = {(0, 0)}$，那么这个集合就是$R^2$平面挖空一个圆心在原点，半径为$\frac{1}2$的孔，比如集合上取$(0, 1),(0, -1)$两点，取$\theta=0.5$，$(0,0)$不在这个集合内，很显然它不是凸集。&lt;/p&gt;
&lt;p&gt;（f）
令$y \in S_2$，集合相当于是多个凸集$(S_1 - y)$的交集，交集为保凸运算，所以也是凸集。&lt;/p&gt;
&lt;p&gt;（g）
是凸集
$$
\begin{array}{ll}
&amp;amp; ||x-a||_2 \leqslant \theta||x-b||_2\newline
\Leftrightarrow &amp;amp; (1-\theta^2)x^Tx - 2 (a-\theta^2b)^Tx + (a^Ta - \theta^2b^Tb) \leq 0
\end{array}
$$&lt;/p&gt;
&lt;p&gt;如果$\theta \leq 1$，集合是一个球
如果$\theta = 1$，集合是半空间
都是凸集&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;一些概率分布集合，令$x$为服从分布 $\textbf{prob}(x=a_i) = p_1, i = 1, ... ,n$ 的实数随机变量，$p \in R^n$在一个标准概率单纯形$P=\{p \mid \mathbf{1}^{T} p=1, p \succeq 0\}$，下面哪些条件在$p$中是凸的？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;（a）$\alpha \leqslant \textbf{E} f(x) \leqslant \beta$&lt;/p&gt;
&lt;p&gt;（b）$\textbf{prob}(x&amp;gt;\alpha) \leqslant \beta$&lt;/p&gt;
&lt;p&gt;（c）$\textbf{E} |x^3| \leqslant \alpha \textbf{E} |x|$&lt;/p&gt;
&lt;p&gt;（d）$\textbf{E} x^2 \leqslant \alpha$&lt;/p&gt;
&lt;p&gt;（e）$\textbf{E} x^2 \geqslant \alpha$&lt;/p&gt;
&lt;p&gt;（f）$\textbf{var} (x) \leqslant \alpha$&lt;/p&gt;
&lt;p&gt;（g）$\textbf{var} (x) \geqslant \alpha$&lt;/p&gt;
&lt;p&gt;（h）$\textbf{quartile} (x) \geqslant \alpha$，$\textbf{quartile} (x) = \text{inf} \{ \beta | \textbf{prob}(x\leqslant \beta) \geqslant 0.25\}$&lt;/p&gt;
&lt;p&gt;（i）$\textbf{quartile} (x) \leqslant \alpha$&lt;/p&gt;
&lt;p&gt;$p$的约束：$p_i \geq 0$是n个半空间，约束$\sum_{i=1}^n = 1$是超平面，也就是说$p$是一个多面体，本身为凸集。&lt;/p&gt;
&lt;p&gt;（a）
$\alpha \leq \sum_{i=1}^n p_i f(a_i) \leq \beta$
增加线性不等式约束，仍为凸集&lt;/p&gt;
&lt;p&gt;（b）
$\textbf{prob}(x\geq \alpha) = \sum_{i, a_i \geq \alpha}p_i \leq \beta$
增加线性不等式约束，仍为凸集&lt;/p&gt;
&lt;p&gt;（c）
$\mathbf{E}\left|x^{3}\right| \leq \alpha \mathbf{E}|x| \to \sum_{i=1}^{n} p_{i}\left(\left|a_{i}^{3}\right|-\alpha\left|a_{i}\right|\right) \leq 0$
增加线性不等式约束，仍为凸集&lt;/p&gt;
&lt;p&gt;（d）
$\sum_{i=1}^{n} p_{i} a_{i}^2 \leq \alpha$
增加线性不等式约束，仍为凸集&lt;/p&gt;
&lt;p&gt;（e）
$\sum_{i=1}^{n} p_{i} a_{i}^2 \geq \alpha$
增加线性不等式约束，仍为凸集&lt;/p&gt;
&lt;p&gt;（f）
$\textbf{var}(x)=\mathbf{E} x^2-(\mathbf{E} x)^2=\sum_{i=1}^{n} p_{i} a_{i}^2-\left(\sum_{i=1}^{n} p_{i} a_{i}\right)^2 \leq \alpha$
不是凸集。举反例，比如$a_1 = 0, a_2 = 1, \alpha = 0.2$，两个点$p_1 = (0, 1), p_2 = (1,0)$，有$\textbf{var}(x) \leq \alpha$，但是中间的点$(\frac{1}2, \frac{1}2)$明显不满足。&lt;/p&gt;
&lt;p&gt;（g）
$\textbf{var}(x)=\mathbf{E} x^2-(\mathbf{E} x)^2=\sum_{i=1}^{n} p_{i} a_{i}^2-\left(\sum_{i=1}^{n} p_{i} a_{i}\right)^2 = b^T p + p^T A p  \geq \alpha$
因为$A = a a^T$是半正定的，所以是凸集&lt;/p&gt;
&lt;p&gt;（h）
$\textbf{prob}\left(x \leq a_{k}\right)=\sum_{i=1}^{k} p_{i}&amp;lt;0.25$
是一个半空间，是凸集。&lt;/p&gt;
&lt;p&gt;（i）
$\sum_{i=k+1}^{n} p_{i} \geq 0.25$
是一个半空间，是凸集。&lt;/p&gt;
</content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://yichengme.site/categories/%E6%8A%80%E6%9C%AF/" term="技术" label="技术" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://yichengme.site/tags/%E5%87%B8%E4%BC%98%E5%8C%96/" term="凸优化" label="凸优化" />
                            
                        
                            
                            
                            
                                <category scheme="https://yichengme.site/tags/%E6%95%B0%E5%AD%A6/" term="数学" label="数学" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">返璞归真，博客重新迁移到Hugo</title>
            <link rel="alternate" type="text/html" href="https://yichengme.site/posts/hello-world/" />
            <id>https://yichengme.site/posts/hello-world/</id>
            <updated>2022-01-12T12:31:42&#43;08:00</updated>
            <published>2021-12-21T23:08:40&#43;08:00</published>
            <author>
                    <name>王毅诚</name>
                    <uri>https://yichengme.site/</uri>
                    <email>engine74396@gmail.com</email>
                    </author>
            <rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">第一次开博客应该是在大二的时候，也就是2018年，用的是Hexo。之后觉得配置太少，想要有发挥的空间，就用当时学的Django写了一个博客网站，再后来又改成了G……</summary>
            
                <content type="html">&lt;p&gt;第一次开博客应该是在大二的时候，也就是2018年，用的是Hexo。之后觉得配置太少，想要有发挥的空间，就用当时学的Django写了一个博客网站，再后来又改成了Go+Vue，作为一个前后端分离的单体应用，包含博客的完整的功能，还能有其他拓展。&lt;/p&gt;
&lt;p&gt;这本来应该是博客的最终形态了，然而精力有限，不想折腾markdown渲染和其他各种功能，以及为一些前后端、运维、优化的问题所烦恼，再加上服务器成本也不少，还是希望能够纯粹的写作。&lt;/p&gt;
&lt;p&gt;因此现在又回到了最初的起点，转回了静态网页，这次改用Hugo搭建（和hexo类似），之前的博客内容会逐步迁移过来，由于发布文章很方便，之后会增加更多的内容，敬请期待。&lt;/p&gt;
</content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://yichengme.site/categories/%E7%94%9F%E6%B4%BB/" term="生活" label="生活" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://yichengme.site/tags/hugo/" term="hugo" label="hugo" />
                            
                        
                            
                            
                            
                                <category scheme="https://yichengme.site/tags/site/" term="site" label="site" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">分布式系统（二）：共识算法</title>
            <link rel="alternate" type="text/html" href="https://yichengme.site/posts/distribution-system-2/" />
            <id>https://yichengme.site/posts/distribution-system-2/</id>
            <updated>2022-02-27T15:21:45&#43;08:00</updated>
            <published>2021-12-19T23:18:18&#43;08:00</published>
            <author>
                    <name>王毅诚</name>
                    <uri>https://yichengme.site/</uri>
                    <email>engine74396@gmail.com</email>
                    </author>
            <rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">拜占庭将军问题 拜占庭将军问题是分布式领域最复杂的一个容错模型，较好地抽象了分布式系统面临的共识问题。 假如你是一位拜占庭的将军，需要与其他几个国家的军队做沟通，而……</summary>
            
                <content type="html">&lt;h2 id=&#34;拜占庭将军问题&#34;&gt;拜占庭将军问题&lt;/h2&gt;
&lt;p&gt;拜占庭将军问题是分布式领域最复杂的一个容错模型，较好地抽象了分布式系统面临的共识问题。&lt;/p&gt;
&lt;p&gt;假如你是一位拜占庭的将军，需要与其他几个国家的军队做沟通，而信使可能会被杀，可能会被替换，可能某国军队会传递错误信息等等，抽象出来的问题就是，如何在可能有错误发生的情况下，让多个节点达成共识，保持一致。&lt;/p&gt;
&lt;p&gt;拜占庭将军是最困难的一种情况，因为会存在恶意节点行为行为，在某些场景（比如数字货币区块链）只能使用拜占庭容错算法（Byzantine Fault Torerace，BFT），常见的拜占庭算法有口信消息型算法、签名消息型算法、PBFT算法、PoW算法等。&lt;/p&gt;
&lt;p&gt;在计算机分布式系统中，最常使用的还是非拜占庭容错算法，也就是故障容错算法（Crash Fault Tolerance，CFT），解决的是分布式系统中存在故障，但不存在恶意节点的场景。常见的算法有Paxos算法、Raft算法、ZAB协议等，这些协议之后都会讲解。&lt;/p&gt;
&lt;p&gt;不过对于恶性的情况，一般只在区块链中出现，算法有PBFT、PoW等。但是我并没有打算涉足区块链相关的研究，所以这些算法不在讨论范围之内。&lt;/p&gt;
&lt;h2 id=&#34;共识算法的概念&#34;&gt;共识算法的概念&lt;/h2&gt;
&lt;p&gt;共识算法就是用来达成一致性的方法。&lt;/p&gt;
&lt;p&gt;需要满足三个条件：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Termination：保证算法最后可以做出决定，不能是无限循环的&lt;/li&gt;
&lt;li&gt;Validity：最终决议一定来自于其中一个参与的节点&lt;/li&gt;
&lt;li&gt;Agreement：算法完成时，所有节点一定会做出相同的决定&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;FLP定理：完美的共识算法不存在。在非同步的网络环境中，就算只应付一个节点故障，也没有一个共识算法能保证完全正确。&lt;/p&gt;
&lt;p&gt;一般的共识算法分为两类：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Symmetric, no leader&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;所有的节点地位等同，client可以向每一个server发送请求&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;Asymmetric, leader based&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;任一时刻只会有一个leader，leader处理client的请求，其余server只接受leader的决策，client只可以向leader发送请求。&lt;/p&gt;
&lt;h2 id=&#34;paxos算法&#34;&gt;Paxos算法&lt;/h2&gt;
&lt;p&gt;Paxos算法是分布式共识算法的元老，目前最流行的分布式算法都是基于Paxos改进的，所以不得不提。&lt;/p&gt;
&lt;p&gt;兰伯特Lamport提出的Paxos包含两个部分：
一个是Basic Paxos，描述的是多个节点之间如何就一个value达成共识；
一个是Multi-Paxos，描述的是执行多个Basic Paxos实例，为一系列value达成共识。
这一节只说Basic Paxos，Multi-Paxos下一节&lt;/p&gt;
&lt;h3 id=&#34;系统角色&#34;&gt;系统角色&lt;/h3&gt;
&lt;p&gt;提议者（Proposers）：向系统里的其他节点提出v=C，希望大家达成共识。&lt;/p&gt;
&lt;p&gt;接受者（Acceptors）：不发起proposal的节点，接受Proposers的提议。&lt;/p&gt;
&lt;p&gt;学习者（Learner）：不参与投票的过程，被告知投票的结果，接受达成的共识存储保存数据。&lt;/p&gt;
&lt;h3 id=&#34;算法流程&#34;&gt;算法流程&lt;/h3&gt;
&lt;p&gt;分为两个流程：&lt;/p&gt;
&lt;p&gt;第一步：准备阶段&lt;/p&gt;
&lt;p&gt;在提出提案之前，先得到超过半数节点的回应，也就是有半数以上的节点愿意聆听这个Proposer。假设这次要发送的数据是v&lt;/p&gt;
&lt;p&gt;具体的过程：Proposers向所有节点发送&lt;code&gt;Prepare(n)&lt;/code&gt;，n包含了一些元信息，可以比较大小，Acceptors接收到后，与这一轮从其他Proposers里收到的最大的提议N比较。&lt;/p&gt;
&lt;p&gt;准备阶段只需要发送n即可，不需要发送v。&lt;/p&gt;
&lt;p&gt;如果$n&amp;lt;N$，也就是目前的这个提议的n比这一轮已有的最大的N还小，直接无视这个提议。
否则，就认为当前提议更好，如果此时已经发送过了一个返回给之前最大的那个Proposer，就返回一个&lt;code&gt;ack(n, (nx, vx))&lt;/code&gt;，n是这一次的n，nx是之前最大的那个Proposer的n，vx之前最大的那个Proposer的x。如果之前没接受过其他提议，就发送&lt;code&gt;ack(n, (null, null))&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;第二步：接受阶段&lt;/p&gt;
&lt;p&gt;Proposers等待过半的Acceptors返回后，对&lt;code&gt;ack&lt;/code&gt;作出判断，如果里面有节点的&lt;code&gt;ack&lt;/code&gt;返回的nx、vx不为空，就主动放弃，找出里面最大nx的vx，再发送&lt;code&gt;accept(n,vx)&lt;/code&gt;给所有的Acceptors。
如果都为空的话，就传送&lt;code&gt;accept(n,v)&lt;/code&gt;给所有的Acceptors。&lt;/p&gt;
&lt;p&gt;Acceptors收到&lt;code&gt;accept(n,v)&lt;/code&gt;后，不过可能还会收到&lt;code&gt;prepare(n)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Paxos论文描述：
&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1640193486/paxos-8.png&#34; alt=&#34;paxos-8&#34;&gt;&lt;/p&gt;
&lt;p&gt;一些容易想错的地方，进行声明：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;这里的n并不是具体的int，只是为了简单描述算法，实际上这里的n是一种数据结构，但是相互之间可以被比较，并且对于每个节点而言，它们的n必然不相同。
并不是说一个节点只能当Proposer、Acceptor、Learner中的一种，实际上，每个节点都同时具有这三种角色。
Basic Paxos只是对一个值形成决议，并不是多个值。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;具体例子&#34;&gt;具体例子&lt;/h3&gt;
&lt;p&gt;举一个具体的例子，两个客户端作为提议者，n分别为1和5，v分别为3和7，有三个接受者。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;准备阶段&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;提议者分别发送&lt;code&gt;Prepare(n)&lt;/code&gt;给三个节点，假设说AB先接收到了客户端1的信息，C先接受到了客户端2的信息&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1640193484/paxos-1.jpg&#34; alt=&#34;paxos-1&#34;&gt;&lt;/p&gt;
&lt;p&gt;由于接受者之前没有提案（也可以认为目前的n是无穷小），所以接受到第一个提案后都进行响应，返回&lt;code&gt;ack(n, (null, null))&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1640193485/paxos-2.jpg&#34; alt=&#34;paxos-2&#34;&gt;&lt;/p&gt;
&lt;p&gt;之后AB接受到客户端2传来的&lt;code&gt;Prepare(5)&lt;/code&gt;，5&amp;gt;1，所以会发送准备响应给2。C接受到客户端1传来的&lt;code&gt;Prepare(1)&lt;/code&gt;，1&amp;lt;5，直接无视该请求&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1640193485/paxos-3.jpg&#34; alt=&#34;paxos-3&#34;&gt;&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;接受阶段
由于1、2都收到了多于半数的准备返回响应，并且返回的响应包含的之前最大提案号为空，所以会发送分别接受请求&lt;code&gt;accpet(1, 3)&lt;/code&gt;和&lt;code&gt;accept(5, 7)&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1640193484/paxos-4.jpg&#34; alt=&#34;paxos-4&#34;&gt;&lt;/p&gt;
&lt;p&gt;最后ABC接受到1的确认，由于之前承诺不再接受n小于5的，所以不会变。接受到5的确认后就修改为了5&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1640193485/paxos-5.jpg&#34; alt=&#34;paxos-5&#34;&gt;&lt;/p&gt;
&lt;p&gt;假设另一个例子，在某个顺序AB是n=5,v=7，C是n=1,v=3。此时有一个请求[9, 6]，发送给ABC之后，准备阶段，由于9&amp;gt;5，ABC会接受，并返回
&lt;code&gt;ack(n, (nx, nv))&lt;/code&gt;，具体是AB返回&lt;code&gt;ack(9, (5, 7))&lt;/code&gt;,C返回&lt;code&gt;ack(9, (1, 3))&lt;/code&gt;，那么客户端3由于接受到的返回不为空，就会判断之前最大的n，这里是5，对应的v是7，所以在接受阶段会发送&lt;code&gt;accpet(9, 7)&lt;/code&gt;给所有节点。&lt;/p&gt;
&lt;p&gt;可以参考这个视频：https://www.youtube.com/watch?v=UUQ8xYWR4do&lt;/p&gt;
&lt;h2 id=&#34;multi-paxos&#34;&gt;Multi-Paxos&lt;/h2&gt;
&lt;p&gt;Multi-Paxos并不是一个具体的算法，而是一种思想。指的是基于Mulit-Paxos算法通过多个Basic Paxos实例实现一系列值的共识的算法。（比如Raft算法、ZAB协议等）&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1640193485/paxos-6.jpg&#34; alt=&#34;paxos-6&#34;&gt;&lt;/p&gt;
&lt;p&gt;由于第一阶段收到大多数准备响应的提议者才能发起第二阶段，那么如果多个提议者同时提交提案，可能因为永远无法收到超过半数的准备响应而阻塞。（比如系统中有5个节点，有3个同时发起提案）。
另一个问题是两轮的RPC太消耗性能，也增加了延迟。&lt;/p&gt;
&lt;p&gt;通过引入Leader（领导者）角色以及优化Basic Paxos来解决这两个问题。
Leader节点作为唯一的提议者，这样就不存在提议冲突的情况。
Leader的提案永远是最新的，所以省略掉准备阶段，直接开始接受阶段：
&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1640193485/paxos-7.jpg&#34; alt=&#34;paxos-7&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;chubby的multi-paxos实现&#34;&gt;Chubby的Multi-Paxos实现&lt;/h3&gt;
&lt;p&gt;Chubby实现了闭源的Multi-Paxos，通过引入Leader节点。Leader是通过执行Basic Paxos投票产生的。
运行过程中会通过续租的方式延长租期，如果Leader故障，其他节点会选举出新的Leader。
所有的读和写操作也只能在Leader上进行：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;写请求，Leader收到客户端的写请求，作为唯一的Proposer执行Basic Paxos将数据发给所有的节点来达成一致，半数以上的服务器接受了写请求之后，响应给客户端成功&lt;/li&gt;
&lt;li&gt;读请求，很简单，Leader直接查询本地数据返回给客户端即可。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Chubby的ulti-Paxos实现的一些点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Leader本地的数据一定是最新的。&lt;/li&gt;
&lt;li&gt;可以容忍$\frac{n-1}{2}$个节点的故障&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;raft&#34;&gt;Raft&lt;/h2&gt;
&lt;p&gt;Raft算法在Multi-Paxos的思想上进行了简化和限制，是最常用的一个共识算法，也是目前分布式系统的首选共识算法。包括Etcd、Consul等。&lt;/p&gt;
&lt;p&gt;本质上来说，Raft算法是通过一切以领导者为准的方式，实现一系列值的共识和各节点的日志一致。&lt;/p&gt;
&lt;p&gt;强烈推荐看一下这个可视化的Raft，可以加深理解：http://thesecretlivesofdata.com/raft/&lt;/p&gt;
&lt;h3 id=&#34;leader选举&#34;&gt;Leader选举&lt;/h3&gt;
&lt;p&gt;服务器节点的状态分为三种：Leader（领导者）、Follower（追随者）、Candidate（候选人），其中Leader有且只有一个。&lt;/p&gt;
&lt;p&gt;Leader：系统的核心角色，负责处理写请求、管理日志复制和不断与其他节点维持心跳，告知节点Leader存活，不要选举
Follower：普通群众，接受和处理来自Leader的消息，如果Leader心跳超时就主动站出来变成Candidate
Candidate：候选人，向其他节点发送RequestVote的RPC消息，通知其他节点投票，一旦获得了多数投票就晋升为Leader&lt;/p&gt;
&lt;p&gt;Raft算法实现了随机超时时间，每个节点等待Leader的心跳超时时间随机。&lt;/p&gt;
&lt;p&gt;初始时没有Leader，都是Follower，所有节点听不到Leader心跳，超时时间最小的节点首先称为候选者。
它会增加自己的任期编号，给自己先投一票，然后发送RPC请求其他节点投票。
其他节点收到RPC投票消息之后，如果还没有称为候选者，也还没投票的话，就会去投一票，同时增加自己的任期编号。
如果在选举超时时间内获得了大多数的选票，就晋升为Leader。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;关于RPC
Raft算法总共有两类RPC，一个是请求投票RequestVote，一个是日志复制AppendEntries&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;关于timeout
每个节点的等待时间有两种：
① 一个是election timeout，也就是从上一次Leader心跳开始算，如果过了这个timeout还没听到心跳，就自己称为Candidate，这个timeout一般是150-300ms
② heartbeat timeout&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;关于任期
任期由单调递增的数字（任期编号）标识
何时加1？Follow发现Leader心跳超时，将自己任期+1，并发RPC
何时更新？
① 跟随者接受到包含任期的RPC请求后，发现任期比自己的大，就更新自己的任期为更大的任期。
② Leader或者Candidate发现自己的任期编号比其他节点小，会立即降为Follower&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果一个节点收到一个包含任期编号比自己小的RPC请求，会直接无视。
任期编号相同时，日志完整性高的Follow会拒绝投票给日志完整性低的Candidate&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;做法就是RequestVote RPC也会包含Candidate自己最后一个log entry的index和term，如果收到RequestRPC的节点发现这个Candidate最后一个log的term小于自己的term，或者term相等的时候index小于自己的index，那么就不会投票给它。这一策略保证了Leader一定拥有最完整的log entries&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;可能会出现多个Candidate同时发起投票请求，这样的话瓜分选票会导致无法选出半数以上的票，不过Raft通过随机超时时间解决了这一问题，把超时时间都进行了分散。这里的超时时间有两种，一个是Follower和Leader维持的心跳超时，一个是等待选举超时的时间间隔。&lt;/p&gt;
&lt;p&gt;当然还有可能出现的极限情况，比如说刚好两个Candidate各拿到了一半的票，那么陷入阻塞，此时这两个Candidate还会有随机timeout，如果时间过了就重新发送RequestVote&lt;/p&gt;
&lt;p&gt;几个注意的点：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;只有日志最完整的节点才能当Leader，Raft中，日志必须是连续的&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;日志复制&#34;&gt;日志复制&lt;/h3&gt;
&lt;p&gt;日志项包含指令、索引值、任期编号等。&lt;/p&gt;
&lt;p&gt;第一阶段，Leader通过日志复制AppendEntries，将日志项复制到集群的其他节点上，如果收到了大多数的“复制成功”消息，就把提交这条日志，并返回成功给客户端，否则会返回错误给客户端。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;一开始只是保存日志到本地，比如客户端提交一条&lt;code&gt;SET x = 5&lt;/code&gt;，Leader会先把这条写在日志里，不会修改x的值，等到多数节点返回成功之后才会执行这条指令，把x设为5。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;AppendEntries RPC在每个heartbeat都会发送&lt;/p&gt;
&lt;p&gt;Leader不需要发送消息来告知其他节点提交日志项，Leader的日志复制RPC和心跳包含了当前最大的将被提交的日志项。从而将二阶段简化为一阶段。&lt;/p&gt;
&lt;p&gt;具体的过程为：
&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1640193609/raft-1.jpg&#34; alt=&#34;raft-1&#34;&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;客户端提交一条写请求&lt;/li&gt;
&lt;li&gt;Leader将其存在本地日志上，然后给各个Followers发送日志复制AppendEntries RPC，&lt;/li&gt;
&lt;li&gt;如果有多数的Follower返回成功，Leader就将日志进行提交&lt;/li&gt;
&lt;li&gt;Leader将执行的结果返回给客户端&lt;/li&gt;
&lt;li&gt;之后如果Follower收到新的日志复制RPC或心跳，发现自己有日志项没提交，就进行提交&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;日志一致性的保证：
Leader的日志必然是完整的，以Leader的日志为准来协调各个节点的日志。&lt;/p&gt;
&lt;p&gt;首先通过AppendEntries RPC的一致性检查来找到自己与Follower相同日志项的最大索引值，之前的日志Follower和Leader一致，之后的就不一致了，然后Leader强制Follower覆盖不一致日志。&lt;/p&gt;
&lt;p&gt;引入两个变量：
PrevLogEntry：当前要复制的日志项的前一项的索引值，下面例子中为7
PrevLogTerm：当前要复制的日志项的前一项的任期编号，下面例子中为4&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1640193609/raft-2.jpg&#34; alt=&#34;raft-2&#34;&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Leader发送AppendEntries RPC，包含当前任期编号4、PrevLogEntry=7、PrevLogTerm=4，&lt;/li&gt;
&lt;li&gt;Follower发现自己的索引中没有这一条，返回Failure&lt;/li&gt;
&lt;li&gt;Leader递减要复制的日志项的索引，发送PrevLogEntry=6、PrevLogTerm=3&lt;/li&gt;
&lt;li&gt;Follower能在本地日志找到这一项，返回Success&lt;/li&gt;
&lt;li&gt;Leader知道了自己与该Follower的相同日志的最大索引，复制并更新覆盖索引值之后的日志项。&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;为什么要上一条？因为这一条的话刚写，必然不一样，如果Follower一直和Leader一致，Follower是有Leader的上一条的，但是必然没有Leader新的一条，所以Leader如果从最新的一条发RPC，每一个节点都必然返回Failure，然后递减，非常浪费RPC。
由于大部分节点是能同步日志的，所以第一次都会返回Success，然后Leader把新的一条复制过去即可，对于第一次Failure的个别节点，才会递减找到相同的最大索引值。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;成员变更&#34;&gt;成员变更&lt;/h3&gt;
&lt;p&gt;在成员进行变更的时候，如何避免出现大于一个的Leader？
比如出现了分区，节点被分为了多个簇，簇与簇之间无法沟通，那么每个簇内都会有一个Leader。&lt;/p&gt;
&lt;p&gt;如果只是为了解决不出现多个Leader的情况，最暴力的方式就是节点全部关闭然后再重新启动，这样投票只会有一个Leader，但是这段时间系统会瘫痪，明显不合理。
最常用的方法是单节点变更，也就是每次只变更一个节点。&lt;/p&gt;
&lt;p&gt;比如当前集群配置为[A, B, C]，现在往里面加入[D, E]，一个一个加，先加D进去：
首先Leader向D同步所有数据，然后Leader更新自己的配置为[A,B,C,D]，将包含新配置的日志项提交到本地状态机，完成单节点变更，之后E加入也一样。
通过单节点变更，可以保证系统只有一个Leader。&lt;/p&gt;
&lt;p&gt;可以看一下Raft作者讲的：
&lt;a href=&#34;https://www.youtube.com/watch?v=vYp4LYbnnW8&#34;&gt;https://www.youtube.com/watch?v=vYp4LYbnnW8&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;p&gt;以这张图进行总结：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1640193631/%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95-1.png&#34; alt=&#34;共识算法-1&#34;&gt;&lt;/p&gt;
&lt;p&gt;对于上述共识算法进行比较：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Backup，简单备份&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;比如mac的time machine。
首先对于Consistency一致性，是无法保证的，一旦改变当前的文件，备份的旧版本和目前的会不一致。
Transaction事务也只能是weak。
Latency（时延）低、Throuput（吞吐量）高，因为读写的时候不需要运行协议，直接读取即可。
Data loss，如果没备份完，系统失效了，那最新的资料会遗失。
Failover 故障恢复，系统恢复的这段时间系统是不能工作的。&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;Master/Salve 主从模式&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;读写请求都在master上进行，master将更新 的数据写到slave上。类似Dropbox。&lt;/p&gt;
&lt;p&gt;Consistency：可以实现最终一致性
Transactions：Master支持完整事务
Latency、Throuput：读写的时候都直接在master上完成，所以低时延、高吞吐。
Data loss：可能造成数据丢失
Failover：恢复的时候slave还是可以提供read&lt;/p&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;Master/Master&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Leaderless模式，每一个节点都可以接受读写请求。比如DynamoDB。&lt;/p&gt;
&lt;p&gt;Consistency：可以实现最终一致性
Transactions：只能本地支持
Latency、Throuput：低时延、高吞吐。
Data loss：可能造成数据丢失
Failover：仍能正常运作&lt;/p&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;2PC&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;二阶段模式&lt;/p&gt;
&lt;p&gt;Consistency：强一致性
Transactions：支持完整事务
Latency、Throuput：因为每次都需要两阶段，比较差
Data loss：只要写入后资料达成一致就不会丢失
Failover：仍能正常运作&lt;/p&gt;
&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;Paxos &amp;amp; Raft&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;虽然表中没有raft，实际上raft和paxos也差不多。
Paxos可以认为是优化2PC之后的最优解。&lt;/p&gt;
&lt;p&gt;Consistency：强一致性
Transactions：支持完整事务
Latency、Throuput：需要半数达成一致，相对差一点
Dataloss：只要写入后资料达成一致就不会丢失
Failover：只要有半数的节点存活就可以正常运行。&lt;/p&gt;
&lt;p&gt;参考：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://ithelp.ithome.com.tw/users/20121042/ironman/2792&#34;&gt;https://ithelp.ithome.com.tw/users/20121042/ironman/2792&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://time.geekbang.org/column/intro/100046101&#34;&gt;https://time.geekbang.org/column/intro/100046101&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://yichengme.site/categories/%E6%8A%80%E6%9C%AF/" term="技术" label="技术" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://yichengme.site/tags/%E5%88%86%E5%B8%83%E5%BC%8F/" term="分布式" label="分布式" />
                            
                        
                            
                            
                            
                                <category scheme="https://yichengme.site/tags/%E7%B2%BE%E9%80%89/" term="精选" label="精选" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">分布式系统（一）：CAP及基础理论</title>
            <link rel="alternate" type="text/html" href="https://yichengme.site/posts/distribution-system-1/" />
            <id>https://yichengme.site/posts/distribution-system-1/</id>
            <updated>2022-02-27T15:21:46&#43;08:00</updated>
            <published>2021-11-19T00:21:18&#43;08:00</published>
            <author>
                    <name>王毅诚</name>
                    <uri>https://yichengme.site/</uri>
                    <email>engine74396@gmail.com</email>
                    </author>
            <rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">ACID、BASE、2PC/3PC ACID 在讲ACID之前，先讲本地事务，事务最早在数据库等课程中就接触过，简单来说，事务提供一种“要么什么也不做，要么全做完”的机制……</summary>
            
                <content type="html">&lt;h2 id=&#34;acidbase2pc3pc&#34;&gt;ACID、BASE、2PC/3PC&lt;/h2&gt;
&lt;h3 id=&#34;acid&#34;&gt;ACID&lt;/h3&gt;
&lt;p&gt;在讲ACID之前，先讲本地事务，事务最早在数据库等课程中就接触过，简单来说，事务提供一种“要么什么也不做，要么全做完”的机制。&lt;/p&gt;
&lt;p&gt;ACID特性是数据库事务的基本特征，包括：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Atomicity 原子性&lt;/li&gt;
&lt;li&gt;Consistency 一致性&lt;/li&gt;
&lt;li&gt;Isolation 隔离性&lt;/li&gt;
&lt;li&gt;Durability 持久性&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;合称就是ACID（在英语中正好是酸的意思，之后的BASE碱也与之对应）&lt;/p&gt;
&lt;p&gt;然而分布式事务和本地事务不同，假设有一个操作需要多个机器上执行，要么都执行，要么都不执行。
要保持分布式事务的ACID，方法有二阶段提交协议和TCC。&lt;/p&gt;
&lt;h3 id=&#34;2pc二阶段提交协议&#34;&gt;2PC二阶段提交协议&lt;/h3&gt;
&lt;p&gt;一个事务跨越多个节点，成为分布式事务，为了保持ACID，需要引入一个协调者的角色来统一掌控所有节点的结果。&lt;/p&gt;
&lt;p&gt;整个过程被分为两个阶段：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;准备阶段（投票）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;协调者给每个参与者发送Prepare信息，每个参与者有两种选择：
①返回失败
②本地执行事务返回成功，但不提交。询问之后的所有事务操作都记log，以便之后的恢复。&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;提交阶段（执行）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;如果协调者收到了失败或者超时，就直接给每个参与者发送回滚消息，否则就发送提交（commit）消息。
参与者如果收到提交消息，就提交事务，并释放资源和锁。如果收到回滚消息，就回滚事务，并释放资源和锁。&lt;/p&gt;
&lt;p&gt;二阶段提交协议的缺点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;同步阻塞，从投票开始到提交完成的这段时间，所用的资源被锁死&lt;/li&gt;
&lt;li&gt;单点故障，如果协调者故障了，就会一直阻塞&lt;/li&gt;
&lt;li&gt;数据不一致，第二阶段发送commit时可能部分节点因为故障收不到，导致只有一部分执行了commit。
等&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;之后有提出三阶段协议3PC，对二阶段协议进行了改进，然而由于增加了通信成本，实际用的并不多，就不细讲。&lt;/p&gt;
&lt;h3 id=&#34;tcctry-confirm-cancel&#34;&gt;TCC（Try-Confirm-Cancel）&lt;/h3&gt;
&lt;p&gt;TCC是一个业务层面的协议，需要在业务代码中编写，包含了预留、确认或撤销三个阶段。
核心思想是针对每个操作都要注册一个对其对应的确认操作和补偿操作。
首先是try阶段，先通知各个节点的将要进行的操作。
如果try阶段的回复都是ok，就执行确认操作，通知各个节点要执行操作；如果try阶段有错误或者超时，就执行撤销操作，&lt;/p&gt;
&lt;p&gt;可以说ACID是CAP一致性的边界，也就是最强的一致性。&lt;/p&gt;
&lt;h3 id=&#34;base&#34;&gt;BASE&lt;/h3&gt;
&lt;p&gt;BASE则是追求可用性，是CAP中AP的拓展。&lt;/p&gt;
&lt;p&gt;BASE的核心是基本可用（Basically Available）和最终一致性（Eventually Consistent）&lt;/p&gt;
&lt;p&gt;比如遇到峰值，可以用四板斧解决：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;流量削峰，将访问请求错开，比如多个秒杀商品放在不同的时间开始&lt;/li&gt;
&lt;li&gt;延迟请求，比如买火车票抢票的时候等一段时间系统才处理&lt;/li&gt;
&lt;li&gt;体验降级，比如先用小图片代替原始图片&lt;/li&gt;
&lt;li&gt;过载保护，请求放入队列中排队处理，超时了就直接拒绝，队列满了之后就清除一定的请求。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;目的是在基本可用性上保持妥协，谁也不想牺牲这些服务，但是为了可用性必须这样。&lt;/p&gt;
&lt;p&gt;最终一致性是指所有数据副本在经过一段时间的同步之后，最终能保持一致性。
显示生活中，除了金融等对一致性要求极高的领域，它们会使用强一致性。绝大部分互联网系统都采用最终一致性。&lt;/p&gt;
&lt;p&gt;实现最终一致性的方式用的多的有以下几种：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;读时修复，查询数据的时候如果检测到不同的数据，系统自动修复&lt;/li&gt;
&lt;li&gt;写时修复，写失败的时候先将数据缓存下来，之后定时重传&lt;/li&gt;
&lt;li&gt;异步修复，最常用，通过定时对账来检测副本数据的一致性并修复&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;然而异步修复和读时修复的开销比较大，需要进行一致性对比，而写时修复的开销低。&lt;/p&gt;
&lt;p&gt;如果要设计分布式数据库的一致性的时候，可以采用自定义写一致级别（All、Quorum、One、All）来让用户自主选择业务所适合的一致性级别&lt;/p&gt;
&lt;p&gt;BASE通过牺牲强一致性来获得高可用性。&lt;/p&gt;
&lt;h2 id=&#34;cap&#34;&gt;CAP&lt;/h2&gt;
&lt;p&gt;分布式系统的最大难点之一就是维护各个节点之间的数据状态一致性。
需要通过数据库或者分布式缓存来维护数据的一致性。&lt;/p&gt;
&lt;p&gt;CAP是三个缩写的组合：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;C（Consistency）：数据一致性，分布式系统中，同一份数据可能存在于多个实例中，其中一份的修改必须同步到所有它的备份中。也就是说每一次必然能读到最新写入的数据，或者返回错误。&lt;/li&gt;
&lt;li&gt;A（Availability）：服务可用性，服务在接收到客户端请求时必须要给出响应。在高并发和部分结点宕机的情况下依然可以响应。也就是每一次必然会返回结果，但是不保证是最新的正确的。&lt;/li&gt;
&lt;li&gt;P（Partition tolerance）：分区容忍性，由于网络的不可靠性，位于不同网络分区的结点可能会通信失败，如果能容忍这种情况，那么就满足分区容忍性。也就是说出现问题能够容忍。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;一个分布式系统不可能同时满足这三个基本需求，最多只能满足两项。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;满足CA&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;也就是必然一致而且能够返回正确结果，这样是不存在的，其实就是单Server，不叫分布式系统。&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;满足CP&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;牺牲A，只要系统中有一个Server没更新完，就返回错误，否则就返回正确的最新的值。&lt;/p&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;满足AP&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;牺牲C，也就是只要Server接收到请求就返回目前的值，但是不能保证一定是最新的正确的值。&lt;/p&gt;
&lt;p&gt;分布式系统必须满足分区容忍性，也就是只能从A和P中进行取舍，数据一致性和服务可用性只能满足一个。当然实际情况不可能只顾一个而完全放弃另一个，而是在主要关心一个的前提下尽量满足另一个。&lt;/p&gt;
&lt;p&gt;比较成熟的服务注册与发现有以下几个：Consul、Etcd、Zookeeper、Eureka&lt;/p&gt;
&lt;p&gt;其中Consul、Etcd、Zookeeper满足了CP，而Eureka满足了AP。&lt;/p&gt;
&lt;h2 id=&#34;一致化模型consistency-model&#34;&gt;一致化模型Consistency Model&lt;/h2&gt;
&lt;p&gt;对Consistency的不同程度的要求也衍生出了多种不同的等级模型。根据不同的情况采取不同的模型。&lt;/p&gt;
&lt;p&gt;假设有一场球赛，记分员负责将分数写入主Server，然后会将操作复制到各个replica server，读取分数的话可能是任意一个server。&lt;/p&gt;
&lt;p&gt;k=0,1分别代表主队和客队，如果主队得了一分，记分员操作是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;v = get(k)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;set(k, v+1)&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1640193245/cap-2.png&#34; alt=&#34;cap-2&#34;&gt;&lt;/p&gt;
&lt;p&gt;假设目前比分是2:5&lt;/p&gt;
&lt;h3 id=&#34;strong-consistency&#34;&gt;Strong Consistency&lt;/h3&gt;
&lt;p&gt;对于任何一个人，读到的一定是最新的&lt;/p&gt;
&lt;h3 id=&#34;eventual-consistency&#34;&gt;Eventual Consistency&lt;/h3&gt;
&lt;p&gt;只把结果给其他Server，只能保证最后的时刻会更新到正确的最终值，但是之前读到任何小于结果的得分都有可能，甚至是完全没出现过的得分，比如2:0&lt;/p&gt;
&lt;h3 id=&#34;consistent-prefix&#34;&gt;Consistent Prefix&lt;/h3&gt;
&lt;p&gt;连同操作一起给其他Server，从而保证读到的一定是比赛中的某个比分，历史发生过。&lt;/p&gt;
&lt;h3 id=&#34;bounded-staleness&#34;&gt;Bounded Staleness&lt;/h3&gt;
&lt;p&gt;保证读到的一定是t以内的结果。Bounded=0则为Strong Consistency。Bounded=无穷则为Eventual Consistency。&lt;/p&gt;
&lt;h3 id=&#34;monotonic-reads&#34;&gt;Monotonic Reads&lt;/h3&gt;
&lt;p&gt;可能返回任何结果，但是接下来会持续从同一个replica server中读取，保证每一次都至少会比之前的值新。&lt;/p&gt;
&lt;h3 id=&#34;read-my-writes&#34;&gt;Read My Writes&lt;/h3&gt;
&lt;p&gt;如果某个client对Server进行了set操作，那么之后的get必然是set的值。&lt;/p&gt;
&lt;p&gt;不同的角色，要求的系统模型不一样。
记分员：只有他会写入系统，用Read My Writes
裁判：只能Strong Consistency
报分员：保证是历史正确比分，然后每一次至少比上次新，Consistent Prefix+Monotonic Reads
记者：Bounded Staleness就可以，多等点时间
观众：无所谓，Eventual Consistency都行&lt;/p&gt;
&lt;p&gt;银行的系统必然是Strong Consistency，只能最新。而DNS只要是Eventual Consistency就可以，因为需要快速返回结果，不是最新的也可以接受。&lt;/p&gt;
&lt;h2 id=&#34;quorum-system&#34;&gt;Quorum System&lt;/h2&gt;
&lt;p&gt;Quorum System随着Amazon与2007年发表的&lt;code&gt;Dynamo: Amazon’s Highly Available Key-value Store&lt;/code&gt;论文而提出，这篇论文是NoSQL的代表之作。DynamoDB是一个NoSQL数据库，支持键值和文档数据结构，具有Strongly Consistent和Eventually Consistent。&lt;/p&gt;
&lt;p&gt;之前都是往一个Leader Server里写入，然后复制到replica server里，而我们更需要的是写入的时候任何一个Server都可以，读取的时候也是任何一个Server都可以。
也就是Leaderless Replication&lt;/p&gt;
&lt;p&gt;但是这样做的问题在于，如果两个写入操作的时间比较靠近，很可能出现对于不同的服务器而言，指令到达的时刻顺序不一致，从而错误。&lt;/p&gt;
&lt;p&gt;一种方法是每次写入都加锁，也就是去抢每个replicas server的锁，直到都写完了才释放所有的锁，让下一个写入进入。但是这样的话过于严格，效率低下。&lt;/p&gt;
&lt;p&gt;把条件放松一些。
对于写入操作，当一个client取得w个replicas的Lock才被允许写入。
取得R个replicas的Lock才被允许读。
写入时搭配timestamp。&lt;/p&gt;
&lt;p&gt;只要W+W&amp;gt;N就可以防止同时写的发生，保证不会出现最新的值不明确的情况。这个不解释。&lt;/p&gt;
&lt;p&gt;只要W+R&amp;gt;N就可以防止同时读写的发生，保证不会出现读取的值不是最新值的情况。配合timestamp之后，根据抽屉理论，读的时候至少会读到一台最新的server，从而根据timestamp可以找出它。&lt;/p&gt;
&lt;p&gt;通过Quorum System，可以不必设置primary server、replica server的形式，直接对任一server进行读写，仍然能保证Strong Consistency。&lt;/p&gt;
&lt;p&gt;这样的话，通过使用DynamoDB，Amazon会在世界各个地方的数据中心存放你的数据，进行备份，也能通过local replica进行加速。&lt;/p&gt;
&lt;h3 id=&#34;read-repair和anti-entropy&#34;&gt;Read-Repair和Anti-Entropy&lt;/h3&gt;
&lt;p&gt;如果说有几个节点瘫痪了，导致每个都无法拿到超过一半的锁。&lt;/p&gt;
&lt;p&gt;Read-Repair就是在读取的时候不仅通过timestamp拿到最新的结果，还顺便将最新的结果写回其他的server里去。这种适用于频繁读取的情况。&lt;/p&gt;
&lt;p&gt;另一个方法是Anti-Entropy，也就是单独创建一个process，通过检查replica的版本并将所有server都同步成最新的。适用于读取不频繁的情况。&lt;/p&gt;
&lt;h3 id=&#34;hinted-handoff&#34;&gt;Hinted Handoff&lt;/h3&gt;
&lt;p&gt;故障的server恢复之后，系统会写回这个server，这种做法叫Hinted Handoff。
写失败的请求会缓存到本地硬盘上，并周期性的尝试重传。&lt;/p&gt;
&lt;h3 id=&#34;quorum-nwr&#34;&gt;Quorum NWR&lt;/h3&gt;
&lt;p&gt;对于AP系统，可以保证最终一致性但是无法保证强一致性。如果想满足强一致性，可以借助Quorum NWR。&lt;/p&gt;
&lt;p&gt;Quorum NWR可以根据业务的特点，调整一致性级别。&lt;/p&gt;
&lt;p&gt;三个要素：N、W、R&lt;/p&gt;
&lt;p&gt;N：复制因子，也就是一个集群中，数据有多少个副本，当然不同的数据可能有不同的副本数
W：写一致性级别，成功完成W个副本更新，才完成写操作
R：读一致性级别，读一个数据对象需要读R个副本&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;W + R &amp;gt; N：不会出现并行读写，一定能读到最新值&lt;/strong&gt;
W + W &amp;gt; N：不会出现并行写
W + W &amp;lt;= N：可能出现不一致
W + R &amp;lt;= N：可能会读不到最新的值
R + R &amp;gt; N：&lt;/p&gt;
&lt;h2 id=&#34;分布式系统的时间&#34;&gt;分布式系统的时间&lt;/h2&gt;
&lt;p&gt;通常会采用W+W&amp;lt;=N来尽量保证Availablity，这种情况下如何规避并行写导致的不一致呢。&lt;/p&gt;
&lt;p&gt;一个方式就是要了解两个指令在发出时的先后顺序，而不是到达时的顺序，从而保证一致性。看起来通过发出信号时就附加timestamp可以解决问题，看起来每台机器的时间是一样的，然而实际上并不一定。&lt;/p&gt;
&lt;p&gt;由于每台机器自身的时间并不一定准确，甚至可能会出现接受到信息的timestamp比机器当前时间还要晚的情况（收到来自“未来”的消息），这样就很离谱，明显不合理。&lt;/p&gt;
&lt;h3 id=&#34;lamport-logical-clock&#34;&gt;Lamport Logical Clock&lt;/h3&gt;
&lt;p&gt;在消息里夹带一个timestamp，但是在传递的时候，每个结点接受到timestamp后，会比较自身时间与timestamp的大小，然后选择最大的那个置为新的timestamp，从而保证一定递增。收到的消息的timestamp比本身时间还大的话，就将自己的时间改为timestamp的时间。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;每个参与者最开始都保存一个timestamp=0&lt;/li&gt;
&lt;li&gt;如果在本地发生，timestamp+1&lt;/li&gt;
&lt;li&gt;如果传递这个消息，timestamp+1，然后传递时附带该timestamp&lt;/li&gt;
&lt;li&gt;如果接受这个消息，timestamp = Max(本地Clock, 消息timestamp) + 1&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;（Lamport发明了Latex）&lt;/p&gt;
&lt;h3 id=&#34;vector-clock&#34;&gt;Vector Clock&lt;/h3&gt;
&lt;p&gt;Lamport timestamp会显示两个先后的事件有因果关系，但是实际逻辑上并不一定，可能只是同时平行发生。&lt;/p&gt;
&lt;p&gt;对于N个Node的系统，Vector Clock让每个Node都存储一个长度为N的timestamp vector&lt;/p&gt;
&lt;p&gt;对于$Node_i$而言，存储$Vector_i = {t_0, t_1, ..., t_n}$&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;初始化每个Node的vector中的每个元素都为0&lt;/li&gt;
&lt;li&gt;$Node_i$发生一个事件，$V_i[t_i]+1$&lt;/li&gt;
&lt;li&gt;$Node_i$发生一个发送事件，$V_i[t_i]+1$，并夹带这个vector&lt;/li&gt;
&lt;li&gt;$Node_j$发生一个接受事件，$V_j[t_i] = V_i[t_i]$、$V_j[t_j] = Max(V_j[t_j],V_i[t_i]) + 1$&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;参考：https://ithelp.ithome.com.tw/users/20121042/ironman/2792&lt;/p&gt;
</content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://yichengme.site/categories/%E6%8A%80%E6%9C%AF/" term="技术" label="技术" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://yichengme.site/tags/%E5%88%86%E5%B8%83%E5%BC%8F/" term="分布式" label="分布式" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">浅谈深度学习模型的可解释性</title>
            <link rel="alternate" type="text/html" href="https://yichengme.site/posts/talk-about-model-interpreter/" />
            <id>https://yichengme.site/posts/talk-about-model-interpreter/</id>
            <updated>2022-02-27T15:47:22&#43;08:00</updated>
            <published>2021-11-01T23:41:33&#43;08:00</published>
            <author>
                    <name>王毅诚</name>
                    <uri>https://yichengme.site/</uri>
                    <email>engine74396@gmail.com</email>
                    </author>
            <rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">前言 可解释性是指人类能够理解决策原因的程度。模型一方面需要有一定的预测能力，另外还应当让人类可以理解，为什么模型会根据这些数据作出最后的判断，也就是中间的决策过……</summary>
            
                <content type="html">&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;
&lt;p&gt;可解释性是指人类能够理解决策原因的程度。模型一方面需要有一定的预测能力，另外还应当让人类可以理解，为什么模型会根据这些数据作出最后的判断，也就是中间的决策过程能够被解释。&lt;/p&gt;
&lt;p&gt;模型的可解释性一直以来是一个热点且重要的研究方向。&lt;/p&gt;
&lt;p&gt;线性回归非常好解释，一旦写出公式，人类很容易理解，但是只能表示线性关系，预测能力不足。另一边的极端是深度神经网络，它们可以在数据和预测之间建立非常深的非线性抽象联系，预测能力很好，但是中间过程几乎是黑箱，人类无法理解模型决策的依据。&lt;/p&gt;
&lt;p&gt;所以大部分深度学习模型只能用评价指标来评价模型预测能力的好坏，而很少讨论其可解释性。&lt;/p&gt;
&lt;h2 id=&#34;为什么要做可解释性分析&#34;&gt;为什么要做可解释性分析&lt;/h2&gt;
&lt;h3 id=&#34;如果没有可解释性在很多领域的实用性会受到限制&#34;&gt;如果没有可解释性，在很多领域的实用性会受到限制&lt;/h3&gt;
&lt;p&gt;在很多实际领域，如军工、医学、法律、无人驾驶，即使模型预测能力再好，没有可解释性依然不会使用，如果用户不信任模型或预测，他们就不会使用它，所以模型的中间过程不能是黑箱，中间的过程必须用合理的理由解释清楚。。&lt;/p&gt;
&lt;p&gt;欧盟的《通用数据保护条例》（GDPR）法律要求对算法的决策过程进行解释，以使其在用于患者护理之前透明&lt;/p&gt;
&lt;p&gt;绝大部分的模型建立者的说法都是：
“我的模型有很好的预测能力”&lt;/p&gt;
&lt;p&gt;但是模型使用者的问题往往是：
“我为什么要相信你的模型？”&lt;/p&gt;
&lt;h3 id=&#34;揭露错误过程&#34;&gt;揭露错误过程&lt;/h3&gt;
&lt;p&gt;有可能在数据集上的表现很好，但本身模型的预测有问题，如果没有可解释性可能难以看出，比如北极熊和棕熊的分类，可能模型实际上只是识别了背景是否有冰雪，可能模型本身的预测和实际需要的并没有什么联系。如果有可解释性，就可以删掉一些没有意义的特征从而改进模型。&lt;/p&gt;
&lt;h3 id=&#34;3揭示新的成像表示物&#34;&gt;3揭示新的成像表示物&lt;/h3&gt;
&lt;p&gt;可解释性方法还可以揭示新的成像生物标志物，从而了解深度神经网络的具体情况。&lt;/p&gt;
&lt;h2 id=&#34;对可解释性的理解&#34;&gt;对可解释性的理解&lt;/h2&gt;
&lt;p&gt;可解释性指的是任何试图回答“模型为什么做出这种预测”问题的技术。我们想要弄清楚以下几个问题：&lt;/p&gt;
&lt;p&gt;what？是什么驱动了模型的判断，公平性
why？为什么模型会给出这个预测结果，可靠性
how？我们如何信任模型的预测，透明度&lt;/p&gt;
&lt;h2 id=&#34;可解释性方法的分类&#34;&gt;可解释性方法的分类&lt;/h2&gt;
&lt;p&gt;可解释性方法可以分为Pre-Model、In-Model和Post-Model。&lt;/p&gt;
&lt;p&gt;其中Pre-Model指的是解释独立于模型本身，只能应用于数据，比如PCA、t-SNE、聚类等。&lt;/p&gt;
&lt;p&gt;In-Model指的是模型本身本质上可解释（一般是一些统计学、机器学习模型），有数理的推导过程，比如模型本身有因果性、外在约束以及自带特征权重等。比如线性回归、逻辑回归、决策树、SVM等。&lt;/p&gt;
&lt;p&gt;Post-Model又称为Post hoc，指的是模型本身是黑盒，但是训练后应用可解释性方法（特征重要性、部分依赖性图）等，从而使得模型可以被解释。&lt;/p&gt;
&lt;h2 id=&#34;通用的可解释性方法&#34;&gt;通用的可解释性方法&lt;/h2&gt;
&lt;h3 id=&#34;特征重要性&#34;&gt;特征重要性&lt;/h3&gt;
&lt;p&gt;给出不同特征的重要性权重&lt;/p&gt;
&lt;p&gt;特征重要性可以告诉你哪些特征是最重要的或者是不重要的。&lt;/p&gt;
&lt;h3 id=&#34;部分依赖图&#34;&gt;部分依赖图&lt;/h3&gt;
&lt;p&gt;PDP或者PD图&lt;/p&gt;
&lt;p&gt;可以展示一个特征如何影响预测，显示特征对预测结果的边际效应。
partial dependence图可以告诉你一个特征是如何影响预测的。&lt;/p&gt;
&lt;h3 id=&#34;shap&#34;&gt;SHAP&lt;/h3&gt;
&lt;p&gt;可以讨论各个特征对预测结果的贡献。
SHAP将预测值解释为每个输入特征的归因值之和，相比于特征重要性，SHAP更能清楚的反映每个样本中各个特征的影响力，具有样本特异性，也能反馈出作用的正负性。
一个特征的shapley value是该特征在所有的特征序列中的平均边际贡献。&lt;/p&gt;
&lt;h3 id=&#34;lime&#34;&gt;LIME&lt;/h3&gt;
&lt;p&gt;Local Interpretable Model-Agnostic Explanations（LIME）与模型无关，可以用于任何机器学习模型，通过扰动样本输入量化预测结果的变化来理解模型。&lt;/p&gt;
&lt;p&gt;有时候可能不是自己的模型，无法更改，如果还想要可解释性，可以考虑LIME。即使对模型内部完全不清楚也能解释行为。&lt;/p&gt;
&lt;p&gt;LIME的核心思想是：对一个复杂的分类模型(黑盒)，在局部拟合出一个简单的可解释模型，例如线性模型、决策树等等。&lt;/p&gt;
&lt;p&gt;将图像划分为多个超像素块（划分为像素太小了）每个像素块进行扰动，看对结果的影响。从而找出影响程度最大的几个超像素&lt;/p&gt;
&lt;p&gt;不过缺点就是比较慢，因为相当于每次改变还要过一次模型&lt;/p&gt;
&lt;h2 id=&#34;深度学习医学图像的可解释性&#34;&gt;深度学习医学图像的可解释性&lt;/h2&gt;
&lt;h3 id=&#34;概念学习模型-concept-learning-models&#34;&gt;概念学习模型 Concept Learning Models&lt;/h3&gt;
&lt;p&gt;放射学家无法直接理解图像的深层特征，所以先从图像中预测高级语义特征（如临床概念），再使用这些可解释的概念进行最终预测。&lt;/p&gt;
&lt;p&gt;不过缺点就是需要手动注释这些标签。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1644560615/dl-interpret-2.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;基于案例的模型-case-based-models&#34;&gt;基于案例的模型 Case-Based Models&lt;/h3&gt;
&lt;p&gt;基于案例的模型适用于分类任务，它通过比较从图像中提取的特征和类别特异性原型。原型分类是可解释的，因为预测是通过输入和原型特征之间的相似性程度来判断的。&lt;/p&gt;
&lt;p&gt;局限：容易受到噪声和压缩的影响，且难以训练。&lt;/p&gt;
&lt;h3 id=&#34;反事实解释-counterfactual-explanation&#34;&gt;反事实解释 Counterfactual Explanation&lt;/h3&gt;
&lt;p&gt;通过对原始图像施加最小扰动来最大程度地改变模型预测结果，从而能够发现关键区域和改变预测所需的重要变化。&lt;/p&gt;
&lt;p&gt;反事实的图像基本是通过GANs或者扰动autoencoder的潜在空间来生成的。&lt;/p&gt;
&lt;p&gt;局限：生成图像的分辨率是有限的。&lt;/p&gt;
&lt;h3 id=&#34;概念因子-concept-attribution&#34;&gt;概念因子 Concept Attribution&lt;/h3&gt;
&lt;p&gt;全局的解释，可以量化深层概念或放射学特征对预测结果的影响。&lt;/p&gt;
&lt;p&gt;局限性：很难对深层的特征进行标注。&lt;/p&gt;
&lt;h3 id=&#34;语言描述-language-description&#34;&gt;语言描述 Language Description&lt;/h3&gt;
&lt;p&gt;在预测的同时增加文本描述提供解释，不过增加了很多注释成本。&lt;/p&gt;
&lt;p&gt;文本解释和预测一致&lt;/p&gt;
&lt;p&gt;局限：结构化诊断报告需要更多注释，在测试过程中重复训练句子。&lt;/p&gt;
&lt;h3 id=&#34;潜在空间解释-latent-space-interpretation&#34;&gt;潜在空间解释 Latent Space Interpretation&lt;/h3&gt;
&lt;p&gt;潜在空间用于揭示数据中与临床知识相关的显著变异因素。在二维中可视化高维潜在空间，以识别相似性和异常值。&lt;/p&gt;
&lt;p&gt;比如采用PCA、t-SNE等方式降维CNN的高维特征&lt;/p&gt;
&lt;p&gt;局限：将高维特征空间投影到二维时的信息丢失。潜在空间中的相似性并不总是转化为人类可解释特征方面的相似性。&lt;/p&gt;
&lt;h3 id=&#34;归因图-attribution-map&#34;&gt;归因图 Attribution Map&lt;/h3&gt;
&lt;p&gt;通过突出显示模型认为重要的输入图像区域，可以提供事后解释。
Attribution Map可以理解为描述区域重要程度的热力图，反映的是注意力，和原图尺寸是一样的。&lt;/p&gt;
&lt;p&gt;不过这种热力图反应的是作出贡献的程度，但是却没有反映如何为预测作出贡献。&lt;/p&gt;
&lt;p&gt;比如分层相关性传播分层相关性传播（LRP），通过评估相关性得分生成热图，一层层计算每个神经元的贡献大小&lt;/p&gt;
&lt;h4 id=&#34;camclass-activation-mapping&#34;&gt;CAM（Class Activation Mapping）&lt;/h4&gt;
&lt;p&gt;类激活映射（Class Activation Maps，CAM）在最后一个卷积层之后添加一个全局平均池层。然后将全局平均池层的输出线性组合以生成类预测。通过获取最后一个卷积层激活的加权和，获得每个类的CAM。不过使用CAM的网络不能有全连接层。&lt;/p&gt;
&lt;p&gt;接上GAP全局平均池化然后softmax，就可以获得每个class的热图&lt;/p&gt;
&lt;p&gt;GAP替换MLP，求每张特征图所有像素的均值。支持任意大小的输入。&lt;/p&gt;
&lt;p&gt;最后一层生成了和目标类别数量一致的特征图，经过GAP再经过softmax得到结果，这样就给每个特征图赋予了意义。&lt;/p&gt;
&lt;p&gt;每一个类别C、每个特征图k都有一个对应的权重$w^c_k$&lt;/p&gt;
&lt;p&gt;训练完后，对于每一个类别C，可以加权所有的特征图合成针对某个类别的热力图，从而看出重要的地方。&lt;/p&gt;
&lt;h4 id=&#34;grad-cam&#34;&gt;Grad-CAM&lt;/h4&gt;
&lt;p&gt;CAM的缺点在于，他需要修改原模型的结构，需要重新训练模型&lt;/p&gt;
&lt;p&gt;Grad-CAM和CAM的最大区别在于求权重$w^c_k$的过程，Grad-CAM通过梯度的全局平均来计算权重，数学推导和CAM的权重是等价的。&lt;/p&gt;
&lt;p&gt;第k个特征图针对类别C的权重：
$$
\alpha_{k}^{c}=\frac{1}{Z} \sum_{i} \sum_{j} \frac{\partial y^{c}}{\partial A_{i j}^{k}}
$$&lt;/p&gt;
&lt;p&gt;Z是特征图像素个数，$y^c$是对应类别的分数（softmax之前的值），$ A_{i j}^{k}$是第k个特征图的(i,j)位置的像素值，得到所有权重后，加权求和即可得到热力图：&lt;/p&gt;
&lt;p&gt;$$
L_{G r a d-C A M}^{c}=\operatorname{ReLU}\left(\sum_{k} \alpha_{k}^{c} A^{k}\right)
$$&lt;/p&gt;
&lt;p&gt;局限：没有提供相关区域如何对结果作出贡献，多个类可能高亮相同的区域。&lt;/p&gt;
&lt;h3 id=&#34;解剖先验-anatomical-prior&#34;&gt;解剖先验 Anatomical Prior&lt;/h3&gt;
&lt;p&gt;任务特定的结构信息被纳入网络的设计过程中。&lt;/p&gt;
&lt;p&gt;局限：可能需要专业的临床知识，但解剖学知识不能用于所有问题。&lt;/p&gt;
&lt;h3 id=&#34;内部网络表示-internal-network-representation&#34;&gt;内部网络表示 Internal Network Representation&lt;/h3&gt;
&lt;p&gt;将CNN中不同过滤器学习到的特征的可视化。&lt;/p&gt;
&lt;p&gt;局限：不同的过滤器学会识别的结构和模式在医学图像中很难解释。&lt;/p&gt;
&lt;h2 id=&#34;可解释性评估方式&#34;&gt;可解释性评估方式&lt;/h2&gt;
&lt;p&gt;分为基于应用的、基于人工的、基于功能的共三种&lt;/p&gt;
&lt;p&gt;参考：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Transparency of Deep Neural Networks for Medical Image Analysis Review of Interpretability Methods&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://zhuanlan.zhihu.com/p/258988892&#34;&gt;https://zhuanlan.zhihu.com/p/258988892&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://zhuanlan.zhihu.com/p/326586020&#34;&gt;https://zhuanlan.zhihu.com/p/326586020&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.jiqizhixin.com/articles/2019-10-30-9&#34;&gt;https://www.jiqizhixin.com/articles/2019-10-30-9&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://yichengme.site/categories/%E6%8A%80%E6%9C%AF/" term="技术" label="技术" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://yichengme.site/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/" term="深度学习" label="深度学习" />
                            
                        
                            
                            
                            
                                <category scheme="https://yichengme.site/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/" term="计算机视觉" label="计算机视觉" />
                            
                        
                            
                            
                            
                                <category scheme="https://yichengme.site/tags/%E5%8F%AF%E8%A7%A3%E9%87%8A%E6%80%A7/" term="可解释性" label="可解释性" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">Google三驾马车（三）—— Bigtable</title>
            <link rel="alternate" type="text/html" href="https://yichengme.site/posts/bigtable/" />
            <id>https://yichengme.site/posts/bigtable/</id>
            <updated>2022-02-27T15:21:55&#43;08:00</updated>
            <published>2021-10-27T00:21:18&#43;08:00</published>
            <author>
                    <name>王毅诚</name>
                    <uri>https://yichengme.site/</uri>
                    <email>engine74396@gmail.com</email>
                    </author>
            <rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">介绍 为什么需要Bigtable？ 需要一个集群支持海量的随机读写，需要支持到每秒百万级别的随机读写。在Bigtable没出之前，使用MySQL集群可以解决一些问题……</summary>
            
                <content type="html">&lt;h2 id=&#34;介绍&#34;&gt;介绍&lt;/h2&gt;
&lt;p&gt;为什么需要Bigtable？
需要一个集群支持海量的随机读写，需要支持到每秒百万级别的随机读写。在Bigtable没出之前，使用MySQL集群可以解决一些问题，然而一方面会放弃关系型数据库的很多特征，比如外键约束、跨行跨表的事务等。一方面在扩容的时候不得不翻倍扩容，非常浪费。缩减服务器也非常麻烦。另外，在每次故障恢复的时候也需要人工介入。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1640192906/bigtable-0.png&#34; alt=&#34;bigtable-0&#34;&gt;&lt;/p&gt;
&lt;p&gt;希望的伸缩性是可以随机增加或者去掉人任何数量的服务器，并且进行这些操作时不会使服务暂停。&lt;/p&gt;
&lt;p&gt;Bigtable建立在GFS的架构之上，是一个管理结构化数据的分布式存储系统，可以拓展到非常大的规模，比如跨越数千服务器的PB级别的数据。
Google已经将其用在了很多内部产品中，Bigtable为其提供了一套高性能的可灵活拓展的解决方案。&lt;/p&gt;
&lt;p&gt;在很多方面，Bigtable像是数据库，但相比于以往的系统，Bigtable提供了不一样的接口。它不支持完整的关系型数据模型。可以使用任意字符的行列名对数据进行索引，Bigtable将数据都视为未解释的字符串。&lt;/p&gt;
&lt;p&gt;当然Bigtable也有缺点，一个是放弃了关系模型，不支持SQL；一个是放弃了跨行的事务，只支持单行的事务模型。&lt;/p&gt;
&lt;p&gt;Bigtable的解决方法是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;将存储层搭建在GFS上，通过单Master调度多Tablets的形式，使得集群容易维护，伸缩性好&lt;/li&gt;
&lt;li&gt;通过MenTable+SSTable的底层文件格式，解决高速随机读写的问题&lt;/li&gt;
&lt;li&gt;通过Chubby分布式锁解决一致性的问题&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;数据模型&#34;&gt;数据模型&lt;/h2&gt;
&lt;p&gt;Bigtable是一个稀疏的、分布式的永久存储的多维排序map，这个map通过row key、column key和timestamp进行索引，每个值都是一个未解释的字符串。&lt;/p&gt;
&lt;p&gt;(row: string, column: string, time: int64) -&amp;gt; string&lt;/p&gt;
&lt;p&gt;下图是一个存储网页的table&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;row是url的倒转，比如www.google.com会存为com.google.www，这样的目的是前面的www大家都一样，而且子域名就会主域名靠一起。&lt;/li&gt;
&lt;li&gt;有多列，其中&lt;code&gt;contents:&lt;/code&gt;列存储网页html内容。&lt;code&gt;anchor:&lt;/code&gt;列存储指向这个页面的anchor文字，比如cnnsi.com和my.look.ca有指向www.cnn.com的anchor，就如下图所示存储。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1640192906/bigtable-1.png&#34; alt=&#34;bigtable-1&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;rows&#34;&gt;Rows&lt;/h3&gt;
&lt;p&gt;行key是表的主键，可以是任意字符串，最大为64kb，在单行的读写都是原子的。
由于读写总是通过行键，这样的数据库也叫做KV数据库。
Bigtable按行key对数据进行排序，行范围动态分区，每个行的范围被称为tablet，是分布式和负载均衡的单位。&lt;/p&gt;
&lt;h3 id=&#34;column-families-列族&#34;&gt;Column Families 列族&lt;/h3&gt;
&lt;p&gt;每一行的数据需要指定列族，每个列族下不需要指定列，每个数据都可以有自己的列，每一行的列可以不一样。这也就是为什么说Bigtable是稀疏的表：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1640192908/bigtable-2.png&#34; alt=&#34;bigtable-2&#34;&gt;&lt;/p&gt;
&lt;p&gt;列key被分组到了一个集合里，被称为column families，每个column families里的应当是相同类型。必须先创建column families，才能使用列key存储数据。
列key通过&lt;code&gt;family:qualifier&lt;/code&gt;命名。比如存储web的表可以用language当做family，另一种是可以用anchor来当做family，每个列key是一个anchor，qualifier是指向该url的网址，内容是链接文本。
访问控制和硬盘内存的记录都是在列family层级下进行的。
比如Bigtable的开源实现HBase，每一个列族的数据存在同一个HFile文件下。&lt;/p&gt;
&lt;h3 id=&#34;timestamp&#34;&gt;Timestamp&lt;/h3&gt;
&lt;p&gt;Bigtable的每个单元格可以包含相同数据的多个版本，不同的版本通过时间戳进行索引。Bigtable的时间戳是64位的整数。不同版本以递减的形式存储，以便可以首先读取最新版本。&lt;/p&gt;
&lt;p&gt;为了防止变得过于繁重，可以指定个数或过期时间，之前的版本被gc。&lt;/p&gt;
&lt;h2 id=&#34;api&#34;&gt;API&lt;/h2&gt;
&lt;p&gt;Bigtable的API包括创建、删除表和列族，以及修改簇、表、列族元数据等。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;9
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-C++&#34; data-lang=&#34;C++&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// Open the table
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Table&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;T&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;OpenOrDie&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;/bigtable/web/webtable&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;

&lt;span class=&#34;c1&#34;&gt;// Write a new anchor and delete an old anchor
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;RowMutation&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;r1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;T&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;com.cnn.www&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;r1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Set&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;anchor:www.c-span.org&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;CNN&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;r1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Delete&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;anchor:www.abc.com&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;Operation&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;op&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;Apply&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;op&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;r1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-C++&#34; data-lang=&#34;C++&#34;&gt;&lt;span class=&#34;n&#34;&gt;Scanner&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;scanner&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;T&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;ScanStream&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;stream&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;stream&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;scanner&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;FetchColumnFamily&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;anchor&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;stream&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;SetReturnAllVersions&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;scanner&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Lookup&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;com.cnn.www&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;stream&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Done&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;stream&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Next&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;())&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;n&#34;&gt;printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;%s %s %lld %s&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\n&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
  &lt;span class=&#34;n&#34;&gt;scanner&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;RowName&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(),&lt;/span&gt;
  &lt;span class=&#34;n&#34;&gt;stream&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ColumnName&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(),&lt;/span&gt;
  &lt;span class=&#34;n&#34;&gt;stream&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;MicroTimestamp&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(),&lt;/span&gt;
  &lt;span class=&#34;n&#34;&gt;stream&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Value&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;());&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h2 id=&#34;构建块&#34;&gt;构建块&lt;/h2&gt;
&lt;p&gt;Bigtable使用GFS存储日志和数据文件，&lt;code&gt;SSTable&lt;/code&gt;用于存储Bigtable数据，每个SSTable包含一个块序列（每个块64kb），并且SSTable可以被完全的映射到内存中，不需要接触磁盘就可以执行查找和扫描。&lt;/p&gt;
&lt;p&gt;Bigtable依赖于分布式锁Chubby，Chubby包含了5个副本，其中一个被选为master并提供request服务。我后面会专门再讲一下Chubby。&lt;/p&gt;
&lt;p&gt;Bigtable通过Chubby完成以下任务：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;确保每个时刻只有一个master&lt;/li&gt;
&lt;li&gt;存储Bigtable数据的引导位置&lt;/li&gt;
&lt;li&gt;存储Bigtable每个表的列族信息&lt;/li&gt;
&lt;li&gt;存储访问控制列表ACL&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;如果Chubby不可用，那么Bigtable也将不可用&lt;/p&gt;
&lt;h2 id=&#34;实现&#34;&gt;实现&lt;/h2&gt;
&lt;p&gt;Bigtable包含三个主要组件：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;链接到每个客户端的库&lt;/li&gt;
&lt;li&gt;一个master服务器&lt;/li&gt;
&lt;li&gt;多个tablet服务器&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;tablet可以动态的增加删除。&lt;/p&gt;
&lt;p&gt;master的职责：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;负责将tablet分配给tablet服务器&lt;/li&gt;
&lt;li&gt;检测tablet的添加和过期&lt;/li&gt;
&lt;li&gt;平衡Tablet server之间的负载&lt;/li&gt;
&lt;li&gt;对GFS的文件进行gc&lt;/li&gt;
&lt;li&gt;管理Table和列族的Schema变更&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;每个tablet服务器存储一组tablet（通常是10-1000个），&lt;/p&gt;
&lt;p&gt;Bigtable和Tablet Server都不进行数据的存储只负责在线业务，存储工作通过SSTable的数据格式写到GFS上。&lt;/p&gt;
&lt;h3 id=&#34;tablet位置&#34;&gt;Tablet位置&lt;/h3&gt;
&lt;p&gt;通过B+树存储tablet的位置&lt;/p&gt;
&lt;p&gt;定义了一张特殊的表Root tablet专门存放元数据，这个分区不会分裂，存的是元数据里其他Tablets的位置。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1640192904/bigtable-5.jpg&#34; alt=&#34;bigtable-5&#34;&gt;&lt;/p&gt;
&lt;p&gt;第一级存储在Chubby的文件，包含root tablet的位置，root包含metadata tablets，包含了其他所有tablet的位置。tablet不做分割，确保不超过三层。&lt;/p&gt;
&lt;p&gt;举个例子，客户端查询ECOMMERCE_ORDERS业务表行键是A20210101RST的某个记录，客户端查询的具体操作：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1640192906/bigtable-6.png&#34; alt=&#34;bigtable-6&#34;&gt;&lt;/p&gt;
&lt;p&gt;也就是说在具体查找数据之前需要三次网络请求来获得数据的具体位置。一般前几次的查询也会缓存起来，以减少请求次数。&lt;/p&gt;
&lt;p&gt;三层结构可以让Bigtable拓展到足够大，tablet大小限制为128MB，每条记录大约1KB，可以存$2^{34}$个Tablet，也就是160亿个Tablet。&lt;/p&gt;
&lt;p&gt;客户端不需要经过master，让设计更加高可用&lt;/p&gt;
&lt;h3 id=&#34;动态分区&#34;&gt;动态分区&lt;/h3&gt;
&lt;p&gt;Bigtable采用动态区间分区，通过自动去split的方式动态分区。
好比是往箱子里放书，按照书名的字母顺序，一旦箱子装满，就中间一分为二，将下面一半放到一个新的空箱子里去。
如果两个相邻的箱子都很空，就可以将其合并。
&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1640192909/bigtable-4.png&#34; alt=&#34;bigtable-4&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;sstable底层结构&#34;&gt;SSTable底层结构&lt;/h2&gt;
&lt;p&gt;Bigtable的写入数据的过程：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;tablet server先做数据验证，以及权限验证&lt;/li&gt;
&lt;li&gt;如果合法，就以追加写的形式顺序写到GFS&lt;/li&gt;
&lt;li&gt;写入成功后还会写到一张内存表MenTable中&lt;/li&gt;
&lt;li&gt;写入的数据快要超过阈值时，会将内存的MemTable冻结，创建一个新的MemTable，被冻结的MemTable会被转换为SSTable写入到GFS，然后从内存中释放掉。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Major Compaction机制，对SSTable进行合并，把数据压实在一起，比如只留下时间戳最近的三个版本的数据。
读取数据的时候，读取的是MemTable和SSTable的合并在一起的视图。
也就是说并没有直接的修改和删除操作，一旦写入就是不可变的，写入的是数据的一个新版本，后台会定时gc，通过合并SSTable来清楚过期和被删除的数据。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1640192906/bigtable-7.png&#34; alt=&#34;bigtable-7&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;p&gt;Bigtable包括四个组件：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;负责存储数据的GFS&lt;/li&gt;
&lt;li&gt;负责作为分布式锁和目录服务的Chubby&lt;/li&gt;
&lt;li&gt;复杂提供在线服务的Tablet Server&lt;/li&gt;
&lt;li&gt;复杂调度Tablet和调整负载的Master&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1640192908/bigtable-8.png&#34; alt=&#34;bigtable-8&#34;&gt;&lt;/p&gt;
</content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://yichengme.site/categories/%E6%8A%80%E6%9C%AF/" term="技术" label="技术" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://yichengme.site/tags/bigtable/" term="Bigtable" label="Bigtable" />
                            
                        
                            
                            
                            
                                <category scheme="https://yichengme.site/tags/%E5%88%86%E5%B8%83%E5%BC%8F/" term="分布式" label="分布式" />
                            
                        
                            
                            
                            
                                <category scheme="https://yichengme.site/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/" term="大数据" label="大数据" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">Google三驾马车（二）—— MapReduce</title>
            <link rel="alternate" type="text/html" href="https://yichengme.site/posts/mapreduce/" />
            <id>https://yichengme.site/posts/mapreduce/</id>
            <updated>2022-02-27T15:21:55&#43;08:00</updated>
            <published>2021-10-18T20:21:18&#43;08:00</published>
            <author>
                    <name>王毅诚</name>
                    <uri>https://yichengme.site/</uri>
                    <email>engine74396@gmail.com</email>
                    </author>
            <rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">介绍 MapReduce是一个用于处理和生成大型数据集的编程模型和相关实现，它是一个分布式模型，通过一个Map函数将k/v对生存一组中间态的k/v对，然后通过一个……</summary>
            
                <content type="html">&lt;h2 id=&#34;介绍&#34;&gt;介绍&lt;/h2&gt;
&lt;p&gt;MapReduce是一个用于处理和生成大型数据集的编程模型和相关实现，它是一个分布式模型，通过一个Map函数将k/v对生存一组中间态的k/v对，然后通过一个reduce函数将所有的中间态k/v对进行聚合。
MapReduce运行在一个大型的商用机器集群上，比如可以在数千台机器上处理大量TB级别的数据。
实际上Google早已将其用于实际的任务，每天有超过1000个MapReduce任务在谷歌的集群上运行。&lt;/p&gt;
&lt;p&gt;面对百亿级别的爬虫数据、日志文件等，常规方法不可能做到时效性，只能采用分布式系统进行并行计算。&lt;/p&gt;
&lt;h2 id=&#34;编程模型&#34;&gt;编程模型&lt;/h2&gt;
&lt;p&gt;输入是一系列k/v对的set，输出也是一系列k/v对的set&lt;/p&gt;
&lt;p&gt;用户需要编写Map和Reduce这两个函数，其中Map函数通过输入pair来产生中间过程的k/v对
接下来会将Key为I的中间值传递给对应处理Key I的Reduce函数
Reduce函数接受一系列的Key为I的值，然后merge在一起，每次只有0或1
具体的见下面的例子。&lt;/p&gt;
&lt;h3 id=&#34;例子&#34;&gt;例子&lt;/h3&gt;
&lt;p&gt;输入文件首先分块，
需要一个Map函数，每个输入文件输入Map进行处理，每个都是并行的，产生对应的输出，输出是一个list形式的Key/Value的键值对。&lt;/p&gt;
&lt;p&gt;假设我们的功能是读取字符出现的次数。
假设输入为&amp;quot;abbac&amp;quot;，被拆成了三个文件，总共也就这三个Key。分别是&amp;quot;ab&amp;quot;,&amp;quot;b&amp;quot;,&amp;quot;ac&amp;quot;，并行输入进Map，三个输出分别为：
(a,1), (b,1)
(b,1)
(a,1), (c,1)&lt;/p&gt;
&lt;p&gt;然后进行reduce操作，对于每个Key，会传入reduce函数进行汇总，去统计每个Key的出现个数。这也是并行的。&lt;/p&gt;
&lt;p&gt;那么经过reduce操作之后，输出为：
(a, 2)
(b, 2)
(c, 1)&lt;/p&gt;
&lt;p&gt;完整的Job由一系列的MapTask和一系列的reduceTask组成。&lt;/p&gt;
&lt;p&gt;下面来说说对于统计字母的功能下，Map和Reduce这两个函数的结构：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-C++&#34; data-lang=&#34;C++&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// Map函数，k指明文件，v是文件内容
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Map&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;k&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;v&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;){&lt;/span&gt;
  &lt;span class=&#34;n&#34;&gt;split&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;v&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;to&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;words&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
  &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;each&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;word&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;w&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;emit&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;w&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;1&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
  &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-C++&#34; data-lang=&#34;C++&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// reduce函数，k是这个字母，v是包含这个字母的map数量
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;reduce&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;k&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;v&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;n&#34;&gt;emit&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;len&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;v&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;MapReduc和GFS都运行在一起，在并行进Map的时候，实际上避免了网络传输，中控通过某些方式能够知道该文件存在哪台主机里，然后在该主机调用Map本地操作，从而减少带宽传输限制。后面reduce只能通过网络。&lt;/p&gt;
&lt;p&gt;最开始是按行存储，然后按列存储，这个过程叫Shuffle，从Map服务器到Reduce服务器，这一过程很消耗网络。&lt;/p&gt;
&lt;h3 id=&#34;类型&#34;&gt;类型&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;map&lt;/code&gt;函数 输入是&lt;code&gt;(k1, v1)&lt;/code&gt;，输出是&lt;code&gt;list(k2, v2)&lt;/code&gt;
&lt;code&gt;reduce&lt;/code&gt;函数 输入是&lt;code&gt;(k2, list(v2))&lt;/code&gt;，输出是&lt;code&gt;list(v2)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;以统计词频为例，这里map的输入是(filename, fileContent)，输出是对于每一个单词为key的k/v列表，比如[&amp;quot;Apple&amp;quot;: 1, &amp;quot;Banana&amp;quot;: 1,...]。
这里reduce的输入就是一个单独单词的一系列值，比如&lt;code&gt;&amp;quot;Apple&amp;quot;, [1, 1, 1,...]&lt;/code&gt;，然后输出是该单词的词频。&lt;/p&gt;
&lt;h3 id=&#34;更多的例子&#34;&gt;更多的例子&lt;/h3&gt;
&lt;p&gt;除此之外还有很多适用于MapReduce的很好的例子。&lt;/p&gt;
&lt;h2 id=&#34;实现&#34;&gt;实现&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1640192780/mapreduce-1.png&#34; alt=&#34;mapreduce-1&#34;&gt;&lt;/p&gt;
&lt;p&gt;分割输入数据，分成M个子集，被调用分布到多台机器上并行处理。之后分割中间key形成R个片（比如通过&lt;code&gt;hash(key) mod R&lt;/code&gt;），reduce调用分布到各个机器上。&lt;/p&gt;
&lt;p&gt;具体步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;分割输入文件为M个片，每个片的大小约16-64M&lt;/li&gt;
&lt;li&gt;一个master，和多个worker，有M个map任务和R个reduce任务将被分配，管理者的一个任务是分配map或者reduce任务给一个空闲的worker&lt;/li&gt;
&lt;li&gt;被分配了map任务的worker需要做的是读取输入片的内容，分析出k/v对，传递给用户自定义的map函数，产生的中间k/v对缓存在内存中。&lt;/li&gt;
&lt;li&gt;缓存在内存中的k/v对通过分割函数写入R个区域，本地的缓存对的位置传送给master，然后master把这些位置传送给reduce worker。&lt;/li&gt;
&lt;li&gt;reduce worker通过远程调用来从map worker的磁盘上读取缓存的内容，reduce worker通过排序使得具有相同key的内容聚集在一起。如果中间数据比内存还大，就需要外排序。&lt;/li&gt;
&lt;li&gt;reduce worker迭代排过序的中间数据，对于每一个唯一的key，把key和相关的value传递给reduce函数，reduce函数的输出被添加到最终的输出文件中&lt;/li&gt;
&lt;li&gt;所有的map和reduce都完成之后，管理者唤醒用户程序，用户程序的MapReduce调用返回到用户代码&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;master的数据结构&#34;&gt;Master的数据结构&lt;/h3&gt;
&lt;p&gt;master首先会存储每个map任务和reduce任务的状态（空闲、进行中、完成）以及工作机器的标识。
master还会存储由map产生的中间文件的区域和大小，然后传给reduce的worker&lt;/p&gt;
&lt;h3 id=&#34;容错&#34;&gt;容错&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;worker故障&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;master会定期ping每个worker，如果一段时间内没有收到响应，master就会将该结点标记为failed。正在进行的map或者reduce更是会重设状态，被调给其他worker。
然而，这些worker已经完成的map任务也会重新设置为idle状态，将会调度给其他的worker，这是因为它们的输出会存在故障机器的本地磁盘上，不过已经完成的reduce任务不需要重新运行，因为它们会存在全局文件系统上。&lt;/p&gt;
&lt;p&gt;如果一个map任务在A worker上执行，然后A挂了，被调度给了B worker。所有的在做reduce的worker都会被通知到这个，然后读取对应的中间数据会从B读取。&lt;/p&gt;
&lt;p&gt;MapReduce对大规模的worker故障有弹性。&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;Master故障&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;master会定期将内部的数据结构写到checkpoints里，如果master挂了，可以很容易的从最后一个checkpoints开启一个新的副本。&lt;/p&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;失败时的Semantics&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;即使有故障，也能得到和没故障发生的情况下一样的输出。&lt;/p&gt;
&lt;p&gt;依赖于map和reduce任务提交的原子性&lt;/p&gt;
&lt;h3 id=&#34;本地&#34;&gt;本地&lt;/h3&gt;
&lt;p&gt;带宽是一种相对稀缺的资源，通过GFS存储在cluster的本地磁盘上。大部分输入数据会在本地读取，不消耗网络带宽。&lt;/p&gt;
&lt;h3 id=&#34;任务粒度&#34;&gt;任务粒度&lt;/h3&gt;
&lt;p&gt;map任务被分为了M个片，reduce任务被分为了R个片，M和R实际上会远高于实际的worker机器，&lt;/p&gt;
&lt;p&gt;master将做$O(M+R)$的任务调度，以及保存$O(M*N)$个状态。&lt;/p&gt;
&lt;h3 id=&#34;备份任务&#34;&gt;备份任务&lt;/h3&gt;
&lt;p&gt;有时候可能会出现某个任务运行过久导致严重影响整体性能，比如某个worker机器的磁盘坏了导致非常慢的运行，它依然响应服务器的心跳不能认为是failed，但是运行就是非常慢。
MapReduce有一个备份任务的机制，就是当MapReduce即将完成的时候，也就是大多数任务都做完了，那么就会去备份还没完成的任务，只要原始任务或者备份任务的其中一个做完了就可以。&lt;/p&gt;
&lt;h2 id=&#34;改良拓展性能表现与实验&#34;&gt;改良拓展、性能表现与实验&lt;/h2&gt;
&lt;p&gt;上述已经是一个基本的MapReduce的任务了，一些改进拓展、性能表现与实验就不详细说明了，日后可以研究。&lt;/p&gt;
</content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://yichengme.site/categories/%E6%8A%80%E6%9C%AF/" term="技术" label="技术" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://yichengme.site/tags/mapreduce/" term="MapReduce" label="MapReduce" />
                            
                        
                            
                            
                            
                                <category scheme="https://yichengme.site/tags/%E5%88%86%E5%B8%83%E5%BC%8F/" term="分布式" label="分布式" />
                            
                        
                            
                            
                            
                                <category scheme="https://yichengme.site/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/" term="大数据" label="大数据" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">Google三驾马车（一）—— Google File System</title>
            <link rel="alternate" type="text/html" href="https://yichengme.site/posts/gfs/" />
            <id>https://yichengme.site/posts/gfs/</id>
            <updated>2022-02-27T15:21:55&#43;08:00</updated>
            <published>2021-10-11T18:00:18&#43;08:00</published>
            <author>
                    <name>王毅诚</name>
                    <uri>https://yichengme.site/</uri>
                    <email>engine74396@gmail.com</email>
                    </author>
            <rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">介绍 GFS，即Google File System，谷歌文件系统。 它是一种能够用于大型密集型数据的可拓展的分布式文件系统。（大型存储系统），它对于廉价硬件提供了容错机制；……</summary>
            
                <content type="html">&lt;h2 id=&#34;介绍&#34;&gt;介绍&lt;/h2&gt;
&lt;p&gt;GFS，即Google File System，谷歌文件系统。
它是一种能够用于大型密集型数据的可拓展的分布式文件系统。（大型存储系统），它对于廉价硬件提供了容错机制；对于大量客户的情况能有高表现。&lt;/p&gt;
&lt;p&gt;GFS的设计是由实际的应用程序负载和技术环境驱动的，与传统的文件系统的一些假设不一样。&lt;/p&gt;
&lt;h2 id=&#34;设计&#34;&gt;设计&lt;/h2&gt;
&lt;h3 id=&#34;一些假设&#34;&gt;一些假设&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;软硬件故障是常态而不是例外&lt;/li&gt;
&lt;li&gt;文件是巨大的（多GB级也是普遍的）&lt;/li&gt;
&lt;li&gt;负载包括大的流式读取和小的随机读取&lt;/li&gt;
&lt;li&gt;负载还包括大的顺序的append写入&lt;/li&gt;
&lt;li&gt;大多数文件是通过append而不是overwrite来改变的，一旦写入，就只能读取，而且是顺序读&lt;/li&gt;
&lt;li&gt;放宽了一致性，从而极大简化了文件系统&lt;/li&gt;
&lt;li&gt;引入了原子的追加写，可以并发的追加&lt;/li&gt;
&lt;li&gt;高的持续带宽比低延迟更重要&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;一般用append，GFS对其一致性有保证，最好不用write&lt;/p&gt;
&lt;h3 id=&#34;接口&#34;&gt;接口&lt;/h3&gt;
&lt;p&gt;接口方面支持通用的create、delte、open、close、read、write。并且还有snapshot和append操作。
snapshot以低成本创建文件或者目录的副本，append允许多个客户端并发的追加同一个文件，保证原子性。
对于实现多路合并以及生产者-消费者模型很有用。&lt;/p&gt;
&lt;h3 id=&#34;架构&#34;&gt;架构&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1640192564/gfs-1.png&#34; alt=&#34;gfs-1&#34;&gt;&lt;/p&gt;
&lt;p&gt;一个GFS集群由一个master结点和多个chunk sever构成，并被多个客户端访问。它们通常都是普通的Linux机器。&lt;/p&gt;
&lt;p&gt;GFS把文件切割为若干固定长度的Chunk块并存储，每个块的大小是64MB，在创建块时，对于每一个Chunk，master还会为其分配一个64位的全局唯一的Handle句柄。为了保证Chunk的可用性，每个块都会被复制到多个chunk server上，默认存储三个副本。&lt;/p&gt;
&lt;p&gt;master维护所有文件系统的元数据，包括namespace、访问控制信息、从文件到chunk的映射、以及块的当前位置。它还控制系统范围内的活动，比如chunk的租约管理、孤立chunk的gc、chunk server之间的chunk迁移。master定期与chunkserver维持心跳通信，给chunkserver指令以及接受它们的状态。客户端和chunkserver都不需要缓存文件数据，从而简化系统，唯一可能要缓存的可能就是客户机会缓存一下元数据。&lt;/p&gt;
&lt;h3 id=&#34;single-master&#34;&gt;Single Master&lt;/h3&gt;
&lt;p&gt;设立一个master可以极大的简化系统的设计，可以很方便地进行全局信息的管理。然而单一的master很容易成为系统的瓶颈，所以只能让其尽可能少的参与读写。客户端从来不从master中读写文件数据，而是向master询问它需要的文件在哪，然后访问这些chunkserver去进行文件交互。&lt;/p&gt;
&lt;p&gt;下面解释一下交互过程，首先客户端借助固定的块大小，将文件名和偏移量转换为块索引，然后向master发送包含文件名和块索引的请求，master返回一个chunk句柄和副本的位置。接下来客户端会向其中一个（往往是最近的）存储着该文件副本的chunkserver发送请求，之后对同一个chunkserver的交互不需要master的参与。事实上客户端通常一次会请求多个块。&lt;/p&gt;
&lt;h3 id=&#34;chunk-size&#34;&gt;Chunk Size&lt;/h3&gt;
&lt;p&gt;选择的是64MB，比典型文件系统的块大得多，相对于小的chunk size，更大的chunk size的优势在于：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;减少客户端请求的chunk数量，减少客户端与master的交互需求。&lt;/li&gt;
&lt;li&gt;大的chunk可以让客户端执行很多操作，通过较长时间与chunkserver的持续的tcp连接来减少网络开销&lt;/li&gt;
&lt;li&gt;减少了chunk的个数，从而减少了存储在master的元数据的大小&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;当然，大的chunk size也有缺点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;可能会出现更多客户端访问一个chunk从而导致这个chunk成为hot spots。一般来说还好，不过如果某个可执行文件被写入了某个chunk，然后在数百台机器上同时启动，那个chunkserver就很容易超载。一个解决方法是将可执行文件复制更多份，并使批队列系统错开启动时间。还有一个解决方法是允许客户机从其他客户机读取数据。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;metadata&#34;&gt;Metadata&lt;/h3&gt;
&lt;p&gt;元数据包含文件和chunk的namespace、从文件到块的映射、以及每个chunk副本的位置，所有的元数据都存储在master的内存中。前面两个也通过日志的方式存储在本地磁盘中，实现持久性存储，顺带也复制在远程机器上备份。这个主要是保证即使master崩溃了也不会出现不一致。
至于chunk副本的位置，master并不会持久地存储，而是在master启动的时候对每个chunkserver进行轮询，或者在新的chunkserver加入集群时询问。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;内存中的数据结构
元数据存储在内存中，所以访问起来很快。
master还会在后台周期性的扫描整个状态，用于实现gc、chunkserver故障时的重新复制、块迁移来平衡负载等。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;可能会认为说元数据存在master内存中，整个系统的容量会受到master内存的限制，实际上chunk由于比较大，个数不会那么多，master也只需要存每个chunk的不到64字节的元数据，所以还好。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;chunk位置
前面说了master通过启动时的轮询获得信息，并且还会保持一个心跳来监听各个chunkserver的状态。
由于集群很大，如果在master上持久化在本地存储chunk副本位置，之后变动会很多（改名、宕机、重启等），并且实际上chunkserver才是对chunk有着最终决定权，在master上维护一个一致性的视图是没有意义的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;操作日志
操作日志包含了元数据发生重大变化的历史记录，是GFS的核心。它是元数据的唯一持久性记录，也作为定义并发操作顺序的逻辑时间线。操作日志需要被可靠地存储。
如果系统崩了，master就会重新执行log来恢复GFS，所以log也不宜过大，以免启动时间过长。会先找到重载的checkpoint然后执行之后的日志记录。检查点是一种类似B树的紧凑形式，加快恢复速度。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;一致性模型&#34;&gt;一致性模型&lt;/h3&gt;
&lt;p&gt;GFS并不保持一个严格的一致性，而是保持一个相对宽松的一致性&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;GFS保证的
命名空间是原子的，保证操作日志是全局的顺序正确的。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;数据更改之后的文件区域的状态：&lt;/p&gt;
&lt;p&gt;文件数据更改之后，会定义一个region，其状态取决于变化的种类（write/append）、是否并行、成功还是失败。&lt;/p&gt;
&lt;p&gt;如果它是一致的，客户端会看到变化写入的内容。
如何区分已定义区域和未定义区域。&lt;/p&gt;
&lt;p&gt;在一次成功的顺序变化后，GFS会：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在chunk的所有副本上以相同的顺序应用这些变化&lt;/li&gt;
&lt;li&gt;使用chunk版本号来检测副本&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;应用程序应当append而不是write。&lt;/p&gt;
&lt;h2 id=&#34;系统交互&#34;&gt;系统交互&lt;/h2&gt;
&lt;p&gt;描述客户端、master、chunkserver如何进行交互，完成数据更改、原子追加和快照。&lt;/p&gt;
&lt;h3 id=&#34;租约和数据更改顺序&#34;&gt;租约和数据更改顺序&lt;/h3&gt;
&lt;p&gt;数据更改（mutations）就是改变chunk的内容或者元数据的操作，比如write或append。数据更改在chunk副本上执行。
使用租约（leases）来维持副本之间的一致的变化顺序。master会将租约授权给其中一个副本，称之为该chunk的主服务器（primary）。主服务器会为这个chunk的所有更改进行顺序排序，其余的所有副本都遵守这个顺序进行更改。
租约机制的目的也是减少master的管理开销，租约的初始时间是60s，不过主要chunk发生了改变，primary就可以向master请求拓展，这些请求被承载在心跳信息上。&lt;/p&gt;
&lt;p&gt;下图是写操作的控制流与详细的步骤
&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1640192564/gfs-2.png&#34; alt=&#34;gfs-2&#34;&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;客户端询问master哪个chunkserver持有当前chunk的租约，以及其他副本的位置。如果没有服务器有租约，master就选择一个副本服务器分给它租约&lt;/li&gt;
&lt;li&gt;服务器返回primary和副本chunkserver的位置，客户端把它们存在缓存中，如果未来短期内再次访问就不需要请求master。除非primary不可达或者primary告知客户端它没有租约了。&lt;/li&gt;
&lt;li&gt;客户端知道副本位置后，将数据push进所有的副本中，可以按照任何顺序。每个chunkserver将数据存储在一个内部的LRU缓存中&lt;/li&gt;
&lt;li&gt;一旦所有的副本都确认接受到了数据，客户端就向primary发送写请求，标识了之前push的数据，primary会分配序列号给这些mutations，提供必要的序列化&lt;/li&gt;
&lt;li&gt;primary将写请求转发给各个备用副本，每个备份副本按照序列号执行更改&lt;/li&gt;
&lt;li&gt;备份副本回复primary表示已经完成了操作&lt;/li&gt;
&lt;li&gt;primary响应客户端，任何遇到的错误也会报告&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;数据流&#34;&gt;数据流&lt;/h3&gt;
&lt;p&gt;数据流和控制流解耦，为了充分利用每台机器的带宽，数据被线性的沿着chunkserver链进行推送，而不是分布在拓扑网络中，这样每台机器的带宽就可以被充分利用，每台机器将数据转发到网络拓扑中“最近的”没有接收到它的机器。（感觉像Prim算法）&lt;/p&gt;
&lt;h3 id=&#34;原子追加&#34;&gt;原子追加&lt;/h3&gt;
&lt;p&gt;GFS提供了原子追加（atomic record appends）操作。
传统的写操作需要提供数据和偏移量，如果出现并行的情况就很可能会出现来自多个客户端的碎片。
在GFS中，客户端只提供数据，GFS会选择偏移量并将其返回给客户端，类似于Unix的&lt;code&gt;O_APPEND&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;大量使用record append，如果是传统的写操作，为了保持一致性就只能使用分布式锁，代价很昂贵。&lt;/p&gt;
&lt;h3 id=&#34;snapshot快照&#34;&gt;Snapshot快照&lt;/h3&gt;
&lt;p&gt;类似AFS，使用标准的copy-on-write技术实现快照。&lt;/p&gt;
&lt;h2 id=&#34;master操作&#34;&gt;Master操作&lt;/h2&gt;
&lt;p&gt;master的任务：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;执行所有namespace相关的操作&lt;/li&gt;
&lt;li&gt;管理系统的chunk副本以及与之相关的一些操作&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;namespace的管理和锁定&#34;&gt;namespace的管理和锁定&lt;/h3&gt;
&lt;p&gt;GFS没有传统文件系统的per-directory数据结构。也不支持alias。&lt;/p&gt;
&lt;h3 id=&#34;gc&#34;&gt;gc&lt;/h3&gt;
&lt;p&gt;文件被删除之后，不会立即回收资源，而是先重命名为包含删除时间戳的隐藏文件，如果隐藏文件存在超过三天，就删除它们。在此期间，这些文件可以被恢复。
内存元数据也会被删除，切断和所有chunk的联系，在和master的心跳中，chunkserver报告自己的chunks，master会返回不出现在namespace里的，chunkserver接受到后可以删掉这些chunk。&lt;/p&gt;
&lt;h2 id=&#34;容错性与诊断&#34;&gt;容错性与诊断&lt;/h2&gt;
&lt;h3 id=&#34;高可用性&#34;&gt;高可用性&lt;/h3&gt;
&lt;p&gt;通过两种简单而有效的策略来保持整个系统的高可用性:快速恢复和复制&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;快速恢复
master和chunkserver都可以在几秒内启动&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;chunk复制
默认是复制3份&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;master复制&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;操作日志和检查点被复制到多台机器上&lt;/p&gt;
</content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://yichengme.site/categories/%E6%8A%80%E6%9C%AF/" term="技术" label="技术" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://yichengme.site/tags/gfs/" term="GFS" label="GFS" />
                            
                        
                            
                            
                            
                                <category scheme="https://yichengme.site/tags/%E5%88%86%E5%B8%83%E5%BC%8F/" term="分布式" label="分布式" />
                            
                        
                            
                            
                            
                                <category scheme="https://yichengme.site/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/" term="大数据" label="大数据" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">Go并发（三）RWMutex源码剖析</title>
            <link rel="alternate" type="text/html" href="https://yichengme.site/posts/go-concurrency-4-waitgroup/" />
            <id>https://yichengme.site/posts/go-concurrency-4-waitgroup/</id>
            <updated>2022-03-02T19:25:50&#43;08:00</updated>
            <published>2021-03-06T22:03:48&#43;08:00</published>
            <author>
                    <name>王毅诚</name>
                    <uri>https://yichengme.site/</uri>
                    <email>engine74396@gmail.com</email>
                    </author>
            <rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">WaitGroup用于任务编排，解决并发-等待的问题。 试想一下，某个并发场景需要完成前置的几个协程任务才能完成另一个任务，如果没有WaitGroup、Chann……</summary>
            
                <content type="html">&lt;p&gt;WaitGroup用于任务编排，解决并发-等待的问题。&lt;/p&gt;
&lt;p&gt;试想一下，某个并发场景需要完成前置的几个协程任务才能完成另一个任务，如果没有WaitGroup、Channel等机制，可能需要轮询查看前置任务是否完成，非常浪费资源。&lt;/p&gt;
&lt;p&gt;WaitGroup的作用是阻塞goroutine，并可以在特定的情况下唤醒。&lt;/p&gt;
&lt;h2 id=&#34;waitgroup使用方式&#34;&gt;WaitGroup使用方式&lt;/h2&gt;
&lt;p&gt;WaitGroup包含三个方法：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;nx&#34;&gt;wg&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Add&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;nx&#34;&gt;wg&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Done&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
&lt;span class=&#34;nx&#34;&gt;wg&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Wait&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;Add可以设置WaitGroup的计数值，一般放在前面写
Done用来将计数值-1，写在前置goroutine里
Wait会阻塞当前的goroutine，直到WaitGroup的计数值为0，写在需要等待的goroutine里，很多情况下是main goroutine。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;say&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;s&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;wg&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;sync&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;WaitGroup&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;defer&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;wg&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Done&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;5&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;nx&#34;&gt;time&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Sleep&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;200&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;time&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Millisecond&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
        &lt;span class=&#34;nx&#34;&gt;fmt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Println&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;nx&#34;&gt;wg&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;new&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;sync&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;WaitGroup&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
    &lt;span class=&#34;nx&#34;&gt;wg&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Add&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;go&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;say&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;1&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;wg&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;go&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;say&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;2&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;wg&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
    &lt;span class=&#34;nx&#34;&gt;wg&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Wait&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;比如使用WaitGroup后，可以确保主协程会在前面的goroutine结束之后才会继续。&lt;/p&gt;
&lt;h2 id=&#34;waitgroup原理基础&#34;&gt;WaitGroup原理基础&lt;/h2&gt;
&lt;h3 id=&#34;nocopy字段&#34;&gt;nocopy字段&lt;/h3&gt;
&lt;p&gt;对于一些不应该被复制的结构体，可以在里面增加&lt;code&gt;nocopy&lt;/code&gt;字段，它的底层是：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;kd&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;noCopy&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;struct&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{}&lt;/span&gt;

&lt;span class=&#34;c1&#34;&gt;// Lock is a no-op used by -copylocks checker from `go vet`.
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;noCopy&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;Lock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{}&lt;/span&gt;
&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;noCopy&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;UnLock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;用&lt;code&gt;go vet&lt;/code&gt;检测就会报错。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;nx&#34;&gt;Copy&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;passes&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;lock&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;by&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;value&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Demo&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;contains&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;noCopy&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h2 id=&#34;源码解析&#34;&gt;源码解析&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;8
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;kd&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;WaitGroup&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;nx&#34;&gt;noCopy&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;noCopy&lt;/span&gt;

  &lt;span class=&#34;c1&#34;&gt;// 前两个元素作为state，后一个元素作为信号量
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;c1&#34;&gt;// 第一个是当前阻塞的goroutine个数，第二个是WaitGroup计数值，第三个是信号量
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;c1&#34;&gt;// 对于32bit和64bit系统，字段有些许差别，后面有代码表示，这里不作讨论
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;nx&#34;&gt;state1&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;uint32&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;wg&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;WaitGroup&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;Add&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;delta&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;c1&#34;&gt;// 获取state和信号量
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;nx&#34;&gt;statep&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;semap&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;wg&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;state&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
  &lt;span class=&#34;c1&#34;&gt;// 高32bit是计数值，所以把delta左移32位加到WaitGroup计数值上
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;nx&#34;&gt;state&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;atomic&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;AddUint64&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;statep&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;uint64&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;delta&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;32&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
  &lt;span class=&#34;c1&#34;&gt;// 当前计数值
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;nx&#34;&gt;v&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;int32&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;state&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;32&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
  &lt;span class=&#34;c1&#34;&gt;// 等待者数量
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;nx&#34;&gt;w&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;uint32&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;state&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
  &lt;span class=&#34;c1&#34;&gt;// 计数值大于0或者w等于0，直接正常的返回
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;v&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;||&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;w&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt;
  &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
  &lt;span class=&#34;c1&#34;&gt;// 接下来的情况就是计数值等于0，但是还有等待者的情况，此时等待的已经没有意义
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;c1&#34;&gt;// 比如说一开始只设了wg.Add(3)，结果启动了五个goroutine里面都有Done，Done了三次之后，剩下的两个协程不会等它们执行完了。
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;c1&#34;&gt;// 直接把组合的statep设为0（v和w都设为0）
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;statep&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;
  &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;w&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;w&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;--&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;nf&#34;&gt;runtime_Semrelease&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;semap&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;false&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
  &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;wg&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;WaitGroup&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;Done&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;nx&#34;&gt;wg&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Add&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// 一直阻塞，直到state的计数值=0
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;wg&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;WaitGroup&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;Wait&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;nx&#34;&gt;statep&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;semap&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;wg&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;state&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
  &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;nx&#34;&gt;state&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;atomic&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;LoadUint64&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;statep&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
    &lt;span class=&#34;nx&#34;&gt;v&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;int32&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;state&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;32&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
    &lt;span class=&#34;nx&#34;&gt;w&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;uint32&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;state&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;// 如果为0.直接返回
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;v&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
      &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;// 否则阻塞
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;atomic&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;CompareAndSwapUint64&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;statep&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;state&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;state&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
      &lt;span class=&#34;nf&#34;&gt;runtime_Semacquire&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;semap&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
      &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
  &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h2 id=&#34;waitgroup的易错场景&#34;&gt;WaitGroup的易错场景&lt;/h2&gt;
&lt;h3 id=&#34;add一个负数&#34;&gt;Add一个负数&lt;/h3&gt;
&lt;p&gt;除非能保证Add负数之后计数器仍大于0，否则会panic。一般不会Add负数，都通过Done的方式来-1。&lt;/p&gt;
&lt;p&gt;另一种就是Done的次数过多，这样会导致减到负数之后直接导致panic。&lt;/p&gt;
&lt;h3 id=&#34;add在wait之后调用&#34;&gt;Add在Wait之后调用&lt;/h3&gt;
&lt;p&gt;如果在一些子goroutine里面开头调用&lt;code&gt;Add&lt;/code&gt;，结束调用&lt;code&gt;Done&lt;/code&gt;，然后主协程&lt;code&gt;Wait&lt;/code&gt;，会出现&lt;code&gt;Add&lt;/code&gt;在&lt;code&gt;Wait&lt;/code&gt;之后的情况，那么&lt;code&gt;Wait&lt;/code&gt;不会被这些自协程阻塞，这些自协程很可能得不到执行。&lt;/p&gt;
&lt;h3 id=&#34;未置为0就重用&#34;&gt;未置为0就重用&lt;/h3&gt;
&lt;p&gt;WaitGroup可以完成一次编排任务，计数值降为0后可以继续被其他任务所用，但是不要在还没使用完的时候就用于其他任务，这样由于带着计数值，很可能出问题。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1646219952/waitGroup-1.jpg&#34; alt=&#34;waitGroup-1&#34;&gt;&lt;/p&gt;
</content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://yichengme.site/categories/%E6%8A%80%E6%9C%AF/" term="技术" label="技术" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://yichengme.site/tags/golang/" term="Golang" label="Golang" />
                            
                        
                            
                            
                            
                                <category scheme="https://yichengme.site/tags/%E5%B9%B6%E5%8F%91/" term="并发" label="并发" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">Go并发（三）RWMutex源码剖析</title>
            <link rel="alternate" type="text/html" href="https://yichengme.site/posts/go-concurrency-3-rwmutex/" />
            <id>https://yichengme.site/posts/go-concurrency-3-rwmutex/</id>
            <updated>2022-03-02T19:25:33&#43;08:00</updated>
            <published>2021-02-19T22:03:48&#43;08:00</published>
            <author>
                    <name>王毅诚</name>
                    <uri>https://yichengme.site/</uri>
                    <email>engine74396@gmail.com</email>
                    </author>
            <rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">RWMutex专门用于解决读写问题。 RWMutex使用方式 方法有五个： Lock：写操作调用，如果锁被写或读占用，会阻塞，如果拿到了锁，其他的读写都会阻塞 Unlo……</summary>
            
                <content type="html">&lt;p&gt;RWMutex专门用于解决读写问题。&lt;/p&gt;
&lt;h2 id=&#34;rwmutex使用方式&#34;&gt;RWMutex使用方式&lt;/h2&gt;
&lt;p&gt;方法有五个：
&lt;code&gt;Lock&lt;/code&gt;：写操作调用，如果锁被写或读占用，会阻塞，如果拿到了锁，其他的读写都会阻塞
&lt;code&gt;Unlock&lt;/code&gt;：写操作调用。释放writer的锁。
&lt;code&gt;RLock&lt;/code&gt;：读操作调用，如果锁被写占用，会阻塞，否则就不会
&lt;code&gt;RUnlock&lt;/code&gt;：读操作调用。释放reader的锁。
&lt;code&gt;RLocker&lt;/code&gt;：返回一个读操作的接口，它的&lt;code&gt;Lock&lt;/code&gt;方法会调&lt;code&gt;RLock&lt;/code&gt;，&lt;code&gt;Unlock&lt;/code&gt;会调&lt;code&gt;RUnlock&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;使用举例，比如一个可以自增和读的计数器，其中读的频率更高。&lt;/p&gt;
&lt;p&gt;对于这种情况，我们用Mutex的话会损失性能，因为并发读是允许的，所以采用&lt;code&gt;RWMutex&lt;/code&gt;更好。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;30
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;31
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;32
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;kd&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;Counter&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;nx&#34;&gt;mu&lt;/span&gt;    &lt;span class=&#34;nx&#34;&gt;sync&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;RWMutex&lt;/span&gt;
  &lt;span class=&#34;nx&#34;&gt;Count&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Counter&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;Incr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;mu&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Lock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
  &lt;span class=&#34;k&#34;&gt;defer&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;mu&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Unlock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
  &lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Count&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Counter&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;Read&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;mu&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;RLock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
  &lt;span class=&#34;k&#34;&gt;defer&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;mu&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;RUnlock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
  &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Count&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;kd&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;Counter&lt;/span&gt;
  &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;10&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;go&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
      &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;nx&#34;&gt;time&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Sleep&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;time&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Second&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
        &lt;span class=&#34;nx&#34;&gt;fmt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Println&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Read&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;())&lt;/span&gt;
      &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;}()&lt;/span&gt;
  &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
  &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Incr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
    &lt;span class=&#34;nx&#34;&gt;time&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Sleep&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;time&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Second&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
  &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h2 id=&#34;rwmutex原理基础&#34;&gt;RWMutex原理基础&lt;/h2&gt;
&lt;p&gt;已经有了Mutex，为什么还要RWMutex？因为对于并发读的场景，实际上没必要加锁，加锁会影响性能。&lt;/p&gt;
&lt;p&gt;也就是说如果当前一个读操作的goroutine持有了锁，对于其他的读操作的goroutine而言，无需等待，可以并发访问变量。&lt;/p&gt;
&lt;p&gt;当然对于写操作，必须独占锁，写完之后才能继续读或写。&lt;/p&gt;
&lt;p&gt;RWMutex同一时间可以被任意数量的Reader持有，或者被单个的Writer持有。&lt;/p&gt;
&lt;p&gt;读写问题一般有三种方式：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;读优先&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;写优先&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;不指定优先级&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;RWMutex采用写优先的策略，也就是说一旦有一个writer在请求锁的话，新来的reader不会获取锁。writer会等到来的时候存在的reader读完就开始写，保证writer不会饥饿。&lt;/p&gt;
&lt;p&gt;RWMutex基于Mutex实现，所以代码容易很多，相当于在Mutex的基础上做了一个变体。&lt;/p&gt;
&lt;h2 id=&#34;源码解析&#34;&gt;源码解析&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;kd&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;RWMutex&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;c1&#34;&gt;// 互斥锁，解决多个writer的竞争
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;nx&#34;&gt;w&lt;/span&gt;           &lt;span class=&#34;nx&#34;&gt;Mutex&lt;/span&gt;
  &lt;span class=&#34;c1&#34;&gt;// writer信号量
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;nx&#34;&gt;writerSem&lt;/span&gt;   &lt;span class=&#34;kt&#34;&gt;uint32&lt;/span&gt;
  &lt;span class=&#34;c1&#34;&gt;// reader信号量
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;nx&#34;&gt;readerSem&lt;/span&gt;   &lt;span class=&#34;kt&#34;&gt;uint32&lt;/span&gt;
  &lt;span class=&#34;c1&#34;&gt;// reader数量
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;nx&#34;&gt;readerCount&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int32&lt;/span&gt;
  &lt;span class=&#34;c1&#34;&gt;// 对于reader正在读的场景，记录当前正在读的reader的数量，也就是writer要等待的reader的数量
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;nx&#34;&gt;readerWait&lt;/span&gt;  &lt;span class=&#34;kt&#34;&gt;int32&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;// 支持的最大的reader数量，2^30个
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;rwmutexMaxReaders&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;30&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;这样设计的原因在于，writer的个数是无所谓的，因为都通过Mutex进行完全的互斥，但是reader的个数很关键。&lt;/p&gt;
&lt;p&gt;没有writer竞争或持有锁的时候，readerCount就是reader的个数，如果有的话就是一个负数。&lt;/p&gt;
&lt;p&gt;先看&lt;code&gt;RLock&lt;/code&gt;，也就是读的锁，什么时候会阻塞读？就是在有writer在等锁的时候。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;9
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;rw&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;RWMutex&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;RLock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;c1&#34;&gt;// 先给readerCount+1
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;c1&#34;&gt;// 如果结果是负值，说明有writer竞争或持有锁
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;c1&#34;&gt;// 见后面writer的lock方法，一旦有writer拿到了写锁，readerCount就会被置为readerCount-rwmutexMaxReaders，也就是非常小的负数
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;atomic&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;AddInt32&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;rw&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;readerCount&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;// 阻塞读
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;nf&#34;&gt;runtime_SemacquireMutex&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;rw&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;readerSem&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;false&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
  &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;rw&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;RWMutex&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;RUnlock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;c1&#34;&gt;// readCount-1，如果有writer竞争，就调用rUnlockSlow
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;r&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;atomic&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;AddInt32&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;rw&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;readerCount&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;r&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;nx&#34;&gt;rw&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;rUnlockSlow&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
  &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;rw&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;RWMutex&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;rUnlockSlow&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;r&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int32&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;atomic&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;AddInt32&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;rw&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;readerWait&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;// 如果reader都释放了锁，就唤醒writer，把锁给writer
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;nf&#34;&gt;runtime_Semrelease&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;rw&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;writerSem&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;false&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
  &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;writer通过&lt;code&gt;Mutex&lt;/code&gt;保持互斥，通过&lt;code&gt;Lock&lt;/code&gt;和&lt;code&gt;Unlock&lt;/code&gt;加锁和释放锁：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;rw&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;RWMutex&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;Lock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;c1&#34;&gt;// writer之间的互斥
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;nx&#34;&gt;rw&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;w&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Lock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
  &lt;span class=&#34;c1&#34;&gt;// 通知其他reader，有writer在等锁，把readerCount置为很小的负数
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;nx&#34;&gt;r&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;atomic&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;AddInt32&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;rw&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;readerCount&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;rwmutexMaxReaders&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;rwmutexMaxReaders&lt;/span&gt;
  &lt;span class=&#34;c1&#34;&gt;// 当前的reader没读完，阻塞写
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;r&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;atomic&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;AddInt32&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;rw&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;readerWait&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;nf&#34;&gt;runtime_SemacquireMutex&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;rw&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;writerSem&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;false&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
  &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;rw&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;RWMutex&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;Unlock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;c1&#34;&gt;// 通知reader当前的writer写完了
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;nx&#34;&gt;r&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;atomic&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;AddInt32&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;rw&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;readerCount&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;rwmutexMaxReaders&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
  &lt;span class=&#34;c1&#34;&gt;// 唤醒阻塞的reader
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;nf&#34;&gt;runtime_Semrelease&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;rw&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;readerSem&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;false&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
  &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
  &lt;span class=&#34;c1&#34;&gt;// 释放写锁，其他writer可以来拿
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;nx&#34;&gt;rw&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;w&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Unlock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h2 id=&#34;rwmutex的易错场景&#34;&gt;RWMutex的易错场景&lt;/h2&gt;
&lt;h3 id=&#34;不可复制&#34;&gt;不可复制&lt;/h3&gt;
&lt;p&gt;因为包含了Mutex，其他字段也有状态意义，所以RWMutex肯定也是不能复制的。&lt;/p&gt;
&lt;h3 id=&#34;释放没加锁的rwmutex&#34;&gt;释放没加锁的RWMutex&lt;/h3&gt;
&lt;p&gt;和前面的Mutex一样&lt;/p&gt;
&lt;h3 id=&#34;重入导致死锁&#34;&gt;重入导致死锁&lt;/h3&gt;
&lt;p&gt;和Mutex一样&lt;/p&gt;
&lt;h3 id=&#34;reader调用writer导致死锁&#34;&gt;reader调用writer导致死锁&lt;/h3&gt;
&lt;p&gt;比如在reader方法里调用writer，由于writer必须等待活跃reader完成，相当于自己锁自己。&lt;/p&gt;
&lt;h3 id=&#34;环形依赖导致的死锁&#34;&gt;环形依赖导致的死锁&lt;/h3&gt;
&lt;p&gt;writer需要等待活跃的reader完成读
新来的reader会等待writer
如果活跃的reader调用新来的reader，那么就会环形依赖导致死锁。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1646219904/RWMutex-1.jpg&#34; alt=&#34;RWMutex-1&#34;&gt;&lt;/p&gt;
</content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://yichengme.site/categories/%E6%8A%80%E6%9C%AF/" term="技术" label="技术" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://yichengme.site/tags/golang/" term="Golang" label="Golang" />
                            
                        
                            
                            
                            
                                <category scheme="https://yichengme.site/tags/%E5%B9%B6%E5%8F%91/" term="并发" label="并发" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">Go并发（二）Mutex源码剖析</title>
            <link rel="alternate" type="text/html" href="https://yichengme.site/posts/go-concurrency-2-mutex/" />
            <id>https://yichengme.site/posts/go-concurrency-2-mutex/</id>
            <updated>2022-03-02T19:24:41&#43;08:00</updated>
            <published>2021-02-06T22:03:48&#43;08:00</published>
            <author>
                    <name>王毅诚</name>
                    <uri>https://yichengme.site/</uri>
                    <email>engine74396@gmail.com</email>
                    </author>
            <rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">基本并发原语 接下来的几节将会解析Go的这几个基本并发原语（同步原语）：Mutex、RWMutex、WaitGroup、Cond、Channel 为什么要用并发原语……</summary>
            
                <content type="html">&lt;h2 id=&#34;基本并发原语&#34;&gt;基本并发原语&lt;/h2&gt;
&lt;p&gt;接下来的几节将会解析Go的这几个基本并发原语（同步原语）：Mutex、RWMutex、WaitGroup、Cond、Channel&lt;/p&gt;
&lt;p&gt;为什么要用并发原语？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;共享资源保护（通常用Mutex、RWMutex）&lt;/li&gt;
&lt;li&gt;任务编排，需要goroutine按照一定规律执行（通常用WaitGroup、Channel）&lt;/li&gt;
&lt;li&gt;消息传递，不同goroutine之间的消息传递（通常用Channel）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;本篇要说的Mutex互斥锁是go中使用最广泛的并发原语（或者叫同步原语）。&lt;/p&gt;
&lt;h2 id=&#34;mutex使用方式&#34;&gt;Mutex使用方式&lt;/h2&gt;
&lt;p&gt;Mutex互斥锁的使用方式很简单：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;kd&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;mu&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;sync&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Mutex&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;// 进入临界区之前先上锁
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;mu&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Lock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
&lt;span class=&#34;cm&#34;&gt;/*
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt;=====================
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; 一些需要保护的临界区
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt;=====================
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt;*/&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;// 退出临界区之后要解锁
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;mu&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Unlock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;更多的时候是嵌入到struct里，比如并发安全的计数器：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;kd&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;Counter&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;struct&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;nx&#34;&gt;mu&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;sync&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Mutex&lt;/span&gt;
  &lt;span class=&#34;nx&#34;&gt;Count&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;如果嵌入struct中，比较好的编程风格是把Mutex字段放在需要被控制的字段的上面一个，这样比较清晰。这个结构的实例如果访问了共享资源，可以：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Counter&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;Add&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;){&lt;/span&gt;
  &lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;mu&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Lock&lt;/span&gt;
  &lt;span class=&#34;k&#34;&gt;defer&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;mu&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Unlock&lt;/span&gt;
  &lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Count&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;i&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;Mutex不需要初始化，不会出现空指针或者获取不到锁的情况。&lt;/p&gt;
&lt;p&gt;Mutex可以被任意一个goroutine释放锁，如果不是当前拿锁的goroutine释放锁的话就会带来严重的问题。所以务必要遵守&lt;strong&gt;谁申请谁释放&lt;/strong&gt;的原则&lt;/p&gt;
&lt;p&gt;另外，还要注意&lt;strong&gt;Lock和Unlock成对出现&lt;/strong&gt;有的时候可能有一些复杂的分支，一些分支会漏写&lt;code&gt;Unlock()&lt;/code&gt;，或者删除代码的时候误删等，从而造成死锁。&lt;/p&gt;
&lt;p&gt;所以更好的方式是采用defer的方式，让Lock和Unlock总是紧凑的成对出现，以免后面忘记Unlock：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;nx&#34;&gt;mu&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Lock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;defer&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;mu&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Unlock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;// 访问共享资源的操作
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;Mutex不能被复制，需要用到一个新的Mutex直接初始化，如果复制了可能会带着之前的状态，从而造成问题。&lt;/p&gt;
&lt;p&gt;Mutex不可重入，关于重入，有些语言（如Java）支持，即一个进程获取到了锁之后，再次获取这个锁可以成功，其他进程会被阻塞。但是Mutex不支持重入，因为它不会检测哪个goroutine拥有这把锁。也就是说不能两次获取同一把锁。&lt;/p&gt;
&lt;h2 id=&#34;mutex原理基础&#34;&gt;Mutex原理基础&lt;/h2&gt;
&lt;h3 id=&#34;mutex演进&#34;&gt;Mutex演进&lt;/h3&gt;
&lt;p&gt;最初的Mutex只是普通实现了抢锁、阻塞、释放锁等流程。
之后逐渐加入了：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;让新加入的goroutine有更多机会获取到锁&lt;/li&gt;
&lt;li&gt;让新来的和唤醒的有更多机会竞争锁&lt;/li&gt;
&lt;li&gt;解决饥饿问题，不会让goroutine阻塞太久&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;当一个锁被释放后，如果有多于一个协程的都在获取这个锁，锁最终会按照FIFO的原则给排队中的协程。&lt;/p&gt;
&lt;p&gt;单纯的FIFO虽然公平但是效率不高，对于刚刚排到队刚唤醒的gorourine和新到的goroutine相比，新来的goroutine已经在CPU上运行，上下文切换会降低效率，所以新来的会和刚唤醒的goroutine对锁进行竞争。而不是直接把醒来的goroutine放到队尾。&lt;/p&gt;
&lt;p&gt;但是这么做可能会造成饥饿，因此如果等待者在1ms之内没有获取到锁，将会从正常模式切换到饥饿模式。&lt;/p&gt;
&lt;h3 id=&#34;mutex的两种模式正常模式和饥饿模式&#34;&gt;Mutex的两种模式：正常模式和饥饿模式。&lt;/h3&gt;
&lt;p&gt;正常模式下，等待的goroutine按照FIFO的顺序排队，刚唤醒的等待者与新来的goroutine进行竞争，因为新来的goroutine可能有很多。如果有等待者等待了1ms以上，就进入饥饿模式。
饥饿模式下，Mutex的所有权严格按照FIFO依次交出，新到达的goroutine不再尝试获取Mutex，也不会自旋。它们只是会排队在末尾。&lt;/p&gt;
&lt;p&gt;如果等待者发现它是队列的最后一个等待者，或者它等待了不到1ms，那么就切换为正常模式。
正常模式的性能很好，但是饥饿模式有必要性，否则可能出现goroutine饿死的情况。&lt;/p&gt;
&lt;h3 id=&#34;自旋锁&#34;&gt;自旋锁&lt;/h3&gt;
&lt;p&gt;自旋这个概念也有很多很重要的应用，后面讲并发调度底层原理的时候也会提到，等待CPU调度的时候也一样有这种自旋的概念，这里先解释一下，不然后面源码看不懂。&lt;/p&gt;
&lt;p&gt;自旋锁指的是一个线程在获取锁的时候，如果锁已经被其他线程获取，那么该线程会循环等待，不断判断是够能够被成功获取，一旦能获取到锁才会退出循环。自旋锁不会引起调用者的睡眠。&lt;/p&gt;
&lt;p&gt;Mutex的源码出现了&lt;code&gt;sync_runtime_canSpin&lt;/code&gt;和&lt;code&gt;sync_runtime_doSpin&lt;/code&gt;这两个自旋锁有关的函数，由于其源码涉及到了最底层的并发原理，将放到后面再讲，这里先理解一下两个函数的作用。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;sync_runtime_canSpin&lt;/code&gt;：返回目前自旋是否有意义。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;sync_runtime_doSpin&lt;/code&gt;：开始自旋。&lt;/p&gt;
&lt;h3 id=&#34;信号量&#34;&gt;信号量&lt;/h3&gt;
&lt;p&gt;信号量机制（semaphore）在很多地方都有应用，在操作系统中也学习过，见之前的&lt;a href=&#34;https://yichengme.site/posts/os-basics-thread/&#34;&gt;操作系统基础（二）进程与线程&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;sema提供了&lt;code&gt;sleep&lt;/code&gt;和&lt;code&gt;wakeup&lt;/code&gt;的并发原语。&lt;/p&gt;
&lt;p&gt;Mutex的源码出现了&lt;code&gt;sync_runtime_SemacquireMutex&lt;/code&gt;和&lt;code&gt;poll_runtime_Semrelease&lt;/code&gt;这两个信号量相关的函数，这里只理解一下函数的作用：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;sync_runtime_SemacquireMutex&lt;/code&gt;：对当前锁进行sleep，阻塞自己&lt;/p&gt;
&lt;p&gt;&lt;code&gt;poll_runtime_Semrelease&lt;/code&gt;：唤醒sleep的锁，&lt;/p&gt;
&lt;h2 id=&#34;mutex源码解析&#34;&gt;Mutex源码解析&lt;/h2&gt;
&lt;h3 id=&#34;变量&#34;&gt;变量&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;sync/mutex&lt;/code&gt;的源码只有两百行（去掉注释只有一百来行），当然其中更底层的是原子包（源码位于&lt;code&gt;sync/atomic.go&lt;/code&gt;）、自旋锁（源码位于&lt;code&gt;runtime/proc.go&lt;/code&gt;）、信号量（源码位于&lt;code&gt;runtime/sema.go&lt;/code&gt;），这几个之后再讨论，先看&lt;code&gt;sync/mutex.go&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Locker&lt;/code&gt;接口，&lt;code&gt;Locker&lt;/code&gt;接口有两个方法&lt;code&gt;Lock()&lt;/code&gt;和&lt;code&gt;Unlock()&lt;/code&gt;，只要实现了这两个方法就属于Locker类，Mutex就是实现了&lt;code&gt;Locker&lt;/code&gt;的接口。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;kd&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;Locker&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;interface&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;nf&#34;&gt;Lock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
  &lt;span class=&#34;nf&#34;&gt;Unlock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;kd&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;Mutex&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;c1&#34;&gt;// state，这一个字段包含了多种数据，下面细说
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;nx&#34;&gt;state&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int32&lt;/span&gt;
  &lt;span class=&#34;c1&#34;&gt;// 等待者队列的信号量变量，用以阻塞或唤醒goroutine
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;nx&#34;&gt;sema&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;uint32&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;state是一个字段，前三个比特分别表示mutexLocked、mutexWoken和mutexStarving，剩余的bit表示mutexWaiter&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// state的各个字段的意义
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;
  &lt;span class=&#34;c1&#34;&gt;// 上锁状态，1
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;nx&#34;&gt;mutexLocked&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;iota&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// mutex is locked
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;c1&#34;&gt;// 唤醒状态，2
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;nx&#34;&gt;mutexWoken&lt;/span&gt;
  &lt;span class=&#34;c1&#34;&gt;// 饥饿状态，4
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;nx&#34;&gt;mutexStarving&lt;/span&gt;
  &lt;span class=&#34;c1&#34;&gt;// mutex上阻止的goroutine个数，3
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;nx&#34;&gt;mutexWaiterShift&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;iota&lt;/span&gt;
  &lt;span class=&#34;nx&#34;&gt;starvationThresholdNs&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mf&#34;&gt;1e6&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1645951599/mutex-2.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;lock方法&#34;&gt;Lock方法&lt;/h3&gt;
&lt;p&gt;首先看&lt;code&gt;Lock()&lt;/code&gt;方法：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;m&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Mutex&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;Lock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;c1&#34;&gt;// 通过atomic提供的CAS原子操作
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;c1&#34;&gt;// 如果m.state是0，表示当前锁是空闲的
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;c1&#34;&gt;// 可以获取到锁，把自己的状态设为mutexLocked（state=1）
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;atomic&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;CompareAndSwapInt32&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;state&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;mutexLocked&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;race&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Enabled&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
      &lt;span class=&#34;nx&#34;&gt;race&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Acquire&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;unsafe&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Pointer&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt;
  &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
  &lt;span class=&#34;c1&#34;&gt;// 当前锁被持有，调用lockSlow，尝试通过自旋竞争或者饥饿goroutine竞争
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;nx&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;lockSlow&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;如果不能直接抢到锁就切换为&lt;code&gt;lockSlow&lt;/code&gt;的方法获取锁：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;30
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;31
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;32
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;33
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;34
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;35
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;36
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;37
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;38
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;39
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;40
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;41
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;42
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;43
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;44
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;45
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;46
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;47
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;48
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;49
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;50
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;51
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;52
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;53
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;54
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;55
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;56
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;57
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;58
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;59
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;60
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;61
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;62
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;63
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;64
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;65
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;66
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;67
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;68
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;69
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;70
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;71
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;72
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;73
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;74
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;75
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;76
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;77
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;78
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;79
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;80
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;81
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;82
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;83
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;84
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;85
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;86
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;87
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;88
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;89
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;90
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;91
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;92
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;93
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;94
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;95
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;m&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Mutex&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;lockSlow&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;c1&#34;&gt;// 请求的初始时间
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;kd&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;waitStartTime&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int64&lt;/span&gt;
  &lt;span class=&#34;c1&#34;&gt;// 饥饿标记
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;nx&#34;&gt;starving&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;false&lt;/span&gt;
  &lt;span class=&#34;c1&#34;&gt;// 唤醒标记
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;nx&#34;&gt;awoke&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;false&lt;/span&gt;
  &lt;span class=&#34;c1&#34;&gt;// 自旋次数
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;nx&#34;&gt;iter&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;
  &lt;span class=&#34;c1&#34;&gt;// 当前锁的状态
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;nx&#34;&gt;old&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;state&lt;/span&gt;
  &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;// 锁未被释放，且非饥饿状态，尝试自旋
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;// 这里为了效率用的位运算，不过会难读一点
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;// mutexLocked = 1，mutexStarving = 100，mutexLocked|mutexStarving = 101
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;// old &amp;amp; 101 == 1，也就是说old是0?1，也就是说是locked状态，而且非饥饿
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;old&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;mutexLocked&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;|&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;mutexStarving&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;mutexLocked&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;runtime_canSpin&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;iter&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
      &lt;span class=&#34;c1&#34;&gt;// 一直自旋，直到发现锁被释放，awoke设为true，唤醒
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;      &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;!&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;awoke&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;old&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;mutexWoken&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;old&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;mutexWaiterShift&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt;
        &lt;span class=&#34;nx&#34;&gt;atomic&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;CompareAndSwapInt32&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;state&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;old&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;old&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;|&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;mutexWoken&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;nx&#34;&gt;awoke&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;true&lt;/span&gt;
      &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
      &lt;span class=&#34;c1&#34;&gt;// 否则就自旋
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;      &lt;span class=&#34;nf&#34;&gt;runtime_doSpin&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
      &lt;span class=&#34;c1&#34;&gt;// 自旋迭代次数+1
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;      &lt;span class=&#34;nx&#34;&gt;iter&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++&lt;/span&gt;
      &lt;span class=&#34;c1&#34;&gt;// 更新状态到old里
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;      &lt;span class=&#34;nx&#34;&gt;old&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;state&lt;/span&gt;
      &lt;span class=&#34;k&#34;&gt;continue&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

    &lt;span class=&#34;nx&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;old&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;// 如果old状态非饥饿，就设置为上锁状态
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;old&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;mutexStarving&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
      &lt;span class=&#34;c1&#34;&gt;// |=位运算，可以将mutexLocked位置置1，也就是加锁
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;      &lt;span class=&#34;nx&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;|=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;mutexLocked&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;// 如果mutex状态是饥饿，那新来的goroutine直接插入队尾，不会自旋也不会抢锁
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;old&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;mutexLocked&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;|&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;mutexStarving&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
      &lt;span class=&#34;c1&#34;&gt;// 等待者数量+1
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;      &lt;span class=&#34;nx&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;mutexWaiterShift&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;// 如果当前没上锁，而且处于饥饿状态，就设置为饥饿状态
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;starving&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;old&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;mutexLocked&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
      &lt;span class=&#34;nx&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;|=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;mutexStarving&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;// 如果被唤醒了
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;awoke&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
      &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;new&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;mutexWoken&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;nf&#34;&gt;throw&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;sync: inconsistent mutex state&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
      &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
      &lt;span class=&#34;c1&#34;&gt;// 新状态清除唤醒标记
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;      &lt;span class=&#34;nx&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;^=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;mutexWoken&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;// 成功设置新状态
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;atomic&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;CompareAndSwapInt32&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;state&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;old&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;new&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
      &lt;span class=&#34;c1&#34;&gt;// 正常请求到了锁，结束循环
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;      &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;old&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;mutexLocked&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;|&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;mutexStarving&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;break&lt;/span&gt;
      &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
      &lt;span class=&#34;c1&#34;&gt;// 如果之前就在队列里，就加入到队列头
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;      &lt;span class=&#34;nx&#34;&gt;queueLifo&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;waitStartTime&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;
      &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;waitStartTime&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;nx&#34;&gt;waitStartTime&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;runtime_nanotime&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
      &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
      &lt;span class=&#34;c1&#34;&gt;// 阻塞等待
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;      &lt;span class=&#34;nf&#34;&gt;runtime_SemacquireMutex&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;sema&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;queueLifo&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
      &lt;span class=&#34;c1&#34;&gt;// 唤醒之后检查是否应该处于饥饿状态
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;      &lt;span class=&#34;nx&#34;&gt;starving&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;starving&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;||&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;runtime_nanotime&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;waitStartTime&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;starvationThresholdNs&lt;/span&gt;
      &lt;span class=&#34;nx&#34;&gt;old&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;state&lt;/span&gt;
      &lt;span class=&#34;c1&#34;&gt;// 如果饥饿
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;      &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;old&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;mutexStarving&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;old&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;mutexLocked&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;|&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;mutexWoken&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;||&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;old&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;mutexWaiterShift&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
          &lt;span class=&#34;nf&#34;&gt;throw&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;sync: inconsistent mutex state&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
        &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
        &lt;span class=&#34;c1&#34;&gt;// 加锁并将等待者数量-1
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;nx&#34;&gt;delta&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;int32&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;mutexLocked&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;mutexWaiterShift&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;!&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;starving&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;||&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;old&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;mutexWaiterShift&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
          &lt;span class=&#34;c1&#34;&gt;// 退出饥饿模式
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;          &lt;span class=&#34;nx&#34;&gt;delta&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;mutexStarving&lt;/span&gt;
        &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
        &lt;span class=&#34;nx&#34;&gt;atomic&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;AddInt32&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;state&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;delta&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;break&lt;/span&gt;
      &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
      &lt;span class=&#34;nx&#34;&gt;awoke&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;true&lt;/span&gt;
      &lt;span class=&#34;nx&#34;&gt;iter&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;else&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
      &lt;span class=&#34;nx&#34;&gt;old&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;state&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
  &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

  &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;race&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Enabled&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;nx&#34;&gt;race&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Acquire&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;unsafe&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Pointer&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt;
  &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h3 id=&#34;unlock方法&#34;&gt;Unlock方法&lt;/h3&gt;
&lt;p&gt;Unlock比Lock的代码稍微简单一点&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;m&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Mutex&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;Unlock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;race&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Enabled&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;nx&#34;&gt;_&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;state&lt;/span&gt;
    &lt;span class=&#34;nx&#34;&gt;race&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Release&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;unsafe&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Pointer&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt;
  &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
  &lt;span class=&#34;c1&#34;&gt;// 去掉锁标志
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;nx&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;atomic&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;AddInt32&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;state&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;mutexLocked&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
  &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;nx&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;unlockSlow&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;new&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
  &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;m&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Mutex&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;unlockSlow&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int32&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;c1&#34;&gt;// 没有加锁的情况下释放了锁，报错
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;c1&#34;&gt;// 也就是此时new=-1，new+mutexLocked=0，(new+mutexLocked)&amp;amp;mutexLocked = 0
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;new&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;mutexLocked&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;mutexLocked&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;nf&#34;&gt;throw&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;sync: unlock of unlocked mutex&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
  &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
  &lt;span class=&#34;c1&#34;&gt;// 如果不是饥饿状态的话
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;new&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;mutexStarving&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;nx&#34;&gt;old&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;new&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
      &lt;span class=&#34;c1&#34;&gt;// 如果没有等待者了，可以直接返回
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;      &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;old&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;mutexWaiterShift&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;||&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;old&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;mutexLocked&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;|&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;mutexWoken&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;|&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;mutexStarving&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt;
      &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
      &lt;span class=&#34;c1&#34;&gt;// 有等待者的话，并且当前没有唤醒的等待者，就唤醒一个
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;      &lt;span class=&#34;nx&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;old&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;mutexWaiterShift&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;|&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;mutexWoken&lt;/span&gt;
      &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;atomic&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;CompareAndSwapInt32&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;state&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;old&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;new&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;nf&#34;&gt;runtime_Semrelease&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;sema&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;false&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt;
      &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
      &lt;span class=&#34;nx&#34;&gt;old&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;state&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
  &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;else&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;// 如果是饥饿状态，直接交给下一个等待者，新来的goroutine不会获得锁
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;nf&#34;&gt;runtime_Semrelease&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;sema&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;true&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
  &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h2 id=&#34;mutex的易错场景&#34;&gt;Mutex的易错场景&lt;/h2&gt;
&lt;h3 id=&#34;lock和unlock不成对出现&#34;&gt;Lock和Unlock不成对出现&lt;/h3&gt;
&lt;p&gt;如果只有Lock没有Unlock，那么永远都无法解锁，造成死锁，全部饿死。&lt;/p&gt;
&lt;p&gt;如果没有Lock就Unlock，则会panic。&lt;/p&gt;
&lt;p&gt;最不要在前面Lock，在if里Unlock，逻辑复杂的时候容易出问题。&lt;/p&gt;
&lt;p&gt;最好是&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;nx&#34;&gt;mu&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Lock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;defer&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;mu&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Unlock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h3 id=&#34;复制mutex&#34;&gt;复制mutex&lt;/h3&gt;
&lt;p&gt;Mutex不可以被复制，它的state包含状态，在并发的环境下根本不知道当前状态是什么，如果要一个新的Mutex就new一个初始化为0的Mutex。&lt;/p&gt;
&lt;h3 id=&#34;重入&#34;&gt;重入&lt;/h3&gt;
&lt;p&gt;锁的重入指的是重复加锁，比如一个线程获取到了锁，之后其他线程获取这个锁只能阻塞，此时如果这个线程又获取一次这个锁，那么会直接成功返回，这样的锁就是可重入锁。&lt;/p&gt;
&lt;p&gt;但是&lt;strong&gt;Mutex不是可重入锁&lt;/strong&gt;，所以不可以重入，因为Mutex并没有记录哪个goroutine拥有了这把锁。&lt;/p&gt;
&lt;p&gt;当然如果要把go的Mutex改造成可重入的也很简答，只要建立一个结构体，封装Mutex、goroutine的标识、重入次数，&lt;/p&gt;
&lt;p&gt;goroutine的标识可以采用goroutine id，或者自己生成一个唯一的token。&lt;/p&gt;
&lt;h2 id=&#34;mutex拓展&#34;&gt;Mutex拓展&lt;/h2&gt;
&lt;p&gt;理解好源码之后，可以开发一些拓展功能。&lt;/p&gt;
&lt;p&gt;比如发现锁被占用了直接reture false而不是排队阻塞，比如获取等待者的数量，直接通过unsafe把state字段里的等待者数量抽出来。&lt;/p&gt;
&lt;p&gt;还可以通过引入Mutex实现线程安全的各种数据结构。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1645951622/mutex-1.png&#34; alt=&#34;mutex-1&#34;&gt;&lt;/p&gt;
</content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://yichengme.site/categories/%E6%8A%80%E6%9C%AF/" term="技术" label="技术" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://yichengme.site/tags/golang/" term="Golang" label="Golang" />
                            
                        
                            
                            
                            
                                <category scheme="https://yichengme.site/tags/%E5%B9%B6%E5%8F%91/" term="并发" label="并发" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">Go并发（一）：并发的基本概念</title>
            <link rel="alternate" type="text/html" href="https://yichengme.site/posts/go-concurrency-1-introduction/" />
            <id>https://yichengme.site/posts/go-concurrency-1-introduction/</id>
            <updated>2022-03-02T19:00:37&#43;08:00</updated>
            <published>2021-01-24T23:46:26&#43;08:00</published>
            <author>
                    <name>王毅诚</name>
                    <uri>https://yichengme.site/</uri>
                    <email>engine74396@gmail.com</email>
                    </author>
            <rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">写在前面 Go语言最有魅力的一个方面就在于它内建的并发支持，Go的并发所涉及的内容化很多，预计会占用比较长的篇幅。等基本更新完成后会在此处放上所有文章的链接。 首先……</summary>
            
                <content type="html">&lt;h2 id=&#34;写在前面&#34;&gt;写在前面&lt;/h2&gt;
&lt;p&gt;Go语言最有魅力的一个方面就在于它内建的并发支持，Go的并发所涉及的内容化很多，预计会占用比较长的篇幅。等基本更新完成后会在此处放上所有文章的链接。
首先会从一些基本概念入手，之后会谈谈基本并发原语和go的并发原子操作，实际上就是尽量完整的剖析&lt;code&gt;sync&lt;/code&gt;这个包下的所有内容，会尽量附带着源码讲，这部分很值得研究。&lt;/p&gt;
&lt;p&gt;接着是最重要的goroutine，以及channel、Context等内容，会提到一些进阶写法和容易错的点。&lt;/p&gt;
&lt;p&gt;最后会尽量深入的讲一下底层的CSP模型、线程调度MPG模型等，从而对Go并发有更深入的理解。&lt;/p&gt;
&lt;p&gt;参考资料来源于国内外的书籍、博客、课程、论坛等，主线参考鸟窝的Go并发编程实战课，在此基础上细化了知识点，并增加了自身对相关源码和实际使用的理解。&lt;/p&gt;
&lt;h2 id=&#34;从并发谈起&#34;&gt;从并发谈起&lt;/h2&gt;
&lt;h3 id=&#34;什么是并发&#34;&gt;什么是并发？&lt;/h3&gt;
&lt;p&gt;并发（Concurrent）指的是在一个时间间隔内可以处理多个任务；与之相对的概念是顺序（Sequential），即多个任务只能按顺序完成。&lt;/p&gt;
&lt;p&gt;另一个容易混淆的概念是并行（Parallel），并行指的是在一个时刻内可以同时处理多个事件；与之相对的概念是串行（Serial），指的是物理上只能一个一个任务的执行，一个瞬间最多只能有一个任务在执行。&lt;/p&gt;
&lt;p&gt;并发：宏观同时，微观轮换
并行：宏观微观都是同时进行&lt;/p&gt;
&lt;p&gt;单核多线程：并发、串行
多核多线程：并发、并行&lt;/p&gt;
&lt;p&gt;Erlang 之父 Joe Armstrong画的一张排队使用咖啡机的场景生动的表示了并发与并行的区别。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://pic4.zhimg.com/80/v2-674f0d37fca4fac1bd2df28a2b78e633_720w.jpg?source=1940ef5c&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;为什么要并发&#34;&gt;为什么要并发？&lt;/h3&gt;
&lt;p&gt;并发可以有效的利用多个CPU核心，从而大大提高程序的执行效率。&lt;/p&gt;
&lt;p&gt;并发程序可以更好地处理复杂业务，进行多任务拆分、简化任务调度、同步执行任务。&lt;/p&gt;
&lt;p&gt;当然并发也会引入额外的复杂度和风险，可能会带来不一致、死锁、饥饿、安全性等问题，而且并发程序难以调试，可能会出现诡异的结果。&lt;/p&gt;
&lt;h3 id=&#34;并发导致的数据竞争&#34;&gt;并发导致的数据竞争&lt;/h3&gt;
&lt;p&gt;两个或多个goroutine在没有同步措施的情况下读写同一个共享资源时，会出现数据竞争的情况。无法知晓几个goroutine代码运行的先后顺序，从而导致可能产生多种结果。&lt;/p&gt;
&lt;p&gt;举一个具体的例子：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;nx&#34;&gt;data&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;go&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;// 1
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;nx&#34;&gt;data&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}()&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;// 2
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;data&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;// 3
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;nx&#34;&gt;fmt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Println&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;data&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;由于开启了一个并发的协程，完全不知道1会在2之前还是2-3之间还是3之后执行，所以输出也不确定。&lt;/p&gt;
&lt;p&gt;如何解决这一问题？&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;设置等待时间（不推荐）&lt;/li&gt;
&lt;li&gt;加锁&lt;/li&gt;
&lt;li&gt;channel
...&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;操作的原子性&#34;&gt;操作的原子性&lt;/h3&gt;
&lt;p&gt;如果一件事是原子的，那么我们说它就是并发安全的，Go有单独的包&lt;code&gt;sync/atomic&lt;/code&gt;包含了语言支持的原子操作。&lt;/p&gt;
&lt;p&gt;将在后面单独写一篇来介绍Go并发原子操作，这里暂时跳过。&lt;/p&gt;
&lt;h2 id=&#34;死锁活锁与饥饿&#34;&gt;死锁、活锁与饥饿&lt;/h2&gt;
&lt;h3 id=&#34;死锁&#34;&gt;死锁&lt;/h3&gt;
&lt;p&gt;死锁是并发中一个绕不开的话题，操作系统中学过导致死锁的四个条件：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;互斥条件&lt;/li&gt;
&lt;li&gt;请求和保持条件&lt;/li&gt;
&lt;li&gt;不剥夺条件&lt;/li&gt;
&lt;li&gt;环路等待条件&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;并发编程的时候很容易出现死锁的问题，看到这种报错信息：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;nx&#34;&gt;fatal&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;error&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;all&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;goroutines&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;are&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;asleep&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;deadlock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;!&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h3 id=&#34;活锁&#34;&gt;活锁&lt;/h3&gt;
&lt;p&gt;陷入活锁的程序并不像死锁一样陷入绝境，而是一直在进行，但是这些操作无法向前推进程序的状态。&lt;/p&gt;
&lt;p&gt;一个例子就是网络发送数据包遇到冲突，都等待一段时间重发，结果由一起冲突。&lt;/p&gt;
&lt;p&gt;这就像两个礼貌的司机在狭窄的桥上相遇，他们都互相礼让都调头更换了另一座桥，结果又在另一座桥上相遇。&lt;/p&gt;
&lt;h3 id=&#34;饥饿&#34;&gt;饥饿&lt;/h3&gt;
&lt;p&gt;饥饿指的是一个可运行的进程尽管能继续执行，但是被调度器无限忽视，导致拿不到时间片来执行的情况。&lt;/p&gt;
&lt;p&gt;并发进程无法获得执行工作所需的所有资源。往往是由于一些并发进程比较贪婪，每次都轮到贪婪进程优先获得资源，而其他的一些难以拿到资源的进程就会饥饿。&lt;/p&gt;
&lt;h2 id=&#34;数据竞争的检测方法race&#34;&gt;数据竞争的检测方法：race&lt;/h2&gt;
&lt;p&gt;多个goroutine同时操作共有的变量会发生各种意想不到的问题，可以通过&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;k&#34;&gt;go&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;run&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;race&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;xxx&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;go&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;来查看可能的竞态检测。&lt;/p&gt;
&lt;p&gt;就以前面的为例：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;kn&#34;&gt;package&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;main&lt;/span&gt;

&lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;
	&lt;span class=&#34;s&#34;&gt;&amp;#34;fmt&amp;#34;&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;data&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;go&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;data&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}()&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;data&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;fmt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Println&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;data&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;如果直接&lt;code&gt;go run&lt;/code&gt;，无法看出是否有数据竞争，但是通过&lt;code&gt;go run -race&lt;/code&gt;，就可以看到具体那几行出现了数据竞争：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;o&#34;&gt;==================&lt;/span&gt;
&lt;span class=&#34;nx&#34;&gt;WARNING&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;DATA&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;RACE&lt;/span&gt;
&lt;span class=&#34;nx&#34;&gt;Write&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;at&lt;/span&gt; &lt;span class=&#34;mh&#34;&gt;0x00c00012e058&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;by&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;goroutine&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;7&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
  &lt;span class=&#34;nx&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;func1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
      &lt;span class=&#34;nx&#34;&gt;C&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Users&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Administrator&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Dropbox&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;GoProject&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Concurrency&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;go&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;10&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mh&#34;&gt;0x5a&lt;/span&gt;

&lt;span class=&#34;nx&#34;&gt;Previous&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;read&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;at&lt;/span&gt; &lt;span class=&#34;mh&#34;&gt;0x00c00012e058&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;by&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;main&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;goroutine&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
  &lt;span class=&#34;nx&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
      &lt;span class=&#34;nx&#34;&gt;C&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Users&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Administrator&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Dropbox&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;GoProject&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Concurrency&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;go&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;12&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mh&#34;&gt;0x92&lt;/span&gt;

&lt;span class=&#34;nx&#34;&gt;Goroutine&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;7&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;running&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;created&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;at&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
  &lt;span class=&#34;nx&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
      &lt;span class=&#34;nx&#34;&gt;C&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Users&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Administrator&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Dropbox&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;GoProject&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Concurrency&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;go&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;9&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mh&#34;&gt;0x84&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;==================&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;就说了第10行goroutine7的&lt;code&gt;data++&lt;/code&gt;和第12行main goroutine的&lt;code&gt;if data == 0&lt;/code&gt;出现了数据竞争的情况。而且说明了goroutine7是第9行启动的。&lt;/p&gt;
&lt;p&gt;一般会在测试的时候使用&lt;code&gt;go -race&lt;/code&gt;进行数据竞争的检测，从而调整代码，尽量避免数据竞争的发生。&lt;/p&gt;
&lt;p&gt;当然还有一个问题，因为是编译完之后才能通过具体地址检测的，即使某个地方可能会有冲突但是运行的时候没有表现出来，race也检测不到。&lt;/p&gt;
</content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://yichengme.site/categories/%E6%8A%80%E6%9C%AF/" term="技术" label="技术" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://yichengme.site/tags/golang/" term="Golang" label="Golang" />
                            
                        
                            
                            
                            
                                <category scheme="https://yichengme.site/tags/%E5%B9%B6%E5%8F%91/" term="并发" label="并发" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">生存分析基础</title>
            <link rel="alternate" type="text/html" href="https://yichengme.site/posts/survival-analysis-basic/" />
            <id>https://yichengme.site/posts/survival-analysis-basic/</id>
            <updated>2022-02-27T15:21:54&#43;08:00</updated>
            <published>2020-12-23T15:23:00&#43;08:00</published>
            <author>
                    <name>王毅诚</name>
                    <uri>https://yichengme.site/</uri>
                    <email>engine74396@gmail.com</email>
                    </author>
            <rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">背景与简介 在生物医学、金融保险等领域，生存分析是一种很常见而且重要的方法。 生存分析主要用在癌症等疾病的研究中，比如对某种抗癌药物做临床试验，筛选一部分癌症患者，……</summary>
            
                <content type="html">&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1640248844/survival-analysis-0.png&#34; alt=&#34;survival-analysis-1&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;背景与简介&#34;&gt;背景与简介&lt;/h2&gt;
&lt;p&gt;在生物医学、金融保险等领域，生存分析是一种很常见而且重要的方法。&lt;/p&gt;
&lt;p&gt;生存分析主要用在癌症等疾病的研究中，比如对某种抗癌药物做临床试验，筛选一部分癌症患者，分为两组，一组服用该试验药物，一组服用对照药物，服药后开始统计每个患者从服药一直到死亡的生存时间。&lt;/p&gt;
&lt;p&gt;生存分析可以抽象概述为，研究在不同条件下，特定事件发生与时间的关系是否存在差异。这些具体事件可以是死亡，也可以是痊愈、肿瘤转移、复发、出院、重新入院等任何可以明确识别的事件，而不同条件即为不同的分组依据，可以是年龄、性别、地域、某个基因表达量的高低、某个突变的携带与否等等。&lt;/p&gt;
&lt;p&gt;（后面均用&amp;quot;死亡&amp;quot;来代指这个特定事件&lt;/p&gt;
&lt;h2 id=&#34;概念与推导&#34;&gt;概念与推导&lt;/h2&gt;
&lt;h3 id=&#34;生存时间t&#34;&gt;生存时间T&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1640248843/surv-time-1.png&#34; alt=&#34;survival-time&#34;&gt;&lt;/p&gt;
&lt;p&gt;把生存时间作为一个随机变量，用PDF（概率密度函数）和CDF（分布函数）来表达&lt;/p&gt;
&lt;p&gt;其中CDF为$F(t) = Pr(T &amp;lt; t)$，也就是t之前死亡的概率&lt;/p&gt;
&lt;h3 id=&#34;生存概率&#34;&gt;生存概率&lt;/h3&gt;
&lt;p&gt;S(t)，Survival probability，研究对象从试验开始到某个特定时间点仍然存活的概率,$S(t) = pr(T &amp;gt; t)$&lt;/p&gt;
&lt;p&gt;$S(t) = 1 - F(t)$&lt;/p&gt;
&lt;p&gt;之后的Kaplan-Meier模型主要关注S(t)&lt;/p&gt;
&lt;h3 id=&#34;风险概率&#34;&gt;风险概率&lt;/h3&gt;
&lt;p&gt;$h(t): \text{Hazard function}$&lt;/p&gt;
&lt;p&gt;$$h(t) = \lim_{\epsilon \to 0}\frac{P(T \in (t, t+\epsilon] | T \geqslant t)}{\epsilon} = \frac{f(t)}{S(t)}$$&lt;/p&gt;
&lt;p&gt;前一个等号的意义 很明显，表示的意义就是研究对象从试验开始到某个特定时间点t之前存活，但是在t时间点发生&amp;quot;死亡&amp;quot;的概率&lt;/p&gt;
&lt;p&gt;后面一个等号的推导过程&lt;/p&gt;
&lt;p&gt;$$
\begin{array}{llr}
h(t)&amp;amp; = \lim_{\Delta t \to 0} \frac{P(t &amp;lt; T \leqslant t + \Delta t | T &amp;gt; t)}{\Delta t}\newline
&amp;amp; = \lim_{\Delta t \to 0} \frac{P(t &amp;lt; T \leqslant t + \Delta t )}{\Delta t S(t)} &amp;amp; \scriptsize{S(t)的定义}\newline
&amp;amp; = \lim_{\Delta t \to 0} \frac{F(t + \Delta t) - F(t)}{\Delta t S(t)} &amp;amp; \scriptsize{F(t)的定义}\newline
&amp;amp; = \frac{f(t)}{S(t)}&amp;amp;  \scriptsize{f(t)是F(t)的微分}
\end{array}
$$&lt;/p&gt;
&lt;p&gt;然后还可以进一步推导：&lt;/p&gt;
&lt;p&gt;$$
h(t) = \frac{f(t)}{S(t)} = \frac{f(t)}{1 - F(t)} = - \frac{\partial log[1 - F(t)]}{\partial t} = - \frac{\partial log[S(t)]}{\partial t}
$$&lt;/p&gt;
&lt;p&gt;表示了$h(t)$和$S(t)$的关系&lt;/p&gt;
&lt;p&gt;$H(t): \text{Comulative\ Hazard\ function}$
 
$$H(t) = \int_0^t h(u) du$$&lt;/p&gt;
&lt;p&gt;进一步推导：
$$H(t) = \int_0^t h(u) du = - \int_0^t \frac{ \partial log[S(u)]}{\partial u} du = -log[S(t)]$$&lt;/p&gt;
&lt;p&gt;$$\to S(t) = exp[-H(t)]$$&lt;/p&gt;
&lt;p&gt;之后的Cox比例风险模型主要关注H(t)&lt;/p&gt;
&lt;h2 id=&#34;hazard-function理解&#34;&gt;Hazard function理解&lt;/h2&gt;
&lt;p&gt;hazard function 本身不是概率，它描述的是一种在给定时间点的风险，$\Delta t \times h(t)$表示在$(t, t + \Delta t]$的概率&lt;/p&gt;
&lt;p&gt;hazard function优势：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;描述给定时间点的风险，这是我们需要的信息&lt;/li&gt;
&lt;li&gt;可以很好的处理数据缺失的情况&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;举个例子&#34;&gt;举个例子&lt;/h2&gt;
&lt;p&gt;假设survival time服从指数分布$Exp(\lambda)$，即$f(x) = \lambda e ^{-\lambda x}, x &amp;gt; 0$&lt;/p&gt;
&lt;p&gt;也就是$f(t) = \lambda e ^{-\lambda x}$&lt;/p&gt;
&lt;p&gt;可以推出：&lt;/p&gt;
&lt;p&gt;$F(t) = 1 - e ^{-\lambda x}$&lt;/p&gt;
&lt;p&gt;$S(t) = 1 - F(t) = e ^{-\lambda x}$&lt;/p&gt;
&lt;p&gt;$h(t) = \frac{f(t)}{S(t)} = \lambda$&lt;/p&gt;
&lt;p&gt;$H(t) = \lambda t$&lt;/p&gt;
&lt;p&gt;$E(T) = \frac{1}{\lambda} （指数分布的性质）= \frac{1}{h(t)}$&lt;/p&gt;
&lt;p&gt;其他的分布同理
Gamma distribution
Weibull distribution
Log-normal distribution
generized gamma distribution...&lt;/p&gt;
&lt;h2 id=&#34;删失数据-censoring&#34;&gt;删失数据 Censoring&lt;/h2&gt;
&lt;p&gt;生存分析中，很常见的一种特征就是删失数据&lt;/p&gt;
&lt;p&gt;指的是在临床试验中，出现一些数据丢失的情况，比如病人中途主动退出、无法联系到、结束时还未发生特定事件。保留了从一开始到丢失前进度的数据成为右删失，另一种称为左删失。（后面只讨论右删失）&lt;/p&gt;
&lt;h3 id=&#34;type-i-censoring观测时间确定&#34;&gt;Type I Censoring：观测时间确定&lt;/h3&gt;
&lt;p&gt;每一项数据增加一个表示：&lt;/p&gt;
&lt;p&gt;$$(U_i, \delta_i) = {min (T_i, c), I(T_i \leqslant c)}, i = 1, ... , n$$&lt;/p&gt;
&lt;p&gt;$$I(T_i \leqslant C) = \begin{cases}
1, &amp;amp; T_i \leqslant C,\
0, &amp;amp; T_i &amp;gt; C
\end{cases}$$&lt;/p&gt;
&lt;p&gt;c是实验时间，是一个常量
也就是说如果是$(c, 0)$，则代表被删失，如果是$(T_i, 1)$，则没有被删失&lt;/p&gt;
&lt;h3 id=&#34;type-ii-censoring观测人数确定&#34;&gt;Type II Censoring：观测人数确定&lt;/h3&gt;
&lt;p&gt;比如观测n人，当死亡r人时停止试验
$T_{(1, n)}, T_{(2, n)}, ..., T_{(r, n)}$&lt;/p&gt;
&lt;h3 id=&#34;type-iii-censoring随机censoring&#34;&gt;Type III Censoring：随机Censoring&lt;/h3&gt;
&lt;p&gt;不用常量c而是用随机变量$C_i$&lt;/p&gt;
&lt;p&gt;$(U_i, \delta_i) = {min (T_i, C_i), I(T_i \leqslant C_i)}, i = 1, ... , n$&lt;/p&gt;
&lt;p&gt;只考虑右删失，我们只观察$(U_i, \delta_i)$
如果$(U_i, \delta_i) = (u_i, 1)$，则说明$T_i = u_i, C_i &amp;gt; u_i$
如果$(U_i, \delta_i) = (u_i, 0)$，则说明$T_i \geqslant u_i, C_i = u_i$&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1640245124/survival-analysis-2.png&#34; alt=&#34;survival-analysis-2&#34;&gt;&lt;/p&gt;
&lt;p&gt;(推导见https://www.bilibili.com/video/BV1WE411P78Z?p=2)&lt;/p&gt;
&lt;h2 id=&#34;kaplan-meier模型&#34;&gt;Kaplan-Meier模型&lt;/h2&gt;
&lt;p&gt;与生存表、Cox并列的一种生存分析的方法，也叫乘积极限(product-limit estimator)&lt;/p&gt;
&lt;p&gt;$\hat{S}(t)=\prod_{i: t_{i} \leq t}\left(1-\frac{d_{i}}{n_{i}}\right), \quad t \geq 0$&lt;/p&gt;
&lt;p&gt;$d_i$是在$t_i$时刻死亡的人数，$n_i$是还在风险中的人数&lt;/p&gt;
&lt;p&gt;例子：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1640245203/survival-analysis-example-1.png&#34; alt=&#34;survival-analysis-example-1&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;life-table-生存表&#34;&gt;Life table 生存表&lt;/h3&gt;
&lt;p&gt;举例：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1640245336/life-table-1.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;设时间点为$t_0, t_1, ... ,t_n$，那么在$t_i$时间点下的生存概率：
$$S(t_i) = \Pi_{j=0}^{i}(1-P(t_j死亡))$$&lt;/p&gt;
&lt;p&gt;也就是：
$$S\left(t_{i}\right)=S\left(t_{i-1}\right)\left(1-\frac{d_{i}}{n_{i}}\right)$$&lt;/p&gt;
&lt;p&gt;$n_i$表示$t_i$时的有效人数，$d_i$表示$t_i$时的死亡人数&lt;/p&gt;
&lt;p&gt;$t_i$处的生存率等于$t_{i-1}$时的生存率乘以（1-$t_i$时间点的死亡率）&lt;/p&gt;
&lt;h3 id=&#34;kaplan-meier-生存曲线&#34;&gt;Kaplan-Meier 生存曲线：&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1640245508/km-curve-1.png&#34; alt=&#34;&#34;&gt;
加号表示删失数据&lt;/p&gt;
&lt;p&gt;往往是多条线（因为是不同的组）&lt;/p&gt;
&lt;h2 id=&#34;cox比例风险回归模型&#34;&gt;Cox比例风险回归模型&lt;/h2&gt;
&lt;p&gt;Cox Proportional-Hazards Model是由英国统计学家D.R.Cox于1972年提出的一种半参数回归模型（半参数值既包含参数模型，又包含非参数模型）&lt;/p&gt;
&lt;p&gt;参数模型：有限维度，有限个参数就可以表示模型分布，比如正态分布的均值和标准差
非参数模型：属于某个无限维的空间，无法用有限个参数来表示，比如决策树、随机森林&lt;/p&gt;
&lt;p&gt;Cox建立回归的是前面提到的$h(x)$
Cox模型：
$$h(t) = h_0(t) \times exp({b_1x_1 + b_2x_2 + ... b_px_p})$$&lt;/p&gt;
&lt;p&gt;其中$h(t)$指的是不同时间的风险值（hazard），$x_i$指的是具有预测效应的变量，$b_i$指的是每个变量对应的效应值，$h_0(t)$是基准风险函数，根据不同的数据来使用不同的分布模型，是非参数模型&lt;/p&gt;
&lt;p&gt;建模时，首先确定需要研究的可能影响生存率的因素，也就是$x_i$，我们主要要做的就是找到合适的$h_0(t)$以及所有协变量的系数$b_p$，需要用到极大似然估计等方法求解参数。&lt;/p&gt;
&lt;h3 id=&#34;两个基本假设&#34;&gt;两个基本假设&lt;/h3&gt;
&lt;p&gt;对公式两边取对数进行变形：&lt;/p&gt;
&lt;p&gt;$$log(h(t)) = log(h_0(t)) + \beta X$$&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;模型中各危险因素对危险率的影响不随时间改变，且与时间无关&lt;/li&gt;
&lt;li&gt;对数危险率与各个危险因素呈线性相关&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;参数的极大似然估计&#34;&gt;参数的极大似然估计&lt;/h3&gt;
&lt;p&gt;通过极大似然估计来求解参数，极大似然估计的思想是，让已经发生的事件出现的可能性最大。&lt;/p&gt;
&lt;p&gt;举个例子，有三个人$X_1, X_2, X_3$分别在三个时间点$t_1, t_2, t_3$死亡&lt;/p&gt;
&lt;p&gt;以$t=t_1$为例，此时我们的目标是$max\ h(t_1, X_1)$和$min\ h(t_1, X_2) + h(t_1, X_3)$，统一这两个的目标：&lt;/p&gt;
&lt;p&gt;$$max\ \frac{h(t_1, X_1)}{h(t_1, X_1) + h(t_1, X_2) + h(t_1, X_3)}$$&lt;/p&gt;
&lt;p&gt;（分母加一个分子不影响结果，但是可以让最后一项不至于分母为0）&lt;/p&gt;
&lt;p&gt;类推得到$t_2$的目标：
$$max\ \frac{h(t_2, X_2)}{h(t_2, X_2) + h(t_2, X_3)}$$&lt;/p&gt;
&lt;p&gt;$t_3$的目标：
$$max\ \frac{h(t_3, X_3)}{h(t_3, X_3)}$$&lt;/p&gt;
&lt;p&gt;所以似然函数是：
$$L(\beta) = \frac{h(t_1, X_1)}{h(t_1, X_1) + h(t_1, X_2) + h(t_1, X_3)} \frac{h(t_2, X_2)}{h(t_2, X_2) + h(t_2, X_3)} \frac{h(t_3, X_3)}{h(t_3, X_3)}$$&lt;/p&gt;
&lt;p&gt;代入$h(x)$的公式之后消掉$h_0(t)$，得到：
$$L(\beta) = \frac{exp(\beta · X_1)}{exp(\beta · X_1) + exp(\beta · X_2) + exp(\beta · X_3)} \frac{exp(\beta · X_2)}{exp(\beta · X_2) + exp(\beta · X_3)} \frac{exp(\beta · X_3)}{exp(\beta · X_3)}$$&lt;/p&gt;
&lt;p&gt;这里我们假设的是3个事件，再泛化到N个的情况：
$$L(\beta)=\prod_{i=1}^{N} \frac{\exp \left(\beta \cdot X_{i}\right)}{\sum_{j: t_{j} \geq t_{i}} \exp \left(\beta \cdot X_{j}\right)}$$&lt;/p&gt;
&lt;p&gt;对数似然函数：
$$l(\beta)=\log L(\beta)=\sum_{i=1}^{N}\left[\beta \cdot X_{i}-\log \left(\sum_{j: t_{j} \geq t_{i}} \exp \left(\beta \cdot X_{j}\right)\right)\right]$$&lt;/p&gt;
&lt;p&gt;梯度为：
$$\frac{\partial l(\beta)}{\partial \beta}=\sum_{i=1}^{N}\left[\beta-\frac{\sum_{j: t_{j} \geq t_{i}} X_{j} \cdot \exp \left(\beta \cdot X_{j}\right)}{\sum_{j: t_{j} \geq t_{i}} \exp \left(\beta \cdot X_{j}\right)}\right]$$&lt;/p&gt;
&lt;p&gt;就可以采用梯度下降法来对参数进行估计&lt;/p&gt;
&lt;h3 id=&#34;解读结果&#34;&gt;解读结果&lt;/h3&gt;
&lt;p&gt;解得了合适的$h_0(t)$以及协变量系数之后，我们可以比较某个协变量$x_i$在不同值的时候对应的不同风险比$\frac{x_i + 1}{x_i}$。&lt;/p&gt;
&lt;p&gt;$$hazard\ ratio = \frac{h_0(t) \times e^{b_1x_1 + b_2x_2 + ...b_i(x_i+1) + ... b_px_p}}{h_0(t) \times e^{b_1x_1 + b_2x_2  + ...b_ix_i + ... b_px_p}} = e^{b_i}$$&lt;/p&gt;
&lt;p&gt;举个例子，假如某个指标$x_i$表示年龄，那么对于年龄x和年龄x+1的人来说，死亡风险比是$e^{b_i}$，如果$b_i&amp;gt;0$，则年龄增大，死亡风险增大。反之减小。等于0则是不起作用&lt;/p&gt;
</content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://yichengme.site/categories/%E6%8A%80%E6%9C%AF/" term="技术" label="技术" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://yichengme.site/tags/%E7%94%9F%E5%AD%98%E5%88%86%E6%9E%90/" term="生存分析" label="生存分析" />
                            
                        
                            
                            
                            
                                <category scheme="https://yichengme.site/tags/%E7%BB%9F%E8%AE%A1%E5%AD%A6/" term="统计学" label="统计学" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">计算机系统结构</title>
            <link rel="alternate" type="text/html" href="https://yichengme.site/posts/computer-system-structure-1/" />
            <id>https://yichengme.site/posts/computer-system-structure-1/</id>
            <updated>2022-02-27T15:21:46&#43;08:00</updated>
            <published>2020-06-04T15:05:09&#43;08:00</published>
            <author>
                    <name>王毅诚</name>
                    <uri>https://yichengme.site/</uri>
                    <email>engine74396@gmail.com</email>
                    </author>
            <rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">第一章：导论 概念部分 第一台通用电子计算机诞生于1946年 计算机技术的飞速发展得益于：计算机制造技术的发展、计算机系统结构的创新 纷纷放弃高性能转向多核，标志着系统……</summary>
            
                <content type="html">&lt;h3 id=&#34;第一章导论&#34;&gt;第一章：导论&lt;/h3&gt;
&lt;h2 id=&#34;概念部分&#34;&gt;概念部分&lt;/h2&gt;
&lt;p&gt;第一台通用电子计算机诞生于1946年&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;计算机技术的飞速发展得益于&lt;/strong&gt;：计算机制造技术的发展、计算机系统结构的创新&lt;/p&gt;
&lt;p&gt;纷纷放弃高性能转向多核，标志着系统结构的重大转折：&lt;strong&gt;从单纯依靠指令集并行转向开发线程级并行和数据集并行&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;计算机系统的层次结构&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;L6: 应用语言虚拟机&lt;/p&gt;
&lt;p&gt;L5: 高级语言虚拟机&lt;/p&gt;
&lt;p&gt;L4: 汇编语言虚拟机&lt;/p&gt;
&lt;p&gt;L3: 操作系统虚拟机&lt;/p&gt;
&lt;p&gt;L2: 传统机器级&lt;/p&gt;
&lt;p&gt;L1: 微程序机器级&lt;/p&gt;
&lt;p&gt;L1-L3通常使用解释实现（一条一条来）&lt;/p&gt;
&lt;p&gt;L4-L6通常使用翻译实现（全部翻译成下面一个低级再执行）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;计算机系统结构定义&lt;/strong&gt;：计算机系统结构是程序员所看到的计算机属性，即概念性结构与功能特性，是计算机系统的软硬件的界面&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;广义的系统结构&lt;/strong&gt;：指令结构、组成和硬件&lt;/p&gt;
&lt;p&gt;包括：指令系统、寻址方式、数据表示、寄存器定义、中断系统、工作状态的切换、存储系统、信息保护、I/O结构等&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;计算机组成&lt;/strong&gt;：计算机系统结构的逻辑实现&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;计算机实现&lt;/strong&gt;：计算机系统结构的物理实现&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一种体系结构可以有多种组成，一种组成可以有多种物理实现&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;系统结构的分类&lt;/strong&gt;
冯氏分类法：按照最大并行度（字宽×一次能处理的字数）分
Flynn分类：按指令流和数据流的多倍性分，分为以下四类：&lt;/p&gt;
&lt;p&gt;①单指令流单数据流（SISD）&lt;/p&gt;
&lt;p&gt;②单指令流多数据流（SIMD）&lt;/p&gt;
&lt;p&gt;③多指令流单数据流（MISD）&lt;/p&gt;
&lt;p&gt;④多指令流多数据流（MIMD）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;冯诺依曼结构&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;最大特点：以运算器为中心&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;虚拟机&lt;/strong&gt;：用软件实现的机器&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;系列机&lt;/strong&gt;：同一个厂家生产的具有相同系统结构但具有不同组成和实现的一系列不同型号的计算机&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;兼容机&lt;/strong&gt;：由不同厂家生产的具有相同系统结构的计算机&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;软件兼容&lt;/strong&gt;：向上兼容、向下兼容、向前兼容和向后兼容，其中向后兼容是系列机的根本特征&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;模拟&lt;/strong&gt;：用软件的方法在一台计算机上实现另一台计算机的指令集（本机要解释执行另一台机子的程序）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;仿真&lt;/strong&gt;：用一台现有计算机上的微程序去解释实现另一台计算机的指令集（本机要实现另一台机子的指令集）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;并行性&lt;/strong&gt;：包括同时性（同一时刻）和并发性（同一间隔）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;提高并行性的措施&lt;/strong&gt;：时间重叠、资源重复、资源共享&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;耦合度&lt;/strong&gt;：反应计算机之间物理连接的紧密程度和交互强弱，分为紧密耦合系统和松散耦合系统&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;计算机系统设计经常使用的4个定量原理&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;以经常性事件为重点&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Amdahl定律&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;CPU性能公式&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;程序的局部性原理&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;计算部分&#34;&gt;计算部分&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Amdahl定律&lt;/strong&gt;（P7）&lt;/p&gt;
&lt;p&gt;$加速比 = \frac{执行时间_{改进前}}{执行时间_{改进后}} = \frac{1}{（ 1 - 可改进比例 ）+ \frac{可改进比例}{部件加速比} }$
依赖于可改进比例和部件加速比&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;CPU时间&lt;/strong&gt;（P9）&lt;/p&gt;
&lt;p&gt;$CPU时间 = IC \times CPI \times 时钟周期时间$&lt;/p&gt;
&lt;p&gt;$时钟周期 = \frac{1}{f}$&lt;/p&gt;
&lt;p&gt;$MIPS速率 = \frac{f}{CPI} $&lt;/p&gt;
&lt;p&gt;执行时间和吞吐率（P11）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;性能比较&lt;/strong&gt;（P14）&lt;/p&gt;
&lt;h3 id=&#34;第二章指令集结构&#34;&gt;第二章：指令集结构&lt;/h3&gt;
&lt;h2 id=&#34;概念部分-1&#34;&gt;概念部分&lt;/h2&gt;
&lt;p&gt;区别不同指令集结构的主要因素是&lt;strong&gt;CPU中用来储存操作数的储存单元的类型&lt;/strong&gt;，因此可以把指令集结构分为&lt;strong&gt;堆栈结构&lt;/strong&gt;、&lt;strong&gt;累加器结构&lt;/strong&gt;和&lt;strong&gt;通用寄存器结构&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;寻址方式&lt;/strong&gt;：
指一种指令集结构如何确定所要访问的数据的地址&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;对指令集的基本要求&lt;/strong&gt;：
完整性、规整性、高效率和兼容性&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;指令集结构设计涉及的内容&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;① 指令集功能设计，主要由CISC和RISC两种方向&lt;/p&gt;
&lt;p&gt;② 寻址方式设计&lt;/p&gt;
&lt;p&gt;③ 操作数表示和操作数类型&lt;/p&gt;
&lt;p&gt;④ 寻址方式的表示&lt;/p&gt;
&lt;p&gt;⑤ 指令集格式的设计，变长、固定长度、混合&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;指令集三种编码格式&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;可变长度编码&lt;/p&gt;
&lt;p&gt;固定长度编码&lt;/p&gt;
&lt;p&gt;混合型编码&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;RISC遵循的原则&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;① 指令条数少而简单&lt;/p&gt;
&lt;p&gt;② 采用简单而又统一的指令格式&lt;/p&gt;
&lt;p&gt;③ 指令的执行在单个机器周期内完成&lt;/p&gt;
&lt;p&gt;④ 只有load和store能访问存储器&lt;/p&gt;
&lt;p&gt;⑤ 大多数指令采用硬连逻辑&lt;/p&gt;
&lt;p&gt;⑥ 强调优化编译器的作用&lt;/p&gt;
&lt;p&gt;⑦ 充分利用流水线&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;I类指令&lt;/strong&gt;：
load、store等&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;0-5&lt;/th&gt;
&lt;th&gt;6-10&lt;/th&gt;
&lt;th&gt;11-15&lt;/th&gt;
&lt;th&gt;16-31&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;操作码&lt;/td&gt;
&lt;td&gt;rs&lt;/td&gt;
&lt;td&gt;rt&lt;/td&gt;
&lt;td&gt;立即数&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;R类指令&lt;/strong&gt;：
ALU等&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;0-5&lt;/th&gt;
&lt;th&gt;6-10&lt;/th&gt;
&lt;th&gt;11-15&lt;/th&gt;
&lt;th&gt;16-20&lt;/th&gt;
&lt;th&gt;21-25&lt;/th&gt;
&lt;th&gt;26-31&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;操作码&lt;/td&gt;
&lt;td&gt;rs&lt;/td&gt;
&lt;td&gt;rt&lt;/td&gt;
&lt;td&gt;rd&lt;/td&gt;
&lt;td&gt;shamt&lt;/td&gt;
&lt;td&gt;funct&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;br&gt;
&lt;h3 id=&#34;第三章流水线技术&#34;&gt;第三章：流水线技术&lt;/h3&gt;
&lt;h2 id=&#34;概念部分-2&#34;&gt;概念部分&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;流水线技术的概念&lt;/strong&gt;：
把一个重复的过程分解为若干个子过程，每一个子过程用一个专门的部件来实现。多个处理过程在时间上错开依次通过各段，让每个子过程和其他过程并行，这就是流水线技术&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;流水线技术的特点&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;① 流水线把一个处理过程分解为若干个子过程，每个子过程由一个专门的功能部件来实现，依靠它们的并行工作来缩短程序的执行时间&lt;/p&gt;
&lt;p&gt;② 流水线各段时间应该尽可能相等&lt;/p&gt;
&lt;p&gt;③ 流水线的每一个功能部件的后面都要有一个缓冲存储器&lt;/p&gt;
&lt;p&gt;④ 流水线适合于大量重复的时序过程&lt;/p&gt;
&lt;p&gt;⑤ 流水线需要有通过时间和排空时间&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;流水线分类&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;单功能流水线：只能完成一种固定功能&lt;/p&gt;
&lt;p&gt;多功能流水线：可以实现不同的功能&lt;/p&gt;
&lt;p&gt;静态流水线：同一时间各段只能按照同一种功能的连接方式工作&lt;/p&gt;
&lt;p&gt;动态流水线：同一时间各段可以有不同的连接，执行多种功能&lt;/p&gt;
&lt;p&gt;部件级流水线：把运算部件分段&lt;/p&gt;
&lt;p&gt;处理机级流水线：把指令的解释执行过程分段&lt;/p&gt;
&lt;p&gt;处理机间流水线：在处理机间流水&lt;/p&gt;
&lt;p&gt;线性流水线：没有反馈回路&lt;/p&gt;
&lt;p&gt;非线性流水线：有反馈回路&lt;/p&gt;
&lt;p&gt;顺序流水线：任务流出流入的顺序一致&lt;/p&gt;
&lt;p&gt;乱序流水线：任务流出的顺序和流入的顺序可以不一样&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解决流水线瓶颈问题的方法&lt;/strong&gt;
细分瓶颈段、重复设置瓶颈段&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;经典的五段流水线划分&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一条指令的执行过程可以划分为以下五个部分：&lt;/p&gt;
&lt;p&gt;取指令周期（IF）&lt;/p&gt;
&lt;p&gt;指令译码/读寄存器（ID）&lt;/p&gt;
&lt;p&gt;执行/有效地址计算（EX）&lt;/p&gt;
&lt;p&gt;存储器访问/分支完成（MEM）&lt;/p&gt;
&lt;p&gt;写回周期（WB）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;相关的概念&lt;/strong&gt;：相关是指两条指令之间存在某种依赖关系&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;相关的分类&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;数据相关：指令之间有数据关联（有传递性）&lt;/p&gt;
&lt;p&gt;名相关：名指的是寄存器名或存储器名，数据不关联但是用了相同的名，名相关又分为反相关（一写一读）和输出相关（都写）&lt;/p&gt;
&lt;p&gt;控制相关：由分支指令引起的相关&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;流水线冲突的概念&lt;/strong&gt;：
对于具体的流水线而言，由于相关的存在，导致指令流的下一条指令不能在指定的时钟周期执行&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;流水线冲突的分类&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;结构冲突：硬件资源无法满足重叠执行的要求&lt;br&gt;
     — 消除结构冲突：气泡停顿、设置独立指令数据存储器、Cache分为指令Cache和数据Cache
数据冲突：重叠执行时需要用到前面的数据&lt;br&gt;
     — 数据冲突分为：写后读（RAW）、写后写（WAW）&lt;/p&gt;
&lt;p&gt;     — 解决数据冲突：定向技术（直接从产生的地方送到需要的地方）、通过编译器指令调度解决
控制冲突：分支指令等引起的冲突&lt;br&gt;
     — 解决控制冲突：冻结或排空流水线（最简单但是分支延迟大）、尽早判断分支是否成功（提前到ID段末尾）、软件方法&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;减少分支延迟的静态方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;预测分支失败&lt;/p&gt;
&lt;p&gt;预测分支成功&lt;/p&gt;
&lt;p&gt;延迟分支（在延迟槽中放入有用的指令，三种调度方法：从前调度、从目标处调入、从失败处调入）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;不采用单周期的原因&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;① 单周期效率低，不同指令需要的时钟周期不一样&lt;/p&gt;
&lt;p&gt;② 单周期需要重复设置部件，而多周期可以共享&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;流水寄存器的作用&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;① 将各段隔开来，使之不会相互干扰&lt;/p&gt;
&lt;p&gt;② 保存相应段的处理结果&lt;/p&gt;
&lt;p&gt;③ 向后传递后面要用到的数据或控制信息&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;流水线的实现（P82 - P90）&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;$IF/IR$&lt;/th&gt;
&lt;th&gt;$IR/EX$&lt;/th&gt;
&lt;th&gt;$EX/MEM$&lt;/th&gt;
&lt;th&gt;$MEM/WD$&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;$NPC$&lt;/td&gt;
&lt;td&gt;$NPC$&lt;/td&gt;
&lt;td&gt;$cond$&lt;/td&gt;
&lt;td&gt;$LMD$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;$IR$&lt;/td&gt;
&lt;td&gt;$A$&lt;/td&gt;
&lt;td&gt;$ALU0$&lt;/td&gt;
&lt;td&gt;$ALU0$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;$B$&lt;/td&gt;
&lt;td&gt;$B$&lt;/td&gt;
&lt;td&gt;$IR$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;$Imm$&lt;/td&gt;
&lt;td&gt;$IR$&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;$IR$&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;计算部分-1&#34;&gt;计算部分&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;吞吐率&lt;/strong&gt;：单位时间内流水线完成的任务数量&lt;/p&gt;
&lt;p&gt;$TP = \frac{n}{T_k}$&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;加速比&lt;/strong&gt;：不用流水线所用的时间和用流水线所用时间之比&lt;/p&gt;
&lt;p&gt;$S = \frac{T_s}{T_k}$&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;效率&lt;/strong&gt;：设备实际使用时间与整个运行时间之比（画图之后即为阴影面积/完整面积）&lt;/p&gt;
&lt;p&gt;易出大题（P61 例题3.1、P104 章后习题3.11）
&lt;strong&gt;务必注意题目里说的是静态流水线还是动态流水线&lt;/strong&gt;，静态流水线必须一个操作做完之后 才能开另一个功能，参见P60例3.1个P60例3.2&lt;/p&gt;
&lt;br&gt;
&lt;h3 id=&#34;第四章指令级并行&#34;&gt;第四章：指令级并行&lt;/h3&gt;
&lt;h2 id=&#34;概念部分-3&#34;&gt;概念部分&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;指令级并行概念&lt;/strong&gt;：利用流水线使指令重叠并行执行，这种指令之间潜在并行性称为指令级并行（ILP，Instruction-Level Parallelism）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;CPI&lt;/strong&gt;：（Cycles Per Instruction）每条指令所消耗的时钟周期数
&lt;strong&gt;IPC&lt;/strong&gt;：（Instructions Per Cycle）每个时钟周期完成的指令条数&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;基本程序块&lt;/strong&gt;：一段除了入口和出口之外不包含其他分支的线性代码段（就是指中间没分支）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;循环级并行&lt;/strong&gt;：让一个循环中的不同循环体并行执行&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;开发循环级并行的技术&lt;/strong&gt;：循环展开技术、采用向量指令和向量数据表示&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;指令顺序&lt;/strong&gt;：由源程序确定的在完全串行方式下指令的执行顺序&lt;/p&gt;
&lt;p&gt;正确执行程序&lt;strong&gt;必须保持的最关键的两个因素&lt;/strong&gt;：数据流（数据从其产生者指令到消费者指令的实际流动）和异常行为（无论怎么改变顺序，都不影响程序中异常的发生情况）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;指令调度&lt;/strong&gt;：通过在编译时让编译器重新组织指令顺序或者通过硬件在执行时调整指令顺序来消除冲突&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;静态调度与动态调度&lt;/strong&gt;：第三章为静态调度，第四章为动态调度，以下为二者区别：
① 静态调度发生在编译过程中，动态调度发生在运行过程中
② 动态调度相比静态有更多优点：能够处理一些编译时不明确的相关、能够套用在其他流水线上&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;精确异常和不精确异常&lt;/strong&gt;：
精确异常：发生异常时，处理机的现场和严格按程序顺序执行时的现场相同
不精确异常：发生异常时，处理机的现场和严格按程序顺序执行时的现场不同&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Tomasulo算法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;保留栈&lt;/strong&gt;：在采用Tomasulo算法的MIPS处理器浮点部件中，在运算部件的入口设置的用来保存已经流出并等待到本功能部件执行的指令
&lt;strong&gt;CDB&lt;/strong&gt;：公共数据总线&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ROB&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;动态分支预测技术&lt;/strong&gt;：根据分支指令过去的表现来预测其将来的行为
&lt;strong&gt;BHT&lt;/strong&gt;：分支历史表，用于记录相关分支指令最近几次的执行情况并根据此进行预测
&lt;strong&gt;分支目标缓冲&lt;/strong&gt;：是一种动态分支预测技术，将执行过的成功的分支指令的地址和预测的分支目标地址记录在一个硬件表中，每次取指令时比较，达到减少分支开销的作用
&lt;strong&gt;前瞻执行&lt;/strong&gt;：解决控制相关的方法，对分支指令的结果进行预测，按照这个预测结果继续后续的过程，不过指令执行的结果不是放在寄存器或存储器中，而是放在ROB缓冲器中，相应指令确认后才将结果写到寄存器或存储器
&lt;strong&gt;ROB&lt;/strong&gt;：前瞻执行缓冲器&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;多流出处理机的两种基本风格&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;超标量：一种多指令流出技术，每个时钟周期流出的指令条数不确定，但有个上限
超长指令字：一种多指令流出技术，每个时钟周期流出的指令条数是固定的，这些指令构成一条长指令或者指令包，通过编译器静态调度&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;超流水&lt;/strong&gt;
一个时钟周期内分时流出多条指令&lt;/p&gt;
&lt;h2 id=&#34;计算部分-2&#34;&gt;计算部分&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;实际CPI&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;$CPI_{流水线} = CPI_{理想} + 停顿_{结构冲突} + 停顿_{数据冲突} + 停顿_{控制冲突}$&lt;/p&gt;
&lt;br&gt;
&lt;h3 id=&#34;第五章存储系统&#34;&gt;第五章：存储系统&lt;/h3&gt;
&lt;h2 id=&#34;概念部分-4&#34;&gt;概念部分&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;人们追求的储存器特性&lt;/strong&gt;：容量大、速度快、价格低&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;走出困境的唯一方法&lt;/strong&gt;：采用多级存储层次结构&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;多级存储层次&lt;/strong&gt;：采用不同的技术实现的存储器，处在离CPU不同位置的层次上，各存储器之间一般满足包容关系，任何一层存储器中的内容都是其下一层的储存器内容的子集。目标是达到离CPU最近的存储器的速度，最远的存储器的容量。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;“Cache-主存”与“主存-辅存”的区别&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;Cache-主存层次&lt;/th&gt;
&lt;th&gt;主存-辅存层次&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;目的&lt;/td&gt;
&lt;td&gt;为了弥补主存速度的不足&lt;/td&gt;
&lt;td&gt;为了弥补主存容量的不足&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;存储管理的实现&lt;/td&gt;
&lt;td&gt;由专用硬件实现&lt;/td&gt;
&lt;td&gt;由软件实现&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;访问速度的比值&lt;/td&gt;
&lt;td&gt;几比一&lt;/td&gt;
&lt;td&gt;几万比一&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;块/页大小&lt;/td&gt;
&lt;td&gt;几十个字节&lt;/td&gt;
&lt;td&gt;几百到几千字节&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;CPU对第二级的访问方式&lt;/td&gt;
&lt;td&gt;可以直接访问&lt;/td&gt;
&lt;td&gt;均通过第一级&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;不命中时是否切换&lt;/td&gt;
&lt;td&gt;不切换&lt;/td&gt;
&lt;td&gt;切换到其他进程&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;映像规则&lt;/strong&gt;
全相联映像：主存中的任意一块可以被放置到Cache中的任意一个位置，空间利用率最高、冲突概率最低、实现最复杂
直接映像：    主存中的每一块只能被放到Cache中唯一的位置，空间利用率最低、冲突概率最高、实现最简单
组相联映像：主存中的每一块可以被放置到Cache中唯一一组中的任何一个位置，是上面二者的折中&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;查找算法&lt;/strong&gt;
查找Cache在哪，通过查找目录表实现，目录表项与储存器块对应&lt;/p&gt;
&lt;p&gt;目录表&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;有效位&lt;/th&gt;
&lt;th&gt;标识&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;/table&gt;
&lt;p&gt;有效位为1表示有效，标识tag标识了存放的信息存在于哪个主存块中&lt;/p&gt;
&lt;p&gt;主存地址&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;标识&lt;/th&gt;
&lt;th&gt;索引&lt;/th&gt;
&lt;th&gt;块内位移&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;替换算法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;随机法&lt;/p&gt;
&lt;p&gt;FIFO&lt;/p&gt;
&lt;p&gt;LRU&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;LRU算法的硬件实现&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;堆栈法&lt;/p&gt;
&lt;p&gt;比较对法&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;写策略&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;写直达法：执行写操作时，不仅写入Cache，而且也直接写入下一级存储器（易于实现）
（不按写分配，不命中直接写入下一级而不调块）&lt;/p&gt;
&lt;p&gt;写回法：执行写操作时，只写入Cache。仅当Cache中相应的块被替换时，才写回主存（速度快）
（按写分配，不命中时调块）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Cache对低CPI、高时钟频率的CPU来说更为重要&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;改进Cache性能&lt;/strong&gt;
包括三个方面：&lt;/p&gt;
&lt;p&gt;① 降低不命中率（8种）&lt;/p&gt;
&lt;p&gt;② 减少不命中开销（5种）&lt;/p&gt;
&lt;p&gt;③ 减少Cache命中时间（4种）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;三种类型的不命中&lt;/strong&gt;
强制性不命中：首次访问就没命中
容量不命中：某些块被替换了，之后又访问了这些块（原因主要是容量小了）
冲突不命中：组相联或直接映像很多块映到了同一组（块）中，原块被替换，之后又访问了这些块&lt;/p&gt;
&lt;p&gt;相联度越高，冲突不命中就越少（因为每块可选的位置变多了，冲突几率下降），对强制不命中和容量不命中没什么影响&lt;/p&gt;
&lt;p&gt;Cache容量增加，容量不命中下降，对强制性不命中没影响&lt;/p&gt;
&lt;p&gt;减少三种不命中的方法：
强制性不命中：增加块大小，预取（本身比例很少）
容量不命中：增加容量
冲突不命中：提高相联度（理想情况：全相联）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;降低不命中率的八种方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;① 增加Cache块大小&lt;br&gt;
            最简单，减少强制不命中，但增加了冲突不命中（因为块的个数少了），同时也会增大不命中开销&lt;/p&gt;
&lt;p&gt;② 增加Cache容量&lt;br&gt;
            最直接，但会增加成本和命中时间&lt;/p&gt;
&lt;p&gt;③ 提高相联度&lt;br&gt;
            会增加命中时间
         （2:1Cache经验规则：容量为N的直接映像Cache的不命中率和容量为N/2的两路组相联Cache的不命中率差不多）&lt;/p&gt;
&lt;p&gt;④ 伪相联Cache&lt;br&gt;
            访问如果命中就和直接映像一样，如果不命中就检查另一个位置是否匹配，简单的方法是将索引的最高位取反。保持命中速度和低不命中率，会让CPU流水线的设计复杂化&lt;/p&gt;
&lt;p&gt;⑤ 硬件预取&lt;br&gt;
            指令和数据在处理器提出访问之前进行预取，由Cache之外的硬件完成，放入一个缓冲器中。预取应当利用存储器的空闲带宽，不能影响对正常不命中的处理，否则可能会降低性能&lt;/p&gt;
&lt;p&gt;⑥ 编译器控制的预取&lt;br&gt;
            由编译器在程序中加入预取指令实现预取。每次预取需要花费一条指令的开销&lt;/p&gt;
&lt;p&gt;⑦ 编译器优化&lt;br&gt;
            三种方法：代码和数据重组、内外循环交换、分块&lt;/p&gt;
&lt;p&gt;⑧ 牺牲Cache&lt;br&gt;
            在Cache和下一级之间设置一个全相联小Cache来存储被替换掉的块，减少冲突不命中很有效，尤其是小容量Cache&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;减少Cache不命中开销的五种方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;① 采用两级Cache（有计算）&lt;/p&gt;
&lt;p&gt;② 让读不命中优先于写
            会增加命中时间&lt;/p&gt;
&lt;p&gt;③ 写缓冲合并&lt;br&gt;
            写入的数据与缓冲器已有地址比较，如果有地址匹配的就合并&lt;/p&gt;
&lt;p&gt;④ 请求字处理技术&lt;br&gt;
            从下一级调入Cache的块只有一个字是立即需要的，称为请求字，两种方法：尽早重启动、请求字优先&lt;br&gt;
            在Cache块较小或者下一条指令正好访问Cache块的另一部分时，效果不明显&lt;/p&gt;
&lt;p&gt;⑤ 非阻塞Cache技术&lt;br&gt;
            在Cache不命中时仍允许CPU进行其他的命中访问&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;减少Cache命中时间的四种方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;① 容量小、结构简单的Cache&lt;br&gt;
            增大不命中率&lt;/p&gt;
&lt;p&gt;② 虚拟Cache&lt;br&gt;
            可以直接用虚拟地址进行访问的Cache&lt;/p&gt;
&lt;p&gt;③ Cache访问流水化&lt;br&gt;
            把对第一级Cache的访问按流水方式组织&lt;/p&gt;
&lt;p&gt;④ 踪迹Cache&lt;br&gt;
            存放CPU所执行过的动态序列，包含分支预测展开的指令&lt;br&gt;
            地址映像机制复杂，相同的指令序列可能被重复存放，提高了Cache的空间利用率&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;主存主要的性能指标&lt;/strong&gt;：延迟和带宽&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;并行主存系统&lt;/strong&gt;：在一个访存周期内能并行访问多个储存字的存储器&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;并行存储器结构包括&lt;/strong&gt;：
单体多字存储器
多体交叉存储器&lt;/p&gt;
&lt;h2 id=&#34;计算部分-3&#34;&gt;计算部分&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;平均每位价格C、命中率H、平均访存时间&lt;/strong&gt;（P155）&lt;/p&gt;
&lt;p&gt;$M_1{T_1, S_1, C_1}、M_2{T_2, S_2, C_2}$&lt;/p&gt;
&lt;p&gt;T: 平均访存时间，S: 存储容量，C: 平均每位价格&lt;/p&gt;
&lt;p&gt;平均每位价格 = $\frac{M_1C_1 + M_2C_2}{M_1 + M_2}$&lt;/p&gt;
&lt;p&gt;命中率 = $\frac{N_1}{N_1+N_2}$&lt;/p&gt;
&lt;p&gt;平均访存时间 = $HT_1 + (1-H)(T_1+T_M) = T_1 + (1-H)T_M = T_1 + FT_M$
不命中开销 $T_M = T_2 + T_B$&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Cache的容量&lt;/strong&gt;（P163）&lt;/p&gt;
&lt;p&gt;Cache容量 = $2^{index} \times$ 相联度 $\times$ 块大小&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;程序执行时间&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;$CPU$时间 = $IC \times (CPI + $每条指令的平均访存次数$\times $不命中率$ \times $不命中开销$) \times $时钟周期时间&lt;/p&gt;
&lt;p&gt;（P172例题）&lt;/p&gt;
&lt;h3 id=&#34;第六章输入输出系统&#34;&gt;第六章：输入输出系统&lt;/h3&gt;
&lt;h2 id=&#34;概念部分-5&#34;&gt;概念部分&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;I/O系统包括&lt;/strong&gt;：I/O设备、I/O设备与处理机的连接&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;系统的响应时间&lt;/strong&gt;：从用户输入命令开始，到得到结果所花费的时间（等于I/O系统的响应时间+CPU的处理时间）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;I/O系统的三个性能指标&lt;/strong&gt;
可靠性：一直连续提供服务的能力，用平均无故障时间MTTF衡量，其倒数为失效率（计算时失效率可累加，倒数相加再倒）
可用性：正常工作的时间在连续两次正常服务间隔中的比例    可用性=$\frac{MTTF}{MTTF+MTTR}$
可信性：服务的质量（无法度量）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;磁盘阵列&lt;/strong&gt;：使用多个磁盘的组合来代替一个大容量的磁盘
阵列的并行性包括：多个请求可以由多个盘来并行处理、一个请求访问多个块也可以多个块合作地并行处理&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;各种RAID&lt;/strong&gt;
（检测盘个数是数据盘个数为8个时所需要的检测盘个数）&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名称&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;th&gt;可容忍故障&lt;/th&gt;
&lt;th&gt;检测盘个数&lt;/th&gt;
&lt;th&gt;优点&lt;/th&gt;
&lt;th&gt;缺点&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;RAID0&lt;/td&gt;
&lt;td&gt;非冗余阵列，没有冗余信息&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;无空间开销&lt;/td&gt;
&lt;td&gt;无纠错能力&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;RAID1&lt;/td&gt;
&lt;td&gt;镜像盘，每个磁盘都有备份&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;计算少，快&lt;/td&gt;
&lt;td&gt;空间开销大&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;RAID2&lt;/td&gt;
&lt;td&gt;汉明纠错码位交叉&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;不依靠故障盘诊断&lt;/td&gt;
&lt;td&gt;空间开销log&lt;sub&gt;2&lt;/sub&gt;n&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;RAID3&lt;/td&gt;
&lt;td&gt;位交叉奇偶校验磁盘阵列&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;空间开销小，大规模I/O带宽高&lt;/td&gt;
&lt;td&gt;小规模I/O支持不好&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;RAID4&lt;/td&gt;
&lt;td&gt;块交叉奇偶校验磁盘阵列&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;空间开销小，小规模I/O带宽高&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;RAID5&lt;/td&gt;
&lt;td&gt;块交叉分布奇偶校验磁盘阵列&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;空间开销小，小规模I/O带宽高&lt;/td&gt;
&lt;td&gt;小规模读写需要访问4次&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;RAID6&lt;/td&gt;
&lt;td&gt;P+Q双校验磁盘阵列&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;容忍两个磁盘出错&lt;/td&gt;
&lt;td&gt;小规模读写需要访问6次&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;实现盘阵列的方式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;软件方式&lt;/p&gt;
&lt;p&gt;阵列卡方式&lt;/p&gt;
&lt;p&gt;子系统方式&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;通道处理机&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;专门负责整个计算机的输入输出工作，通道处理机只能执行有限的一组输入输出指令&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入输出系统的层次&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;CPU-&amp;gt;通道-&amp;gt;设备控制器-&amp;gt;外设&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;通道的主要硬件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;寄存器&lt;/p&gt;
&lt;p&gt;控制逻辑&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;通道的工作过程&lt;/strong&gt;（3步）&lt;/p&gt;
&lt;p&gt;① 在用户程序中启动一个访管指令，由管理程序来编制一个通道程序，并启动通道&lt;/p&gt;
&lt;p&gt;② 通道处理机执行通道程序，完成指定的数据的输入输出工作&lt;/p&gt;
&lt;p&gt;③ 通道程序结束后向CPU发出中断请求&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;通道的种类&lt;/strong&gt;（3种）&lt;/p&gt;
&lt;p&gt;① 字节多路通道，为多台低中速外设服务，以字节交叉的方式分时轮流服务，可以包含多个子通道，每个子通道连接一台设备控制器&lt;/p&gt;
&lt;p&gt;② 选择通道，为多台高速外围设备服务，一段时间内只为一条高速外设独占&lt;/p&gt;
&lt;p&gt;③ 数组多路通道，适用于高速设备，每次选择一个高速设备后传送一个数据块，轮流为多台外围设备服务&lt;/p&gt;
&lt;h2 id=&#34;计算部分-4&#34;&gt;计算部分&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;通道流量分析（P238）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;字节多路通道：（连一个外设，传一个字节，再连一个外设，传一个字节...）&lt;/p&gt;
&lt;p&gt;p台设备传输n个数据所需时间：$T_{BYTE}=(T_S+T_D)\times p\times n$&lt;/p&gt;
&lt;p&gt;最大流量：$f_{MAX-BYTE} = \frac{1}{T_S+T_D}$&lt;/p&gt;
&lt;p&gt;选择通道：（一台设备的数据传输工作全部结束后通道才为另一台设备服务）&lt;/p&gt;
&lt;p&gt;p台设备传输n个数据所需时间：$T_{SELECT}=(\frac{T_S}{n}+T_D)\times p\times n$&lt;/p&gt;
&lt;p&gt;最大流量：$f_{MAX-SELECT} = \frac{1}{\frac{T_S}{n}+T_D}$&lt;/p&gt;
&lt;p&gt;数组多路通道：（连一个外设，传一个k个字节的数据块，再连一个外设，传一个k个字节的数据块...）&lt;/p&gt;
&lt;p&gt;p台设备传输n个数据所需时间：$T_{BLOCK}=(\frac{T_S}{k}+T_D)\times p\times n$&lt;/p&gt;
&lt;p&gt;最大流量：$f_{MAX-BLOCK} = \frac{1}{\frac{T_S}{k}+T_D}$&lt;/p&gt;
&lt;br&gt;
&lt;h3 id=&#34;第八章多处理机&#34;&gt;第八章：多处理机&lt;/h3&gt;
&lt;h2 id=&#34;概念部分-6&#34;&gt;概念部分&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;MIMD的成为通用多处理机系统结构的选择的原因&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;MIMD具有灵活性&lt;/p&gt;
&lt;p&gt;MIMD可以充分利用现有微处理机的性价比优势&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;MIMD的分类&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;集中式共享存储器结构&lt;/strong&gt;（CSMA、UMA、对称式共享存储器多处理机SMP）&lt;/p&gt;
&lt;p&gt;多个处理器共享一个集中式的物理存储器，单一主存而且主存对于各处理器而言是对等的&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;分布式存储器多处理机&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;存储器分布到各个处理器上，优点：&lt;/p&gt;
&lt;p&gt;①降低对存储器和互联网络的带宽要求&lt;/p&gt;
&lt;p&gt;②对本地存储器的访问延迟时间小；&lt;/p&gt;
&lt;p&gt;缺点：处理器之间的通信较为复杂，访问延迟大&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;两种储存器系统结构&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;共享地址空间：物理上分离的所有储存器作为一个统一的共享逻辑空间进行编址，不同处理器的同一个物理地址指向同一个存储单元&lt;/p&gt;
&lt;p&gt;独立编址：每个节点的存储器编址为一个独立的地址空间，不同处理器的地址是独立的。每一个处理器-存储器模块实际上是一台单独的计算机&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;两种通信机制&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;共享存储器通信机制：处理器之间通过store-load对相同存储器地址进行读写来实现的
优点：&lt;/p&gt;
&lt;p&gt;① 与常用的SMP通信机制兼容&lt;/p&gt;
&lt;p&gt;② 易于编程&lt;/p&gt;
&lt;p&gt;③ 数据量小时开销较低&lt;/p&gt;
&lt;p&gt;④ 可以采用cache来减少远程通信的频度&lt;/p&gt;
&lt;p&gt;消息传递通信机制：处理器之间通过发送消息来进行通信&lt;/p&gt;
&lt;p&gt;优点&lt;/p&gt;
&lt;p&gt;① 硬件简单&lt;/p&gt;
&lt;p&gt;② 通信是显式的&lt;/p&gt;
&lt;p&gt;③ 减少不当的同步带来的可能的错误&lt;/p&gt;
&lt;p&gt;④ 显式通信让编程者重点关注主要通信开销&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Cache一致性协议&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;监听式协议&lt;/p&gt;
&lt;p&gt;目录式协议&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Cache一致性问题解决方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;写作废协议&lt;/p&gt;
&lt;p&gt;写更新协议&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;同时多线程技术&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;一种在多流出、动态调度的处理器上同时开发线程级并行和指令级并行的技术&lt;/p&gt;
</content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://yichengme.site/categories/%E6%8A%80%E6%9C%AF/" term="技术" label="技术" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://yichengme.site/tags/%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/" term="系统结构" label="系统结构" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">同济学生服务站小程序如何每日自动打卡</title>
            <link rel="alternate" type="text/html" href="https://yichengme.site/posts/miniprogram-auto-checkin/" />
            <id>https://yichengme.site/posts/miniprogram-auto-checkin/</id>
            <updated>2022-02-26T23:50:03&#43;08:00</updated>
            <published>2020-05-10T18:44:36&#43;08:00</published>
            <author>
                    <name>王毅诚</name>
                    <uri>https://yichengme.site/</uri>
                    <email>engine74396@gmail.com</email>
                    </author>
            <rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">（仅针对同济大学学生服务站小程序，本文只提供思路，需要具体代码的话可以私信。如果你一直呆在学校，可以考虑使用该方法自动签到，但是一旦离开上海，请务必向辅导员申报……</summary>
            
                <content type="html">&lt;p&gt;（仅针对同济大学学生服务站小程序，本文只提供思路，需要具体代码的话可以私信。如果你一直呆在学校，可以考虑使用该方法自动签到，但是一旦离开上海，请务必向辅导员申报！）&lt;/p&gt;
&lt;p&gt;之前寒假期间的打卡用的是问卷星，直接通过Selenium自动化来模拟操作前端填写问卷和提交打卡，都是流于表面的一些js操作，实现起来很简便。但是开学之后我们更换为了小程序打卡，微信小程序虽然是类前端，但它不同于常规网页，无法直接在浏览器中打开，只能借助微信来启动，可以理解为微信给它套了一个壳，提供了一些内置组件UI、请求统一处理、微信api调用、单独的IDE等等。小程序只能借助微信才能打开，只能通过腾讯发布的Wechat DevTool才能调试。&lt;/p&gt;
&lt;p&gt;那么问题来了，我们应该在小程序中怎么去模拟打卡的操作呢，我先试了试反编译，看看小程序的具体逻辑。&lt;/p&gt;
&lt;h2 id=&#34;反编译&#34;&gt;反编译&lt;/h2&gt;
&lt;p&gt;这里需要一台root过的安卓手机（推荐留个root过的安卓备用机，做很多事会比较方便，注意最好用备用机不要用主力机），没有的话也可以使用安卓模拟器先root再操作。&lt;/p&gt;
&lt;p&gt;安装微信和支持root超级权限的文件管理器，在模拟器里用微信登陆自己的账号，打开小程序，等小程序加载完成后，通过root文件管理器前往&lt;code&gt;data/data/com.tencent.mm/MicroMsg/&amp;lt;很长的一串数字字母字符串&amp;gt;/appbrand/pkg/&lt;/code&gt;文件夹下，在里面通过时间信息找到对应的wxpkg文件（不root的话是无法操作这些文件的），可以就地压缩然后通过微信或者其他软件发送到电脑上。&lt;/p&gt;
&lt;p&gt;最早的小程序反编译脚本是这个项目：https://github.com/qwerty472123/wxappUnpacker&lt;/p&gt;
&lt;p&gt;作者弃坑之后可以利用另一位大佬改进的项目：
&lt;a href=&#34;https://github.com/xuedingmiaojun/wxappUnpacker&#34;&gt;https://github.com/xuedingmiaojun/wxappUnpacker&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;按照README的说明来操作，就不具体解释&lt;/p&gt;
&lt;p&gt;中途如果遇到报错可以利用搜索引擎解决一下&lt;/p&gt;
&lt;p&gt;最后成功的输出&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span class=&#34;p&#34;&gt;...&lt;/span&gt;
&lt;span class=&#34;nx&#34;&gt;Generate&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;wxss&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;second&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;turn&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)...&lt;/span&gt;
&lt;span class=&#34;nx&#34;&gt;Generate&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;wxss&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;second&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;turn&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;done&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;
&lt;span class=&#34;nx&#34;&gt;Save&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;wxss&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;...&lt;/span&gt;
&lt;span class=&#34;nx&#34;&gt;saveDir&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;C&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;\&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Users&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;\&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;wyc&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;\&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Desktop&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;\&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;_97557709_27&lt;/span&gt;
&lt;span class=&#34;nx&#34;&gt;Split&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;and&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;make&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;up&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;done&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;
&lt;span class=&#34;nx&#34;&gt;Delete&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;files&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;...&lt;/span&gt;
&lt;span class=&#34;nx&#34;&gt;Deleted&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;

&lt;span class=&#34;nx&#34;&gt;File&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;done&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;
&lt;span class=&#34;nx&#34;&gt;Total&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;use&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;mf&#34;&gt;3.545&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;s&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;就会生成一个小程序源项目文件夹，可以直接用Wechat Dev Tool打开：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1641816256/checkin-1.png&#34; alt=&#34;checkin-1&#34;&gt;&lt;/p&gt;
&lt;p&gt;看了前端代码之后，可以看到所有的前端逻辑，签到的流程很简单，如下：&lt;/p&gt;
&lt;p&gt;初次使用小程序：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;完成学籍认证&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果学籍信息正确且该学籍没有绑定微信，则绑定学生信息到该微信id&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;（注意，该小程序每个学籍只能绑定一个微信，也就是说你不可以通过其他人的微信来绑定你的学籍）&lt;/p&gt;
&lt;p&gt;之后每次启动小程序：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;通过微信id，后端可以查到这名学生的签到信息&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;2-1. 如果已经签过到了，只提示“你已经签过到了”&lt;/p&gt;
&lt;p&gt;2-2. 如果当天没有签到，显示签到表单让用户填写&lt;/p&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;提交表单到后端，更新用户签到记录&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;值的一提的是，这里提交的位置信息并不是显示在前端的xx市xx区xx路，而是经纬度和xx市xx区，其他位置信息没用到，并且实际上校验的时候只要市正确即可，所以签到的话只要是标在上海市都没问题。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;所以只需要向后端服务器发送一条包含位置信息的POST请求，不论使用的设备在哪里，只要在data里写明上海，那么就会在上海打卡。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;然而只有前端并没有实质的收获，实际上也不需要前端代码，只是想通过反编译的方式了解一下逻辑。关键的是后端接口，可以抓包来获取，然后伪造打卡请求即可。&lt;/p&gt;
&lt;h2 id=&#34;抓包&#34;&gt;抓包&lt;/h2&gt;
&lt;p&gt;使用常见的抓包工具，抓包工具用顺手的就行，Fidder、Charles、Proxyman...我这次使用的是Proxyman，当然这几个都是完全同理的。&lt;/p&gt;
&lt;p&gt;微信小程序的抓包有一些不同，配置好手机和电脑连上之后，直接抓会获取不到：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1641816256/checkin-2.png&#34; alt=&#34;checkin-2&#34;&gt;&lt;/p&gt;
&lt;p&gt;（当然这里我们知道了base url，结合之前的前端源码，可以知道所有的api的url，但是不知道header、token等信息，发送post请求会比较麻烦。）&lt;/p&gt;
&lt;p&gt;为什么抓不到呢？这是因为微信7.0对https的证书做了限制，只有系统信任的证书才可以被允许，而我们安装的是软件的第三方证书&lt;/p&gt;
&lt;p&gt;你需要通过下面两种方式中的一种，才可以捕获成功：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;安装微信7.0之前的版本（简单）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;安卓root之后，把证书移动到系统证书目录下（会比较麻烦）&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;我两种方法都用过，第一种非常无脑，去豌豆荚下一个老版的微信即可，当然第二种方法会更好一些，毕竟老版本之后可能会有问题。&lt;/p&gt;
&lt;p&gt;按照软件的教程给电脑安装证书，手机配置网络代理，然后打开打卡小程序开始抓包，这个小程序抓包很轻松，api直接明文暴露了出来&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1641816256/checkin-3.png&#34; alt=&#34;checkin-3&#34;&gt;&lt;/p&gt;
&lt;p&gt;弄清楚这几个接口的含义、Header的信息、Auth的方式、POST数据的格式以及返回的信息含义，如果后端没有做一些处理的话，理论上就能直接伪装一个POST请求来进行签到。&lt;/p&gt;
&lt;p&gt;这些api的含义很明显，其他的就不细说了，主要说一下要用到的两个：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;用户是否签到&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;method: GET&lt;/p&gt;
&lt;p&gt;url: &amp;quot;https://tjxsfw.chisai.tech/api/school_tjxsfw_student/yqfkLogDailyreport/hasDoneToday?studentPid=&amp;quot; + studentPid&lt;/p&gt;
&lt;p&gt;header: 需要jwt验证&lt;/p&gt;
&lt;p&gt;Header中需要加入&amp;quot;Bearer: &amp;lt;jwt_token&amp;gt;&amp;quot;来验证&lt;/p&gt;
&lt;p&gt;返回一个json，如果code==200并且data=true，则表示已经签过到了，data=false表示今天还没签到&lt;/p&gt;
&lt;p&gt;这个api用于检测你是否需要签到，以及签到是否成功&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;签到&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;method: POST&lt;/p&gt;
&lt;p&gt;url: &amp;quot;https://tjxsfw.chisai.tech/api/school_tjxsfw_student/yqfkLogDailyreport/v2&amp;quot;&lt;/p&gt;
&lt;p&gt;data: 签到的json，包含用户信息、签到地点、打卡时间等&lt;/p&gt;
&lt;p&gt;header: 需要jwt验证&lt;/p&gt;
&lt;p&gt;第二天用postman试了一下，直接从proxyman里复制请求信息，然后修改时间，发了个POST过去，打开小程序，提示已经打过卡了，说明该方法有效&lt;/p&gt;
&lt;h2 id=&#34;构造请求反馈方式与定时任务&#34;&gt;构造请求、反馈方式与定时任务&lt;/h2&gt;
&lt;h3 id=&#34;构建请求&#34;&gt;构建请求&lt;/h3&gt;
&lt;p&gt;既然我们知道了具体的api，那么构造请求就非常简单了，C++、Java、C#、Python、JavaScript、Golang...基本上正常的编程语言都可以，选择自己顺手的即可。照着抓包到的请求抄一下header和token什么的，然后记得把请求的data里的日期改成现在的时间点。&lt;/p&gt;
&lt;p&gt;如果硬是要给明天后天也签个到，我没试过，理论上后端肯定会判断时间的，大概率会失败。主要是没这个必要，只要每天定时打卡即可&lt;/p&gt;
&lt;p&gt;（注意，同济大学学生服务站小程序会在每天的00：00-00：30分进行维护，需要绕开这个时间打卡）&lt;/p&gt;
&lt;h3 id=&#34;反馈方式&#34;&gt;反馈方式&lt;/h3&gt;
&lt;p&gt;我们设置了自动打卡，那么打完卡之后，小程序是不会通知你的，这时候就需要一个被通知的方式，来告诉你自动打卡成功或者失败的消息。&lt;/p&gt;
&lt;p&gt;途径有很多，我说说几个能想到的：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;QQ Bot&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;优点：部署完之后会很方便，还可以做其他事，有很全面的交互
缺点：构建比较复杂，尤其是tx几个月前封杀了一些第三方机器人，酷q倒了之后，目前我了解到的仅mirai可用。这件事主要表明了tx想要封杀第三方机器人的态度，导致QQ Bot的未来很迷茫。
适合人群：已经有自己的正常运行的QQ Bot，再写一个插件即可&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;Telegram Bot/ Discord Bot&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;优点：和QQ Bot优点一样，不过很稳定，软件官方支持的Bot
缺点：需要全程科学上网
适合人群：能全程科学上网的telegram/discord重度用户&lt;/p&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;IFTTT&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;优点：很容易，不用写代码，不用自己买服务器或域名
缺点：功能比较简陋（但是只是通知的话够用了）&lt;/p&gt;
&lt;p&gt;另外还搜到了一些其他的第三方软件，用法和IFTTT类似，需要的可以自己去搜索&lt;/p&gt;
&lt;p&gt;推荐采用IFTTT通知的方式，最容易实现。可以参考：https://zhuanlan.zhihu.com/p/103419701&lt;/p&gt;
&lt;h3 id=&#34;定时任务&#34;&gt;定时任务&lt;/h3&gt;
&lt;p&gt;需要设置一个定时任务来在每天的一个时间点打卡，所以不能关机。推荐使用云服务器或者是闲置的不关机电脑。&lt;/p&gt;
&lt;p&gt;这里分windows、mac&amp;amp;linux三个平台来说&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Windows&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;先构造一个bat脚本来启动程序，或者也可以打包程序为exe&lt;/p&gt;
&lt;p&gt;通过计算机管理 - 创建基本任务 - 定位bat或者exe文件 - 设置每日执行一次和执行的时间，然后就ok了&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;MacOS/Linux&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;因为mac也是类Unix系统，所以和Linux都可以使用crontab来设置定时任务，具体的教程网上很多&lt;/p&gt;
&lt;h3 id=&#34;后续&#34;&gt;后续&lt;/h3&gt;
&lt;p&gt;设定好定时任务后，就免去了每日打卡的操作，它会自动定时打卡，成功后通过手机发送通知。每天点三下屏幕都不想做，可能就是懒癌晚期吧。&lt;/p&gt;
</content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://yichengme.site/categories/%E7%94%9F%E6%B4%BB/" term="生活" label="生活" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://yichengme.site/tags/%E8%84%9A%E6%9C%AC/" term="脚本" label="脚本" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">Mongodb初级教程</title>
            <link rel="alternate" type="text/html" href="https://yichengme.site/posts/mongodb-basics/" />
            <id>https://yichengme.site/posts/mongodb-basics/</id>
            <updated>2022-02-27T15:21:46&#43;08:00</updated>
            <published>2020-04-20T14:29:14&#43;08:00</published>
            <author>
                    <name>王毅诚</name>
                    <uri>https://yichengme.site/</uri>
                    <email>engine74396@gmail.com</email>
                    </author>
            <rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">背景 mongodb是一个基于分布式文件存储的数据库。由C++语言编写。旨在为WEB应用提供可扩展的高性能数据存储解决方案。它是一个介于关系数据库和非关系数据库之……</summary>
            
                <content type="html">&lt;h2 id=&#34;背景&#34;&gt;背景&lt;/h2&gt;
&lt;p&gt;mongodb是一个基于分布式文件存储的数据库。由C++语言编写。旨在为WEB应用提供可扩展的高性能数据存储解决方案。它是一个介于关系数据库和非关系数据库之间的产品，是非关系数据库当中功能最丰富，最像关系数据库的。&lt;/p&gt;
&lt;p&gt;这里简单的讲一下使用方法，不涉及底层理论&lt;/p&gt;
&lt;h2 id=&#34;起步&#34;&gt;起步&lt;/h2&gt;
&lt;h3 id=&#34;mac下安装mongodb&#34;&gt;Mac下安装MongoDB&lt;/h3&gt;
&lt;p&gt;之前是
&lt;code&gt;brew install mongodb&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;但是现在会报错：No available formula with the name “mongodb”。&lt;/p&gt;
&lt;p&gt;先tap一个仓库 &lt;code&gt;brew tap mongodb/brew&lt;/code&gt;
安装mongodb社区版 &lt;code&gt;brew install mongodb-community&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&#34;运行mongod&#34;&gt;运行mongod&lt;/h3&gt;
&lt;p&gt;新建一个&lt;code&gt;/data/db&lt;/code&gt;文件夹&lt;/p&gt;
&lt;p&gt;运行MongoDB服务
&lt;code&gt;sudo mongod&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;（注：macOS 10.15 Catalina无法在根目录下进行修改，可以在其他目录新建，启动服务时通过&lt;code&gt;sudo mongod --dbpath=new_path/data/db&lt;/code&gt;指定）&lt;/p&gt;
&lt;p&gt;定位和启动MongoDB命令行
&lt;code&gt;cd /usr/local/Cellar/mongodb/4.0.3_1/bin&lt;/code&gt;
&lt;code&gt;./mongo&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;MongoDB和关系型数据库（Oracle、MySQL等）的区别：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;SQL&lt;/th&gt;
&lt;th&gt;MongoDB&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;table&lt;/td&gt;
&lt;td&gt;collection(集合)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;row&lt;/td&gt;
&lt;td&gt;document(文档)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;colume&lt;/td&gt;
&lt;td&gt;field(数据字段)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;每个文档是一组键值对（BSON）相同的字段不需要相同的数据类型&lt;/p&gt;
&lt;h2 id=&#34;基本命令&#34;&gt;基本命令&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;show dbs&lt;/code&gt; 展示所有数据库&lt;/p&gt;
&lt;p&gt;&lt;code&gt;use xx&lt;/code&gt; 使用某个数据库&lt;/p&gt;
&lt;p&gt;使用了某个数据库后：&lt;code&gt;show collections&lt;/code&gt;查看所有的集合&lt;/p&gt;
&lt;p&gt;&lt;code&gt;db.dropDatabase()&lt;/code&gt; 删除当前数据库&lt;/p&gt;
&lt;p&gt;&lt;code&gt;db.&amp;lt;col&amp;gt;.drop()&lt;/code&gt; 删除某个集合&lt;/p&gt;
&lt;p&gt;&lt;code&gt;mongodump -o &amp;lt;output_path&amp;gt;&lt;/code&gt; 导出数据库
（如果设置了密码，需要通过下面的命令导出）
&lt;code&gt;sudo mongodump -o &amp;lt;output_path&amp;gt; --authenticationDatabase admin --username &amp;lt;db_username&amp;gt; --password &amp;lt;db_password&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;mongorestore -d &amp;lt;dbname&amp;gt; &amp;lt;db_path&amp;gt;&lt;/code&gt; 导入数据库&lt;/p&gt;
&lt;h3 id=&#34;验证&#34;&gt;验证&lt;/h3&gt;
&lt;p&gt;本地的还好，如果部署到服务器上，默认是无法外网访问数据库的，倘若你想访问，就得开放端口然后在mongo的配置文件里设置0.0.0.0。然后mongo默认也没有密码&lt;/p&gt;
&lt;p&gt;这就会产生一个很蛋疼的事，当其他人访问你服务器的ip的27017端口时，可以直接完全操作你的数据库，对于非个人弄着玩的项目，这显然是不可能接受的。&lt;/p&gt;
&lt;p&gt;所以我们需要增加数据库验证，这里最常见的就是增加账号密码登录，方法如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span class=&#34;o&#34;&gt;//&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;err&#34;&gt;先使用&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;admin&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;use&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;admin&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;//&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;err&#34;&gt;创建&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;root密码&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;db&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;createUser&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;user&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;root&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;pwd&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;password&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;roles&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;root&amp;#34;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;其他的role：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;read
readWrite
dbAdmin
userAdmin
clusterAdmin
readAnyDatabase
readWriteAnyDatabase
userAdminAnyDatabase
dbAdminAnyDatabase
&lt;/code&gt;&lt;/pre&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span class=&#34;o&#34;&gt;//&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;err&#34;&gt;创建用户&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;db&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;createUser&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;user&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;username&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;pwd&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;password&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;roles&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;userAdminAnyDatabase&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;dbAdminAnyDatabase&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;readWriteAnyDatabase&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;在&lt;code&gt;/etc/mongo.conf&lt;/code&gt;配置文件里，把auth=true前面的&lt;code&gt;#&lt;/code&gt;去掉，让验证生效。&lt;/p&gt;
&lt;p&gt;重启mongodb服务&lt;code&gt;sudo service mongodb restart&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;之后的连接方式：mongo命令行连接：
&lt;code&gt;mongo admin -u username -p password&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;本地GUI（如navicat）连接，设置账号密码即可&lt;/p&gt;
&lt;h3 id=&#34;字段操作&#34;&gt;字段操作&lt;/h3&gt;
&lt;p&gt;字段重命名：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;db.col.update({},{$rename:{&amp;quot;old_field&amp;quot;:&amp;quot;new_field&amp;quot;}},false,true)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;比如：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;db.questionnaire.update({},{$rename:{&amp;quot;questionList&amp;quot;:&amp;quot;question&amp;quot;}},false,true)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;字段增加：
还可以指定默认值xxx&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;db.col.update({},{$set:{new_field:&#39;xxx&#39;}},{multi:true})
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;字段删除：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;db.col.update({},{$unset:{&#39;old_field&#39;:&#39;&#39;}},false, true)
&lt;/code&gt;&lt;/pre&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;db.user_questionnaire.update({},{$unset:{&#39;inputCostEstimation&#39;:&#39;&#39;}},false, true)
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;查找&#34;&gt;查找&lt;/h3&gt;
&lt;p&gt;列出集合信息：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;db.&amp;lt;collection-name&amp;gt;.find()
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;列出第一条集合的信息（按Json排版一下）：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;db.&amp;lt;collection-name&amp;gt;.findOne()
db.&amp;lt;col-name&amp;gt;.find({query}, {show})
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;query是一个查询字段。比如{&amp;quot;name&amp;quot;:&amp;quot;yicheng&amp;quot;}这种形式
后面的参数决定field是否显示，比find({&amp;quot;name&amp;quot;:&amp;quot;yicheng&amp;quot;}, {&amp;quot;_id&amp;quot;: 0, &amp;quot;age&amp;quot;: 1}) 表示_id不会显示，age会显示&lt;/p&gt;
&lt;p&gt;条件比较：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;操作&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;th&gt;用法&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;$gt&lt;/td&gt;
&lt;td&gt;&amp;gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;$gte&lt;/td&gt;
&lt;td&gt;&amp;gt;=&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;$lt&lt;/td&gt;
&lt;td&gt;&amp;lt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;$lte&lt;/td&gt;
&lt;td&gt;&amp;lt;=&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;$eq&lt;/td&gt;
&lt;td&gt;=&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;$ne&lt;/td&gt;
&lt;td&gt;!=&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;$in&lt;/td&gt;
&lt;td&gt;in&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;$nin&lt;/td&gt;
&lt;td&gt;not in&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;增删改&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;增加：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;db.col.insert(json)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;e.g.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;db.col.insert({&amp;quot;name&amp;quot;:&amp;quot;engine&amp;quot;, &amp;quot;age&amp;quot;:18})

db.articles.insert({&amp;quot;title&amp;quot;:&amp;quot;Test&amp;quot;,&amp;quot;author&amp;quot;:&amp;quot;engine&amp;quot;,&amp;quot;time&amp;quot;:&amp;quot;2020.02.27&amp;quot;,&amp;quot;kind&amp;quot;:&amp;quot;tech&amp;quot;,&amp;quot;tags&amp;quot;:&amp;quot;golang,website&amp;quot;,&amp;quot;content&amp;quot;:&amp;quot;This is a blog for test&amp;quot;,&amp;quot;comment&amp;quot;:&amp;quot;comment1&amp;quot;,&amp;quot;view&amp;quot;:10,&amp;quot;like&amp;quot;:5})

db.user.insert({&amp;quot;name&amp;quot;:&amp;quot;user1&amp;quot;,avatar:&amp;quot;https://i.loli.net/2020/03/15/XsJjRomr1dy8u4D.png&amp;quot;,&amp;quot;type&amp;quot;:0,&amp;quot;score&amp;quot;:20,&amp;quot;password&amp;quot;:&amp;quot;123456&amp;quot;,&amp;quot;todo&amp;quot;:&amp;quot;&amp;quot;})
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;删除：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;db.col.remove(query)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;修改&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;db.mycoll.update(query, object[, upsert_bool, multi_bool])
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;第一个参数是查询条件，第二个参数是修改信息，第三个是如果没找到是否相当于插入（默认为false），第四个参数是修改一个还是所有（默认为false）&lt;/p&gt;
&lt;p&gt;e.g.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;db.col.update({&amp;quot;name&amp;quot;:&amp;quot;engine&amp;quot;}, {$set:{&amp;quot;age&amp;quot;:20}})

db.col.update({&amp;quot;age&amp;quot;: {$gt: 20}}, {$set:{&amp;quot;age&amp;quot;: 30}}, false, true)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;更复杂的逻辑：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;db.getCollection(&#39;participant&#39;).find().forEach(
   function(item){
       db.getCollection(&#39;participant&#39;).update({&amp;quot;_id&amp;quot;:item._id},{$set:{&amp;quot;modifyTimes&amp;quot;: 3}})
   }
)
&lt;/code&gt;&lt;/pre&gt;&lt;table class=&#34;reference&#34;&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;th&gt;数据类型&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;字符串。存储数据常用的数据类型。在 MongoDB 中，UTF-8 编码的字符串才是合法的。   &lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;Integer&lt;/td&gt;&lt;td&gt;整型数值。用于存储数值。根据你所采用的服务器，可分为 32 位或 64 位。  &lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;Boolean&lt;/td&gt;&lt;td&gt;布尔值。用于存储布尔值（真/假）。  &lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;Double&lt;/td&gt;&lt;td&gt;双精度浮点值。用于存储浮点值。  &lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;Min/Max keys&lt;/td&gt;&lt;td&gt;将一个值与 BSON（二进制的 JSON）元素的最低值和最高值相对比。  &lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;Array&lt;/td&gt;&lt;td&gt;用于将数组或列表或多个值存储为一个键。  &lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;Timestamp&lt;/td&gt;&lt;td&gt;时间戳。记录文档修改或添加的具体时间。  &lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;Object&lt;/td&gt;&lt;td&gt;用于内嵌文档。  &lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;Null&lt;/td&gt;&lt;td&gt;用于创建空值。  &lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;Symbol&lt;/td&gt;&lt;td&gt;符号。该数据类型基本上等同于字符串类型，但不同的是，它一般用于采用特殊符号类型的语言。&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;Date&lt;/td&gt;&lt;td&gt;日期时间。用 UNIX 时间格式来存储当前日期或时间。你可以指定自己的日期时间：创建 Date 对象，传入年月日信息。  &lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;Object ID&lt;/td&gt;&lt;td&gt;对象 ID。用于创建文档的 ID。  &lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;Binary Data&lt;/td&gt;&lt;td&gt;二进制数据。用于存储二进制数据。&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;Code&lt;/td&gt;&lt;td&gt;代码类型。用于在文档中存储 JavaScript 代码。&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;Regular expression&lt;/td&gt;&lt;td&gt;正则表达式类型。用于存储正则表达式。&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;更新某个字段的值&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;db.getCollection&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;participant&amp;#39;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;.find&lt;span class=&#34;o&#34;&gt;()&lt;/span&gt;.forEach&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;
   &lt;span class=&#34;k&#34;&gt;function&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;item&lt;span class=&#34;o&#34;&gt;){&lt;/span&gt;
       db.getCollection&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;participant&amp;#39;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;.update&lt;span class=&#34;o&#34;&gt;({&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;_id&amp;#34;&lt;/span&gt;:item._id&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;,&lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;$set&lt;/span&gt;:&lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;modifiTimes&amp;#34;&lt;/span&gt;: 2&lt;span class=&#34;o&#34;&gt;}})&lt;/span&gt;
   &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h2 id=&#34;golang的mongodb接口mgo&#34;&gt;Golang的MongoDB接口：mgo&lt;/h2&gt;
&lt;p&gt;简单的使用&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;kd&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;Person&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;Name&lt;/span&gt;  &lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;Phone&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;c1&#34;&gt;// mgo.Dial核心函数，由url新建一个session
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;nx&#34;&gt;session&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;mgo&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Dial&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;mongodb://127.0.0.1:27017/&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;nb&#34;&gt;panic&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;defer&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;session&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Close&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
	&lt;span class=&#34;c1&#34;&gt;// Optional. Switch the session to a monotonic behavior.
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;nx&#34;&gt;session&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;SetMode&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;mgo&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Monotonic&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;true&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
        &lt;span class=&#34;c1&#34;&gt;// c就连到了对应的collection
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;session&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;DB&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;test&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;).&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;C&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;people&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
        &lt;span class=&#34;c1&#34;&gt;// 插入数据
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Insert&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Person&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;Ale&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;+55 53 8116 9639&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;},&lt;/span&gt;
		&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Person&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;Cla&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;+55 53 8402 8510&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;})&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;log&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Fatal&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;result&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;Person&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{}&lt;/span&gt;
        &lt;span class=&#34;c1&#34;&gt;// result是一个查询结果
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Find&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;bson&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;M&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;name&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;Ale&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}).&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;One&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;result&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;log&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Fatal&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;fmt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Println&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;Phone:&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;result&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Phone&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;</content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://yichengme.site/categories/%E6%8A%80%E6%9C%AF/" term="技术" label="技术" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://yichengme.site/tags/mongodb/" term="MongoDB" label="MongoDB" />
                            
                        
                            
                            
                            
                                <category scheme="https://yichengme.site/tags/database/" term="Database" label="Database" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">操作系统基础（四）文件IO</title>
            <link rel="alternate" type="text/html" href="https://yichengme.site/posts/os-basics-io/" />
            <id>https://yichengme.site/posts/os-basics-io/</id>
            <updated>2022-03-02T19:00:04&#43;08:00</updated>
            <published>2020-02-20T16:01:08&#43;08:00</published>
            <author>
                    <name>王毅诚</name>
                    <uri>https://yichengme.site/</uri>
                    <email>engine74396@gmail.com</email>
                    </author>
            <rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">文件基本概念 文件是记录在外存上相关信息的具名集合，对于用户而言文件是逻辑外存最小的分配单位，文件是一组有意义信息的集合 在系统运行时，计算机以进程为基本单位进行资……</summary>
            
                <content type="html">&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1645945891/os-io-1.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;文件基本概念&#34;&gt;文件基本概念&lt;/h2&gt;
&lt;p&gt;文件是记录在外存上相关信息的具名集合，对于用户而言文件是逻辑外存最小的分配单位，文件是一组有意义信息的集合&lt;/p&gt;
&lt;p&gt;在系统运行时，计算机以进程为基本单位进行资源的调度和分配，而在用户进行输入输出时，则以文件为基本单位。&lt;/p&gt;
&lt;p&gt;需要系统提供一个文件管理系统来让用户管理文件，文件系统由一组文件和目录结构组成&lt;/p&gt;
&lt;h3 id=&#34;文件属性&#34;&gt;文件属性&lt;/h3&gt;
&lt;p&gt;文件名、标志符（唯一标签，用户不可读）、类型、位置、大小、保护信息、时间、日期和用户标识&lt;/p&gt;
&lt;p&gt;文件属于抽象数据类型&lt;/p&gt;
&lt;h3 id=&#34;文件基本操作&#34;&gt;文件基本操作&lt;/h3&gt;
&lt;p&gt;（操作系统应该向上提供的文件操作功能）
创建文件、写文件、读文件、在文件内重定位、删除文件（完全删除）、截短文件（删除内容不删属性）&lt;/p&gt;
&lt;h3 id=&#34;文件的打开与关闭&#34;&gt;文件的打开与关闭&lt;/h3&gt;
&lt;p&gt;要读一个文件首先要用open系统调用打开该文件，open中的参数包括文件路径名和文件名，&lt;/p&gt;
&lt;p&gt;read只需要使用open返回的文件描述符，不使用文件名作为参数&lt;/p&gt;
&lt;p&gt;每个打开文件有以下信息：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;文件指针&lt;/li&gt;
&lt;li&gt;文件打开计数器&lt;/li&gt;
&lt;li&gt;文件磁盘位置&lt;/li&gt;
&lt;li&gt;访问权限&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;文件的逻辑结构&#34;&gt;文件的逻辑结构&lt;/h3&gt;
&lt;p&gt;文件的逻辑结构是&lt;strong&gt;从用户观点出发看到的文件内部的组织形式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;文件按照逻辑结构分为无结构文件（流式文件）和有结构文件（记录式文件）&lt;/p&gt;
&lt;p&gt;无结构文件（流式文件）：以字节为单位&lt;/p&gt;
&lt;p&gt;有结构文件（记录式文件）：分为顺序文件、索引文件、顺序索引文件、散列文件&lt;/p&gt;
&lt;p&gt;文件的目录结构（文件之间的组织形式）
文件存放在外存中（文件的物理结构）&lt;/p&gt;
&lt;h3 id=&#34;访问方法&#34;&gt;访问方法&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;顺序访问&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;直接访问&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;目录结构&#34;&gt;目录结构&lt;/h3&gt;
&lt;p&gt;引入&lt;strong&gt;文件控制块(FCB)&lt;/strong&gt; 这个数据结构&lt;/p&gt;
&lt;p&gt;FCB包括基本信息、存取控制信息和使用信息&lt;/p&gt;
&lt;p&gt;目录相关操作有：搜索文件、创建文件、删除文件、遍历目录、重命名文件、跟踪文件系统&lt;/p&gt;
&lt;h3 id=&#34;保护&#34;&gt;保护&lt;/h3&gt;
&lt;p&gt;信息需要被保护，不受物理损坏（可靠性）和非法访问（保护）&lt;/p&gt;
&lt;p&gt;口令、存取控制和用户权限表都是常见的文件保护方法&lt;/p&gt;
&lt;p&gt;可靠性通常靠文件备份来提供&lt;/p&gt;
&lt;p&gt;访问类型：读、写、执行、添加、删除、列表清单&lt;/p&gt;
&lt;p&gt;为每个文件添加一个访问控制列表（ACL）&lt;/p&gt;
&lt;p&gt;加密保护和访问控制：加密保护安全性更高，访问控制灵活性更好。访问控制需要由系统实现来保证安全性&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1645945891/os-io-2.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;错题归纳&#34;&gt;错题归纳&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;从用户的角度看，引入文件系统的目的是实现对文件的按名存取；从系统角度看，文件系统则负责对文件储存空间进行组织分配、负责文件储存并对存入的文件进行保护和检索&lt;/li&gt;
&lt;li&gt;FCB的有序集合称为文件目录，一个FCB就是一个文件目录项&lt;/li&gt;
&lt;li&gt;逻辑结构的组织形式取决于用户，物理结构的组织形式取决于储存介质特性&lt;/li&gt;
&lt;li&gt;文件目录项（FCB）不包括FCB的物理位置&lt;/li&gt;
&lt;li&gt;对一个访问的限制，常由用户访问权限和文件属性共同限制，与优先级无关&lt;/li&gt;
&lt;li&gt;一个文件被用户首次打开的过程中，操作系统需要将文件控制块读到内存中，不是文件内容&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;文件系统实现&#34;&gt;文件系统实现&lt;/h2&gt;
&lt;h3 id=&#34;文件系统层次结构&#34;&gt;文件系统层次结构&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1645945891/os-io-3.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;用户调用接口：给用户文件操控的接口&lt;/li&gt;
&lt;li&gt;文件目录系统：管理文件目录&lt;/li&gt;
&lt;li&gt;存取控制模块：实现文件保护&lt;/li&gt;
&lt;li&gt;逻辑文件系统与文件信息缓冲区：根据逻辑结构将用户要读写的逻辑记录转换成文件逻辑结构内的相应块号&lt;/li&gt;
&lt;li&gt;物理文件系统：把相应块号转成实际物理地址&lt;/li&gt;
&lt;li&gt;辅助分配模块：管理辅存空间，辅存空间的分配和回收&lt;/li&gt;
&lt;li&gt;设备管理模块：管理相关设备&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;单层结构目录、双层结构目录、树状结构目录、无环图目录（同一文件可以在不同目录中）、通用图目录&lt;/p&gt;
&lt;p&gt;物理块是分配和传输的基本单位&lt;/p&gt;
&lt;h3 id=&#34;目录实现&#34;&gt;目录实现&lt;/h3&gt;
&lt;p&gt;线性链表、哈希表&lt;/p&gt;
&lt;h3 id=&#34;外存分配方式&#34;&gt;外存分配方式&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;连续分配&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;每个文件在磁盘上占有一组连续的块&lt;/p&gt;
&lt;p&gt;分配方式可以用第一块磁盘的地址和连续块数量来确定&lt;/p&gt;
&lt;p&gt;优点：实现简单、存取速度快
缺点：不方便动态增加，容易产生外部碎片&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;链接分配（隐式、显式）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;以离散分配的方式，消除外部碎片&lt;/p&gt;
&lt;p&gt;隐式：除最后一个块外，每个块都有一个指向下一个盘块的指针，目录包括第一个指针和最后一个指针&lt;/p&gt;
&lt;p&gt;显式：显式地存放在内存的一张链接表中，文件分配表（File Allocation Table, FAT）&lt;/p&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;索引分配（一级、二级、多级）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;每个文件设置一个索引块，是一个磁盘块地址的数组&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1645945891/os-io-4.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1645945891/os-io-5.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;错题归纳-1&#34;&gt;错题归纳&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;文件储存空间的管理实质上是对外存空闲区的管理和组织&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;磁盘结构&#34;&gt;磁盘结构&lt;/h2&gt;
&lt;p&gt;概念：磁盘由表面涂有磁性物质的圆形盘片组成，每个盘片被划成一个个磁道，每个磁道被划成一个个扇区&lt;/p&gt;
&lt;p&gt;如何读写：磁头移动到目标位置，盘片旋转，对应扇区划过磁道，完成读写&lt;/p&gt;
&lt;p&gt;磁盘的物理地址依靠柱面号、盘面号、扇区号来确定&lt;/p&gt;
&lt;p&gt;磁盘分类：
活动头磁盘、固定头磁盘
可换盘磁盘、固定盘磁盘&lt;/p&gt;
&lt;h3 id=&#34;磁盘调度算法&#34;&gt;磁盘调度算法&lt;/h3&gt;
&lt;p&gt;一次读/写操作需要的时间包括
寻找时间：读写之前磁头移动到磁道花费的时间，$T_S = T_{启动磁头臂} + m_{跨越一个磁道耗时}*n_{需要跨越的磁道数}$
延迟时间：通过旋转磁盘让磁头定位到目标扇区所需要的时间，平均延迟时间$T_R = \frac{1}{2} * \frac{1}{r}$ (r为转速)
传输时间：从磁盘读出或向磁盘写入数据所经历的时间，转速为r，读写的字节数b，每个磁道字节数N，传输时间$T_t = \frac{1}{r} * \frac{b}{N}$&lt;/p&gt;
&lt;p&gt;延迟时间和传输时间是硬件决定的，操作系统只能通过调度算法优化寻找时间&lt;/p&gt;
&lt;p&gt;磁盘调度算法：
先来先服务（FCFS）：按顺序处理
最短寻找时间（SSTF）：先处理离目前磁头最近的请求，贪心算法（局部最优不一定是全局最优），可能导致饥饿
扫描算法（SCAN）：只有移动到最内侧磁道才能往外侧移动，只有移动到最外侧磁道才能往内侧移动
LOOK调度算法：扫描算法的升级，在移动方向上没有请求了就可以改变方向
循环扫描算法（C-SCAN）：扫描算法的变形，每次扫描的移动方向一样，扫到底了直接快速移到开头，中间不管，这样解决了SCAN算法两侧与中间不均的问题
C-LOOK：C-SCAN的升级，相比C-SCAN头尾不需要是磁盘的最前面和最后面，只要有请求的最前面和最后面&lt;/p&gt;
&lt;p&gt;题目里的SCAN都默认是对应的LOOK算法&lt;/p&gt;
&lt;h3 id=&#34;减少&#34;&gt;减少&lt;/h3&gt;
&lt;p&gt;交替编号
错位命名&lt;/p&gt;
&lt;h2 id=&#34;io管理&#34;&gt;I/O管理&lt;/h2&gt;
&lt;h3 id=&#34;io设备分类&#34;&gt;I/O设备分类&lt;/h3&gt;
&lt;p&gt;按照使用特性：
人机交互外部设备：比如鼠标键盘（数据传输最慢）
储存设备：比如移动硬盘（数据传输最快）
网络通信设备：比如路由器&lt;/p&gt;
&lt;p&gt;按照传输速率：
低速设备、中速设备、高速设备&lt;/p&gt;
&lt;p&gt;按照信息交换的单位：
块设备（传输快、可以寻址）、字符设备（不可寻址，通常用中断驱动控制）&lt;/p&gt;
&lt;h3 id=&#34;io控制方式&#34;&gt;I/O控制方式&lt;/h3&gt;
&lt;p&gt;程序直接控制方式：CPU不断轮询检查是否设备就绪，简单，CPU利用率低&lt;/p&gt;
&lt;p&gt;中断驱动方式：CPU先让IO进程阻塞，之后IO设备向CPU发出中断让其执行，CPU利用率提高，但频繁中断浪费CPU时间&lt;/p&gt;
&lt;p&gt;DMA（直接存储器存取）方式：在IO与内存之间开辟新的数据通路，仅在开始和结束时才需要CPU干预，数据传输不需要经过CPU，可以传数据块&lt;/p&gt;
&lt;p&gt;通道控制方式：可以看成专门处理IO的阉割版CPU，完成后才向CPU发送中断&lt;/p&gt;
&lt;p&gt;上面四个方式从上往下CPU干预程度越来越低，CPU利用率越来越高&lt;/p&gt;
&lt;h3 id=&#34;io子系统的层次结构&#34;&gt;I/O子系统的层次结构&lt;/h3&gt;
&lt;p&gt;用户层I/O软件：比如库函数printf
设备独立性软件
设备驱动程序
中断处理程序
硬件设备&lt;/p&gt;
&lt;p&gt;中间三层属于I/O核心子系统&lt;/p&gt;
</content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://yichengme.site/categories/%E6%8A%80%E6%9C%AF/" term="技术" label="技术" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://yichengme.site/tags/os/" term="OS" label="OS" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">操作系统基础（三）内存</title>
            <link rel="alternate" type="text/html" href="https://yichengme.site/posts/os-basics-memory/" />
            <id>https://yichengme.site/posts/os-basics-memory/</id>
            <updated>2022-03-02T18:59:52&#43;08:00</updated>
            <published>2020-02-08T19:45:04&#43;08:00</published>
            <author>
                    <name>王毅诚</name>
                    <uri>https://yichengme.site/</uri>
                    <email>engine74396@gmail.com</email>
                    </author>
            <rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">基础 程序装入和链接 编译：编译程序将源代码编译成若干目标模块 链接：链接程序把各个目标模块，包括外部库函数链接在一起 装入：由装入程序将装入模块装入内存中运行 其中链接……</summary>
            
                <content type="html">&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1645944931/os-memory-1.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;基础&#34;&gt;基础&lt;/h2&gt;
&lt;h3 id=&#34;程序装入和链接&#34;&gt;程序装入和链接&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;编译：编译程序将源代码编译成若干目标模块&lt;/li&gt;
&lt;li&gt;链接：链接程序把各个目标模块，包括外部库函数链接在一起&lt;/li&gt;
&lt;li&gt;装入：由装入程序将装入模块装入内存中运行&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其中链接分为三种：
静态链接
装入时动态链接：装入时边装入边链接
运行时动态链接：执行时才链接&lt;/p&gt;
&lt;p&gt;装入也分为三种：
绝对（静态）装入：在编程阶段就把物理地址计算好
可重定位装入：有一个逻辑地址到物理地址的映射，之后不能变
动态重定位装入：运行时才转换，之后可以变&lt;/p&gt;
&lt;h3 id=&#34;地址绑定&#34;&gt;地址绑定&lt;/h3&gt;
&lt;p&gt;将指令和数据绑定到内存地址有三种情况：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;编译时：生成绝对代码，编译时就知道了进程在内存中的驻留地址，所生成的编译代码就可以从该位置往后扩展（开始位置发生变化就要重新编译）&lt;/li&gt;
&lt;li&gt;加载时：生成可重定位代码&lt;/li&gt;
&lt;li&gt;执行时：绑定延迟到执行时才进行&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;物理地址: 内存地址寄存器中的地址，又叫绝对地址、实地址&lt;/p&gt;
&lt;p&gt;逻辑地址: CPU生成的地址，又叫相对地址、虚地址（用户程序在经过汇编后目标代码常用，把首地址设为0，后面是相对地址）&lt;/p&gt;
&lt;p&gt;编译和加载时的地址绑定方法生成相同逻辑地址和物理地址，而执行时的地址绑定方案生成不同的逻辑和物理地址，这种情况通常称逻辑地址为虚拟地址&lt;/p&gt;
&lt;p&gt;运行时从虚拟地址到物理地址的映射由&lt;strong&gt;内存管理单元&lt;/strong&gt;来完成&lt;/p&gt;
&lt;h3 id=&#34;内存映射与保护&#34;&gt;内存映射与保护&lt;/h3&gt;
&lt;p&gt;内存通常分为两个区域：用于驻留操作系统和用于用户进程&lt;/p&gt;
&lt;p&gt;为输入队列中需要调入内存的进程分配内存空间，采用连续内存分配，每个进程位于一个连续的区域&lt;/p&gt;
&lt;p&gt;逻辑地址通过界限地址寄存器（判断是否合理）、重定位寄存器（加一个基地址）映射到物理地址，定位到内存&lt;/p&gt;
&lt;p&gt;内存保护：&lt;/p&gt;
&lt;p&gt;（1）界地址保护&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;设置地址上界寄存器、下界寄存器的地址检查机制&lt;/li&gt;
&lt;li&gt;基址、限长寄存器和动态地址转换机构&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1645944931/os-memory-2.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;CPU所能访问的存储器只有内存和CPU内的寄存器，因此执行指令以及指令使用的数据必须在这些可访问的存储设备中，否则就要在CPU使用前把数据移到内存中&lt;/p&gt;
&lt;p&gt;确定进程只能访问其合法范围，通过基地址寄存器和界限地址寄存器可以做到：&lt;/p&gt;
&lt;p&gt;基地址寄存器：a
界限地址寄存器：b
那么程序可以访问a~a+b的所有地址&lt;/p&gt;
&lt;p&gt;寄存器 $\to$ cache $\to$ 内存 $\to$ 外存&lt;/p&gt;
&lt;h3 id=&#34;交换&#34;&gt;交换&lt;/h3&gt;
&lt;p&gt;进程可以暂时从内存中交换到辅存上（换出），需要再次执行时再调回内存中（换入）&lt;/p&gt;
&lt;p&gt;处于阻塞或者优先级低，会被换出，优先级更改会被换入&lt;/p&gt;
&lt;h2 id=&#34;连续内存分配&#34;&gt;连续内存分配&lt;/h2&gt;
&lt;h3 id=&#34;内存分配&#34;&gt;内存分配&lt;/h3&gt;
&lt;p&gt;单一连续分配：分为系统区用户区，简单但是只适用于单用户
固定分区分配：用户空间划分好多个分区（分为大小均相同分区和大小不相同分区两种）
动态分区分配：用户空间一开始不划分，而是在装入内存时根据进程大小动态建立分区&lt;/p&gt;
&lt;p&gt;以下都是讨论动态分区（可变分区）：&lt;/p&gt;
&lt;p&gt;从一组可用孔中选择一个合适的空闲孔的方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;首次适应：分配第一个足够大的孔（空闲分区链以地址递增顺序链接）&lt;/li&gt;
&lt;li&gt;最佳适应：分配最小的足够大的孔（空闲分区链按长度递增顺序链接）&lt;/li&gt;
&lt;li&gt;最差适应：分配最大的孔&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;首次适应被认为既是最简单的，也是最好最快，最佳和最差容易生成小碎片（不要被最佳的名字忽悠，这家伙性能很差，会产生最多的外部碎片）&lt;/p&gt;
&lt;p&gt;分区式存储管理优缺点：
优点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;便于动态申请内存&lt;/li&gt;
&lt;li&gt;便于共享内存&lt;/li&gt;
&lt;li&gt;便于动态链接&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;缺点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;碎片问题，内存利用率不高&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;碎片&#34;&gt;碎片&lt;/h3&gt;
&lt;p&gt;内部碎片：固定分区方法会有内部碎片，程序所占空间小于分给它的空间，内部空间的间隙为内部碎片&lt;/p&gt;
&lt;p&gt;外部碎片：动态分区随着进程装入和移出内存，空闲内存被分为小片段，中间产生的空隙为外部碎片，首次适应和最佳适应都会有这种外部碎片问题&lt;/p&gt;
&lt;p&gt;解决外部碎片的方法：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;紧缩，仅在重定位是动态并在运行时可用，把所有的孔移到一段，开销较大（可重定位分区）&lt;/li&gt;
&lt;li&gt;允许物理地址非连续，只要有物理内存就能为进程分配，有两种互补的实现技术：分页、分段、段页&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;分页&#34;&gt;分页&lt;/h2&gt;
&lt;p&gt;以上是连续内存分配管理方式，接下来的分页和分段是非连续内存分配管理方式
连续分配方式，比如说一个需要1GB的程序，就必须要去内存找一块连续的1G空闲区间分配给它，而非连续分配方式可以分散地给这段程序分配内存空间&lt;/p&gt;
&lt;p&gt;分页不会产生外部碎片，每个进程平均产生半个块大小的内部碎片（很小的）&lt;/p&gt;
&lt;p&gt;把物理内存分为固定大小的块，称为帧，也叫物理块
把逻辑内存分为同样大小的块，称为页&lt;/p&gt;
&lt;p&gt;每个地址分为页号p和偏移d，前面的页号经过页表变成内存块号，后面的页内偏移直接对过去&lt;/p&gt;
&lt;p&gt;页表：为每个进程建立一张页表，将进程的每一页离散地储存在内存的物理块中（页号→块号）&lt;/p&gt;
&lt;p&gt;举个例子：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;32 - 12&lt;/th&gt;
&lt;th&gt;11 - 0&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;页号P&lt;/td&gt;
&lt;td&gt;偏移量W&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;说明总共有2&lt;sup&gt;20&lt;/sup&gt;页（也就是1M页），每页2&lt;sup&gt;12&lt;/sup&gt;大小（也就是4KB）&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1645944931/os-memory-3.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1645944931/os-memory-4.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;采用分页技术不会产生外部碎片，但是会有内部碎片，产生的原因是进程所需内存不是页的整数倍，最后一页可能装不满最后一个帧（物理块），导致产生页内碎片&lt;/p&gt;
&lt;p&gt;分页的一个重要特点是用户视角的内存和实际物理内存的分离，用户看到的是一整块内存用于一个进程，但实际的物理内存则是分散的，逻辑地址到物理地址的映射用户不知道。&lt;/p&gt;
&lt;p&gt;用户进程不能访问该进程非占用的内存，即无法访问页表规定之外的内存&lt;/p&gt;
&lt;p&gt;页表的初始地址放在寄存器中&lt;/p&gt;
&lt;h3 id=&#34;快表&#34;&gt;快表&lt;/h3&gt;
&lt;p&gt;快表（TLB）是一种高速缓冲寄存器，加速地址变换过程，通常采用TLB + 页表的形式&lt;/p&gt;
&lt;p&gt;每次要访存两次，为了提高速度，加入TLB（快表），本质是一个cache，可以看成是页表的子集，里面不是连续存储&lt;/p&gt;
&lt;p&gt;TLB由键和值组成，包括页表中的一小部分条目，逻辑地址的页号提交给TLB，如果命中那么直接得到帧号，否则就访问页表（TLB失效），同时把页号和帧号加入到TLB中&lt;/p&gt;
&lt;p&gt;快表的有效性基于局部性原理&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1645944931/os-memory-5.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;页号在TLB中被查找到的几率称为命中率，有效内存访问时间要按加权计算&lt;/p&gt;
&lt;p&gt;保护：每个帧有相关联的保护位&lt;/p&gt;
&lt;p&gt;共享页：可以共享公共代码&lt;/p&gt;
&lt;p&gt;二级页表和多级页表：把页表再一步离散化，用页表再映射页表&lt;/p&gt;
&lt;h2 id=&#34;分段&#34;&gt;分段&lt;/h2&gt;
&lt;p&gt;支持用户视角的内存管理方案，逻辑地址空间由一组段组成，分段地址中的地址包括段号和段内偏移，用户通过段号和段内偏移来指定地址 &amp;lt;segment-number, offset&amp;gt;&lt;/p&gt;
&lt;p&gt;为每个段分配一个连续的分区&lt;/p&gt;
&lt;p&gt;段表可以把二维数组定位到一维物理地址，每个段在段表中占一个表项，记录了该段在内存中的起始地址和段的长度（防止越界），段内地址不能大于段长&lt;/p&gt;
&lt;p&gt;段表示例：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;段号&lt;/th&gt;
&lt;th&gt;段首地址&lt;/th&gt;
&lt;th&gt;段长&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;50k&lt;/td&gt;
&lt;td&gt;20k&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;100k&lt;/td&gt;
&lt;td&gt;60k&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;...&lt;/td&gt;
&lt;td&gt;...&lt;/td&gt;
&lt;td&gt;...&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1645944931/os-memory-6.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;硬件支持：一对寄存器（段表基址寄存器和段表长度寄存器）&lt;/p&gt;
&lt;p&gt;也可以加快表，逻辑和页表类似&lt;/p&gt;
&lt;h3 id=&#34;分页和分段的比较&#34;&gt;分页和分段的比较&lt;/h3&gt;
&lt;p&gt;页是信息的物理单位，是出于系统管理的需要；
页的大小固定且由系统确定，由硬件实现，系统中的页只能有一种大小；
分页的作业地址空间是一维的&lt;/p&gt;
&lt;p&gt;段是信息的逻辑单位，是出于用户的需要；
段的长度不固定，取决于用户编写的程序的，通常由编译程序在对源程序进行编译时，根据信息的性质来划分；
分段的作业地址空间是二维的，除了要给出段名还要给出段长&lt;/p&gt;
&lt;h2 id=&#34;段页式&#34;&gt;段页式&lt;/h2&gt;
&lt;p&gt;段号+段内页号+页内地址&lt;/p&gt;
&lt;p&gt;首先被分为若干个逻辑段，每一段都有自己的段号，然后在里面分页&lt;/p&gt;
&lt;p&gt;段页式中，一个进程对应一张段表，每个段对应一张页表&lt;/p&gt;
&lt;p&gt;需要三次访问：第一次访问段表，第二次访问页表，第三次访问指令/数据的实际地址&lt;/p&gt;
&lt;p&gt;段页式的地址空间是二维的&lt;/p&gt;
&lt;p&gt;用分段方法来分配和管理用户地址空间，用分页方法来管理物理存储空间&lt;/p&gt;
&lt;h2 id=&#34;tips&#34;&gt;Tips：&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;链接完成重定位，形成逻辑地址，装载完成从逻辑地址到物理地址的变换&lt;/li&gt;
&lt;li&gt;内存保护需要操作系统和硬件机构合作完成&lt;/li&gt;
&lt;li&gt;固定分区、分页、段页都有内部碎片，不过分段没有内部碎片&lt;/li&gt;
&lt;li&gt;页式管理划分的页面大小是相等的&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;虚拟内存&#34;&gt;虚拟内存&lt;/h3&gt;
&lt;p&gt;引入原因：暂时不运行和运行完的程序仍然占用内存&lt;/p&gt;
&lt;p&gt;虚拟内存技术允许执行进程不必完全在内存中，程序可以比物理内存大，将用户逻辑内存与物理内存分开&lt;/p&gt;
&lt;p&gt;虚拟存储器：具有请求调入和置换的功能，能从逻辑上对内存容量加以扩充的一种储存系统，其运行速度接近内存，成本又接近外存&lt;/p&gt;
&lt;p&gt;虚拟内存特征：多次性、对换性、虚拟性&lt;/p&gt;
&lt;h3 id=&#34;局部性原理&#34;&gt;局部性原理&lt;/h3&gt;
&lt;p&gt;时间局部性原理：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;程序中的某一条指令一旦执行，不久以后该指令可能再次执行；某个数据被访问过，不久以后该数据可能再次被访问&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;空间局部性原理：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;某个储存单元被访问，不久之后其附近的储存单元也将被访问，一段时间内访问的地址可能集中在一定的范围内&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;虚拟内存的实现&#34;&gt;虚拟内存的实现&lt;/h3&gt;
&lt;p&gt;请求分页储存管理
请求分段储存管理
请求段页式储存管理&lt;/p&gt;
&lt;h3 id=&#34;请求分页管理方式&#34;&gt;请求分页管理方式&lt;/h3&gt;
&lt;p&gt;页表机制扩充：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;状态位P&lt;/li&gt;
&lt;li&gt;访问位A&lt;/li&gt;
&lt;li&gt;修改位M&lt;/li&gt;
&lt;li&gt;外存地址&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1645944931/os-memory-7.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;缺页中断&#34;&gt;缺页中断&lt;/h2&gt;
&lt;p&gt;在请求分页系统中，每当所要访问的页面不在内存时，就会产生缺页中断&lt;/p&gt;
&lt;h2 id=&#34;页面置换算法&#34;&gt;页面置换算法&lt;/h2&gt;
&lt;h3 id=&#34;1-最佳置换算法opt&#34;&gt;1. 最佳置换算法（OPT）&lt;/h3&gt;
&lt;p&gt;选择的被淘汰的页面是之后最长时间内不再访问的，可以保证最低的缺页率，但是无法预知未来所以无法实现，可以拿来测量其他算法&lt;/p&gt;
&lt;p&gt;谁最后访问，先换掉谁&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1645944931/os-memory-8.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;2-先进先出算法fifo&#34;&gt;2. 先进先出算法（FIFO）&lt;/h3&gt;
&lt;p&gt;优先淘汰最早进入内存的页面，因为不符合实际规律，用的比较少&lt;/p&gt;
&lt;p&gt;谁呆的时间最长，先换掉谁&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1645944931/os-memory-9.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;-3-最近最久未使用算法lru&#34;&gt;★ 3. 最近最久未使用算法（LRU）&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1645944931/os-memory-10.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;选择过程：
第一行从后往前数n个（n是物理块数），跳过重复的，那个就是要被替换的&lt;/p&gt;
&lt;p&gt;比如上面例子第八列的4，往前数3个 0→3→2（重复的0跳过了），那么就替换2
第十列的3，往前数3个 2-&amp;gt;4-&amp;gt;0，就替换0&lt;/p&gt;
&lt;h3 id=&#34;4-clock算法&#34;&gt;4. Clock算法&lt;/h3&gt;
&lt;h2 id=&#34;页面分配策略&#34;&gt;页面分配策略&lt;/h2&gt;
&lt;h3 id=&#34;驻留集大小&#34;&gt;驻留集大小&lt;/h3&gt;
&lt;p&gt;驻留集大小确定方式：
固定分配：给进程分配一定空间的物理块，后面不可变，即驻留集大小不变
可变分配：给进程分配的物理块在运行期间可以改变
局部置换：发生缺页时只能置换自己的物理块
全局置换：可以置换自己的，也可以置换其他进程的&lt;/p&gt;
&lt;p&gt;有三种组合方式：
固定分区局部置换：初始分配固定数量，缺点是很难确定初始分多少
可变分区全局置换：只要缺页就会获得新的物理块，确定是之后缺页率会增多
可变分区局部置换：根据发生缺页的频率来动态改变进程的物理块&lt;/p&gt;
&lt;h3 id=&#34;调入页面的时机&#34;&gt;调入页面的时机&lt;/h3&gt;
&lt;p&gt;预调页策略：一次调入若干个相邻的页（根据局部性原理），不过成功率不高，一般是运行前采用
请求调页策略：在缺页时调入，每次调一页，I/O开销大，一般是运行期间采用&lt;/p&gt;
&lt;h3 id=&#34;从何处调入页面&#34;&gt;从何处调入页面&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;有足够的对换区空间：全部从对换区调入所需页面，进程运行之前把所有有关文件从文件区复制到对换区&lt;/li&gt;
&lt;li&gt;没有足够的对换区空间：不会修改的文件直接从文件区调入，要修改的就得先去对换区&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;抖动&#34;&gt;抖动&lt;/h3&gt;
&lt;p&gt;页面置换中最糟糕的情况：刚换出的页面马上又要换入主存，刚换入的页面马上又要换出，这种频繁的调度称为抖动或颠簸&lt;/p&gt;
&lt;h2 id=&#34;tips-1&#34;&gt;Tips&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;虚拟内存的实现只能建立在离散分配的内存管理的基础上&lt;/li&gt;
&lt;li&gt;虚拟内存技术是补充内存逻辑空间的技术&lt;/li&gt;
&lt;li&gt;虚拟储存器理论逻辑上的最大容量由地址长度决定，实际上可能的最大容量为理论最大容量和内存外存和之中较小的那一个&lt;/li&gt;
&lt;li&gt;所有的调度策略都不可能完全避免抖动&lt;/li&gt;
&lt;/ul&gt;
</content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://yichengme.site/categories/%E6%8A%80%E6%9C%AF/" term="技术" label="技术" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://yichengme.site/tags/os/" term="OS" label="OS" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">操作系统基础（二）进程与线程</title>
            <link rel="alternate" type="text/html" href="https://yichengme.site/posts/os-basics-thread/" />
            <id>https://yichengme.site/posts/os-basics-thread/</id>
            <updated>2022-03-02T18:59:43&#43;08:00</updated>
            <published>2020-01-20T14:29:59&#43;08:00</published>
            <author>
                    <name>王毅诚</name>
                    <uri>https://yichengme.site/</uri>
                    <email>engine74396@gmail.com</email>
                    </author>
            <rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">本部分主要包括四个模块：进程与线程的概念、处理机调度算法、进程同步和死锁问题 一、进程与线程 进程 进程是进程实体的运行过程。是系统进行资源分配和调度的一个独立单位。……</summary>
            
                <content type="html">&lt;p&gt;本部分主要包括四个模块：进程与线程的概念、处理机调度算法、进程同步和死锁问题&lt;/p&gt;
&lt;h2 id=&#34;一进程与线程&#34;&gt;一、进程与线程&lt;/h2&gt;
&lt;h3 id=&#34;进程&#34;&gt;进程&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1645944201/os-thread-0.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;进程是进程实体的运行过程。是系统进行资源分配和调度的一个独立单位。&lt;/p&gt;
&lt;p&gt;进程包含运行时的所有信息，不仅仅包含程序代码，还包括当前活动，通过程序计数器和处理器寄存器的内容来表示；另外还经常包括堆栈端和数据段，还有可能包括堆&lt;/p&gt;
&lt;p&gt;正文段：包括全局变量、常量等
数据栈段：局部变量、传递的实参等
数据堆段：被分配的内存
PCB：进程自身的一些信息&lt;/p&gt;
&lt;p&gt;程序不是进程，程序是被动实体，进程是活动实体，当一个可执行文件被装入内存时，一个程序才可能成为进程。同一个程序也可以通过创建副本而成为多个独立的进程&lt;/p&gt;
&lt;p&gt;进程控制块 (Process Control Block, PCB) 描述进程的基本信息和运行状态，所谓的创建进程和撤销进程，都是指对 PCB 的操作。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;PCB是进程存在的唯一标志，动态性是进程最基本的特征。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;（下图显示了 4 个程序创建了 4 个进程，这 4 个进程可以并发地执行。）&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1645944201/os-thread-1.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;进程是由多程序的并发执行而提出的，和程序是截然不同的概念，进程的特点如下：
（了解即可）&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;动态性，有动态的地址空间，有生命周期（后面有图），动态产生、变化和消亡，最基本的特征&lt;/li&gt;
&lt;li&gt;并发性，多个进程实体能在一段时间内同时运行，引入进程的目的就是为了并发&lt;/li&gt;
&lt;li&gt;独立性，各进程地址空间相互独立&lt;/li&gt;
&lt;li&gt;异步性，各进程按照各自独立、不可预知的速度向前推进&lt;/li&gt;
&lt;li&gt;结构性，程序段、数据段、PCB&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;进程和程序的区别&#34;&gt;进程和程序的区别&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;程序是静态的，进程是动态的（算一个根本区别）&lt;/li&gt;
&lt;li&gt;程序是有序代码的集合，进程是程序的执行&lt;/li&gt;
&lt;li&gt;程序是永久的，进程是暂时的&lt;/li&gt;
&lt;li&gt;进程包括程序、数据和PCB&lt;/li&gt;
&lt;li&gt;通过多次执行，一个程序可以对应多个进程；通过调用关系，一个进程可以包括多个程序&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;进程状态的切换-&#34;&gt;进程状态的切换 ★&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1645944201/os-thread-2.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;最重要的一条是从就绪到运行&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;就绪状态：等待被调度，进程已经获得了除了处理机之外的一切所需资源&lt;/li&gt;
&lt;li&gt;运行状态：进程正在处理机上运行，对于单CPU而言，同一时间运行的进程只能有一个&lt;/li&gt;
&lt;li&gt;等待状态：等待资源或等待I/O，即使处理机空闲也无法运行&lt;/li&gt;
&lt;li&gt;新的状态：进程正在被创建，尚未转化到运行状态&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;应该注意以下内容：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;只有就绪态和运行态可以相互转换，其它的都是单向转换。就绪状态的进程通过调度算法从而获得 CPU 时间，转为运行状态；而运行状态的进程，在分配给它的 CPU 时间片用完之后就会转为就绪状态，等待下一次调度。&lt;/li&gt;
&lt;li&gt;不能从等待直接到运行，因为在等I/O，给CPU也没有。不能从就绪到等待，因为就绪只缺CPU，别的都不缺，给了也没用。&lt;/li&gt;
&lt;li&gt;等待状态是缺少需要的资源从而由运行状态转换而来，但是该资源不包括 CPU 时间，缺少 CPU 时间会从运行态转换为就绪态。&lt;/li&gt;
&lt;li&gt;某个时间点上等待只能等一个资源&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;进程间通信&#34;&gt;进程间通信&lt;/h3&gt;
&lt;p&gt;不和其他任何进程共享数据的进程是独立的，如果互相有意向那么该进程是协作的&lt;/p&gt;
&lt;p&gt;有许多理由：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;信息共享&lt;/li&gt;
&lt;li&gt;提高运算速度&lt;/li&gt;
&lt;li&gt;模块化&lt;/li&gt;
&lt;li&gt;方便&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;进程之间交换数据不能通过访问地址空间，因为进程各自的地址空间是私有的&lt;/p&gt;
&lt;p&gt;PV操作是低级进程通信方式，高级进程通信方式包括：&lt;strong&gt;共享内存、消息传递、管道通信、共享文件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;共享内存比消息传递快，它可以达到内存的速度，要求通信进程共享一些变量，进程通过使用这些变量来共享信息、主要由程序员提供通信，操作系统只需要提供共享呢内存；&lt;/p&gt;
&lt;p&gt;消息传递更易于实现，适合交换少量的数据，不需要避免冲突，允许进程交换信息。提供通信的主要职责在于操作系统本身&lt;/p&gt;
&lt;h3 id=&#34;进程控制块pcb&#34;&gt;进程控制块(PCB)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;进程状态：包括新的、就绪、运行、等待、停止&lt;/li&gt;
&lt;li&gt;程序计数器：表示要执行的下一个指令的地址&lt;/li&gt;
&lt;li&gt;CPU寄存器：包括很多东西，中断时要保存&lt;/li&gt;
&lt;li&gt;CPU调度信息：包括进程优先级、调度队列指针和其他调度参数&lt;/li&gt;
&lt;li&gt;内存管理信息：&lt;/li&gt;
&lt;li&gt;记账信息：&lt;/li&gt;
&lt;li&gt;I/O状态信息：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;PCB块是进程的唯一标识，OS就是通过控制PCB来对并发执行的进程进行控制和管理的&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1645944201/os-thread-3.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;进程调度&#34;&gt;进程调度&lt;/h3&gt;
&lt;p&gt;进程调度会选择一个可用的程序到CPU上执行&lt;/p&gt;
&lt;h4 id=&#34;调度队列&#34;&gt;调度队列&lt;/h4&gt;
&lt;p&gt;进程到系统后会进入作业队列，包括所有进程。等待运行的会进入到就绪队列。通常用链表表示&lt;/p&gt;
&lt;h4 id=&#34;调度程序&#34;&gt;调度程序&lt;/h4&gt;
&lt;p&gt;操作系统必须按某种方式从队列中选择进程，进程的选择是由相应的调度程序来执行的&lt;/p&gt;
&lt;p&gt;短期调度程序
长期调度程序&lt;/p&gt;
&lt;h4 id=&#34;上下文切换&#34;&gt;上下文切换&lt;/h4&gt;
&lt;p&gt;一个进程运行时，CPU中所有寄存器中的内容、进程的状态以及运行栈中的内容被称为进程的上下文（和PCB对应）&lt;/p&gt;
&lt;p&gt;通过执行一个状态保存来&lt;strong&gt;保存&lt;/strong&gt;CPU当前状态，之后执行一个状态&lt;strong&gt;恢复&lt;/strong&gt;重新开始运行。将CPU切换到另一个进程需要保存当前状态并恢复另一个进程的状态，这一状态切换称为上下文切换。&lt;/p&gt;
&lt;h3 id=&#34;进程控制&#34;&gt;进程控制&lt;/h3&gt;
&lt;h4 id=&#34;进程的创建&#34;&gt;进程的创建&lt;/h4&gt;
&lt;p&gt;允许一个进程创建另一个进程，创建者称为父进程，被创建的称为子进程，子进程可以获得父进程的所有资源，子进程结束会归还资源给父进程，父进程结束必须同时撤销子进程。&lt;/p&gt;
&lt;p&gt;创建进程的过程：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;分配唯一的进程标志号(pid)&lt;/li&gt;
&lt;li&gt;分配资源&lt;/li&gt;
&lt;li&gt;初始化PCB&lt;/li&gt;
&lt;li&gt;插入到就绪队列&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;通过fork()系统调用，可以创建新进程&lt;/p&gt;
&lt;h4 id=&#34;进程的终止&#34;&gt;进程的终止&lt;/h4&gt;
&lt;p&gt;包括正常结束和异常结束&lt;/p&gt;
&lt;p&gt;终止进程的过程&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;根据pid搜索PCB，读出状态&lt;/li&gt;
&lt;li&gt;立即终止&lt;/li&gt;
&lt;li&gt;若还有子进程，一并终止&lt;/li&gt;
&lt;li&gt;归还资源&lt;/li&gt;
&lt;li&gt;把PCB从队列中删除&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;如果一个进程终止，那么它的所有子进程都终止。这种现象称为级联终止&lt;/p&gt;
&lt;h4 id=&#34;进程的阻塞&#34;&gt;进程的阻塞&lt;/h4&gt;
&lt;p&gt;自发的行为 block()&lt;/p&gt;
&lt;h4 id=&#34;进程的唤醒&#34;&gt;进程的唤醒&lt;/h4&gt;
&lt;p&gt;wakeup()&lt;/p&gt;
&lt;h3 id=&#34;线程&#34;&gt;线程&lt;/h3&gt;
&lt;p&gt;线程是CPU使用的基本单元，由线程ID、程序计数器、寄存器集合和栈组成，它与属于同一进程的其他线程共享代码段、数据段和其他操作系统资源&lt;/p&gt;
&lt;p&gt;线程是独立调度的基本单位，引入线程的目的是为了简化进程间的通信，减小程序在并发执行时所付出的时间开销，提高操作系统的并发性&lt;/p&gt;
&lt;p&gt;线程自己不拥有系统资源，只有一点点必要的运行资源，但是它可以和同一进程的其他线程一起共享进程拥有的全部资源&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1645944201/os-thread-4.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;举个栗子：QQ和浏览器是两个进程，浏览器进程里面有很多线程，例如 HTTP 请求线程、事件响应线程、渲染线程等等，线程的并发执行使得在浏览器中点击一个新链接从而发起 HTTP 请求时，浏览器还可以响应用户的其它事件。&lt;/p&gt;
&lt;p&gt;多线程编程的优点:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;响应度高&lt;/li&gt;
&lt;li&gt;资源共享&lt;/li&gt;
&lt;li&gt;经济&lt;/li&gt;
&lt;li&gt;多处理器体系机构的利用&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;多线程模型&#34;&gt;多线程模型&lt;/h4&gt;
&lt;p&gt;有两种不同的方法来提供线程支持：用户层的用户线程和内核层的内核线程，二者有三种对应关系&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;多对一模型：多个用户线程映射到一个内核线程&lt;/li&gt;
&lt;li&gt;一对一模型：有更好的并发功能，但是开销比较大&lt;/li&gt;
&lt;li&gt;多对多模型&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;线程池&#34;&gt;线程池&lt;/h4&gt;
&lt;p&gt;为了解决创建线程时间和丢弃，以及没有限制线程数量可能会导致资源用尽的问题，产生了线程池的解决方法&lt;/p&gt;
&lt;p&gt;线程池会在进程开始时创建一定数量的线程，并放入池中来等待，服务器每次收到请求就会唤醒池中的一个线程，线程完成了任务又会返回池中。如果池中没有可用线程，服务器会等待。&lt;/p&gt;
&lt;p&gt;优点：
使用现有线程比创建新线程快
限制了数量，不会耗尽资源&lt;/p&gt;
&lt;h4 id=&#34;线程库&#34;&gt;线程库&lt;/h4&gt;
&lt;p&gt;线程库为程序员提供创建和管理线程的api&lt;/p&gt;
&lt;p&gt;Pthread
Win32
Java&lt;/p&gt;
&lt;h4 id=&#34;多线程问题&#34;&gt;多线程问题&lt;/h4&gt;
&lt;p&gt;fork()和exec()&lt;/p&gt;
&lt;p&gt;取消：异步取消、延迟取消&lt;/p&gt;
&lt;h3 id=&#34;进程与线程的区别&#34;&gt;进程与线程的区别&lt;/h3&gt;
&lt;h4 id=&#34;资源方面&#34;&gt;资源方面&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;进程是资源分配的基本单位&lt;/strong&gt;，但是线程不拥有资源，线程可以访问隶属进程的资源，线程没有自己独立的地址空间。&lt;/p&gt;
&lt;h4 id=&#34;调度方面&#34;&gt;调度方面&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;线程是独立调度的基本单位&lt;/strong&gt;，在同一进程中，线程的切换不会引起进程切换，从一个进程中的线程切换到另一个进程中的线程时，会引起进程切换。&lt;/p&gt;
&lt;h4 id=&#34;系统开销&#34;&gt;系统开销&lt;/h4&gt;
&lt;p&gt;由于创建或撤销进程时，系统都要为之分配或回收资源，如内存空间、I/O 设备等，所付出的开销远大于创建或撤销线程时的开销。类似地，在进行进程切换时，涉及当前执行进程 CPU 环境的保存及新调度进程 CPU 环境的设置，而线程切换时只需保存和设置少量寄存器内容，开销很小。&lt;/p&gt;
&lt;h4 id=&#34;通信方面&#34;&gt;通信方面&lt;/h4&gt;
&lt;p&gt;线程间可以通过直接读写同一进程中的数据进行通信，但是进程通信需要借助 IPC。&lt;/p&gt;
&lt;h4 id=&#34;并发性&#34;&gt;并发性&lt;/h4&gt;
&lt;p&gt;一个进程间的多个线程可以并发&lt;/p&gt;
&lt;h3 id=&#34;tips&#34;&gt;Tips&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;一个进程被不同的地方调用，会形成不同的进程&lt;/li&gt;
&lt;li&gt;同一个线程可以被多个进程调用，线程还是同一个&lt;/li&gt;
&lt;li&gt;对进程的管理和控制是通过执行各种原语来实现的&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;二处理机调度&#34;&gt;二、处理机调度&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1645944201/os-thread-5.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;单处理器系统，每次只允许一个进程运行，这个效率啊，efficiency。&lt;/p&gt;
&lt;p&gt;每当CPU空闲时，操作系统就必须从就绪队列中选择一个进程来执行，由短期调度程序或者CPU调度来执行。调度程序从内存中选择一个能够执行的进程并为之分配CPU&lt;/p&gt;
&lt;p&gt;就绪队列可实现为FIFO队列、优先队列、树或者简单的无序链表&lt;/p&gt;
&lt;p&gt;CPU调度决策可在如下四种环境下发生：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;进程从运行切换到等待（I/O请求、调用wait等）&lt;/li&gt;
&lt;li&gt;从运行切换到就绪（出现中断）&lt;/li&gt;
&lt;li&gt;从等待切换到就绪（I/O完成）&lt;/li&gt;
&lt;li&gt;终止&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;1、4的情况下，调度方式是非抢占的，2、3是抢占的&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;调度的层级：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;作业调度：给作业获得竞争处理机的机会&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;中级调度：内存调度，提高内存利用率和系统吞吐量&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;进程调度：低级调度，从就绪队列选进程分配处理机&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;进程调度方式：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;剥夺调度：有另一个优先级高的进程进入，立即调度&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;非剥夺调度：等一个进程介绍才会调度，不抢&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;调度准则&#34;&gt;调度准则&lt;/h3&gt;
&lt;p&gt;用于比较的特征准则有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CPU使用率&lt;/li&gt;
&lt;li&gt;吞吐量：一个单位时间内完成进程的数量&lt;/li&gt;
&lt;li&gt;周转时间：从进程提交到进程完成的时间称为周转时间&lt;/li&gt;
&lt;li&gt;平均周转时间：多个作业周转时间平均值&lt;/li&gt;
&lt;li&gt;带权周转时间：周转时间/运行时间&lt;/li&gt;
&lt;li&gt;平均带权周转时间：多个作业带权周转时间的平均值&lt;/li&gt;
&lt;li&gt;等待时间：为最就绪队列中等待所花的时间，调度算法不影响进程运行时间，只影响在队列中的等待时间&lt;/li&gt;
&lt;li&gt;响应时间：从提交请求到响应请求的时间&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;调度算法&#34;&gt;调度算法&lt;/h3&gt;
&lt;p&gt;CPU调度是多道程序操作系统的基础，通过在进程之间切换CPU，操作系统可以提高计算机的吞吐率。&lt;/p&gt;
&lt;p&gt;不同环境的调度算法目标不同，因此需要针对不同环境来讨论调度算法。&lt;/p&gt;
&lt;p&gt;几个概念：
&lt;strong&gt;周转时间&lt;/strong&gt;：最后完成的时刻-刚进来的时刻，即包括等待时间与运行时间
&lt;strong&gt;带权周转时间&lt;/strong&gt;：周转时间/进程运行时间
&lt;strong&gt;响应比&lt;/strong&gt;：（等待时间+要求服务时间）/ 要求服务时间&lt;/p&gt;
&lt;h4 id=&#34;1-批处理系统&#34;&gt;1. 批处理系统&lt;/h4&gt;
&lt;p&gt;批处理系统没有太多的用户操作，在该系统中，调度算法目标是保证吞吐量和周转时间（从提交到终止的时间）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.1 先来先服务 first-come first-serverd（FCFS）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;按照请求的顺序进行调度。&lt;/p&gt;
&lt;p&gt;用FIFO队列就可以实现&lt;/p&gt;
&lt;p&gt;有利于长作业，但不利于短作业，因为短作业必须一直等待前面的长作业执行完毕才能执行，而长作业又需要执行很长时间，造成了短作业等待时间过长。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.2 短作业优先 shortest job first（SJF）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;按估计运行时间最短的顺序进行调度。&lt;/p&gt;
&lt;p&gt;SJF算法调度理论上确实是最佳的，但问题在于如何知道下一个CPU区间的长度&lt;/p&gt;
&lt;p&gt;长作业有可能会饿死，处于一直等待短作业执行完毕的状态。因为如果一直有短作业到来，那么长作业永远得不到调度。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.3 最短剩余时间优先 shortest remaining time next（SRTN）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;按估计剩余时间最短的顺序进行调度。&lt;/p&gt;
&lt;h4 id=&#34;2-交互式系统&#34;&gt;2. 交互式系统&lt;/h4&gt;
&lt;p&gt;交互式系统有大量的用户交互操作，在该系统中调度算法的目标是快速地进行响应。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.1 时间片轮转&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;将所有就绪进程按 FCFS 的原则排成一个队列，每次调度时，把 CPU 时间分配给队首进程，该进程可以执行一个时间片。当时间片用完时，由计时器发出时钟中断，调度程序便停止该进程的执行，并将它送往就绪队列的末尾，同时继续把 CPU 时间分配给队首的进程。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;时间片轮转算法是为了多个用户能及时干预系统&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;时间片轮转算法的效率和时间片的大小有很大关系：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;因为进程切换都要保存进程的信息并且载入新进程的信息，如果时间片太小，会导致进程切换得太频繁，在进程切换上就会花过多时间。&lt;/li&gt;
&lt;li&gt;而如果时间片过长，那么实时性就不能得到保证。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;2.2 优先级调度&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;为每个进程分配一个优先级，按优先级进行调度。&lt;/p&gt;
&lt;p&gt;为了防止低优先级的进程永远等不到调度，可以随着时间的推移增加等待进程的优先级。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.3 多级反馈队列&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一个进程需要执行 100 个时间片，如果采用时间片轮转调度算法，那么需要交换 100 次。&lt;/p&gt;
&lt;p&gt;多级队列是为这种需要连续执行多个时间片的进程考虑，它设置了多个队列，每个队列时间片大小都不同，例如 1,2,4,8,..。进程在第一个队列没执行完，就会被移到下一个队列。这种方式下，之前的进程只需要交换 7 次。&lt;/p&gt;
&lt;p&gt;每个队列优先权也不同，最上面的优先权最高。因此只有上一个队列没有进程在排队，才能调度当前队列上的进程。&lt;/p&gt;
&lt;p&gt;可以将这种调度算法看成是时间片轮转调度算法和优先级调度算法的结合。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1645944201/os-thread-7.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;3-实时系统&#34;&gt;3. 实时系统&lt;/h4&gt;
&lt;p&gt;实时系统要求一个请求在一个确定时间内得到响应。&lt;/p&gt;
&lt;p&gt;分为硬实时和软实时，前者必须满足绝对的截止时间，后者可以容忍一定的超时。&lt;/p&gt;
&lt;h3 id=&#34;tips-1&#34;&gt;Tips&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;考虑到系统资源利用率，要选择让I/O繁忙型作业有更高的优先级&lt;/li&gt;
&lt;li&gt;作业和进程的区别，作业由用户提交、以用户任务为单位，进程由系统自动生成、以操作系统控制为单位&lt;/li&gt;
&lt;li&gt;分时操作系统采用时间片轮转调度算法&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;三进程同步&#34;&gt;三、进程同步&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;%C2%B5https://res.cloudinary.com/dbmkzs2ez/image/upload/v1645944201/os-thread-6.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;同步与互斥&#34;&gt;同步与互斥&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;同步&lt;/strong&gt;：直接相互制约同步&lt;/p&gt;
&lt;p&gt;进程之间的合作，比如A进程向B进程提供数据，多个进程会按一定顺序执行；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;互斥&lt;/strong&gt;：间接相互制约&lt;/p&gt;
&lt;p&gt;源于资源共享，几个进程抢相同的资源，多个进程在同一时刻只有一个进程能进入临界区。&lt;/p&gt;
&lt;p&gt;互斥可能会出现两种情况：
饥饿：拥有其他所有资源却得不到CPU的就绪进程
死锁：进程之间相互等待对方资源却无法得到，陷入永远的阻塞&lt;/p&gt;
&lt;p&gt;进程互斥实际上是进程同步的一种特殊情况，可以认为是逐次使用互斥资源&lt;/p&gt;
&lt;h3 id=&#34;临界资源和临界区&#34;&gt;临界资源和临界区&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;临界资源&lt;/strong&gt; ：一次仅允许一个进程使用的资源，比如说硬件资源打印机什么的，一些非硬件资源比如一些变量、数据&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;临界区&lt;/strong&gt; ：对临界资源进行访问的那段代码称为临界区&lt;/p&gt;
&lt;p&gt;不论是硬件临界资源还是软件临界资源，多个进程必须互斥地对它们进行访问&lt;/p&gt;
&lt;p&gt;把临界资源的访问分为四个部分：进入区、临界区、退出区、剩余区&lt;/p&gt;
&lt;p&gt;为了互斥访问临界资源，每个进程在进入临界区之前，需要先进行检查，看是否正在被访问，如果未被访问就可以进入临界区，并设置它正在被访问的标志。在进入临界区之前执行的这段代码称为进入区。&lt;/p&gt;
&lt;p&gt;在出来之前也要运行一段代码，把访问标志清除，这段代码称为退出区。&lt;/p&gt;
&lt;p&gt;进入区和退出区起到互斥保护临界区的作用&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;k&#34;&gt;while&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;){&lt;/span&gt;
  &lt;span class=&#34;n&#34;&gt;entry&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;section&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 进入区
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;n&#34;&gt;critical&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;section&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 临界区
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;n&#34;&gt;exit&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;section&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 退出区
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;n&#34;&gt;remainer&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;section&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 剩余区
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;临界区不是原语的，中途可以出现中断等（反正其他的还是进不来）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;同步机制的原则：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;空闲让进&lt;/li&gt;
&lt;li&gt;忙则等待&lt;/li&gt;
&lt;li&gt;有限等待&lt;/li&gt;
&lt;li&gt;让权等待&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;信号量&#34;&gt;信号量&lt;/h3&gt;
&lt;p&gt;信号量（Semaphore）是一个整型变量，可以对其执行wait和signal操作，也就是常见的 P 和 V 操作。&lt;/p&gt;
&lt;p&gt;wait是P（申请资源），signal是V（释放资源）&lt;/p&gt;
&lt;p&gt;S.value的初值就代表资源的数目，如果S.value &amp;lt; 0，那么其绝对值表示阻塞的进程的个数&lt;/p&gt;
&lt;h4 id=&#34;整型信号量&#34;&gt;整型信号量&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;P&lt;/strong&gt; ：如果信号量S大于 0 ，执行 -1 操作；如果信号量等于 0，进程睡眠，等待信号量大于 0；
&lt;strong&gt;V&lt;/strong&gt; ：对信号量S执行 +1 操作，唤醒睡眠的进程让其完成 down 操作。&lt;/p&gt;
&lt;p&gt;P V操作需要被设计成原语，不可分割，通常的做法是在执行这些操作的时候屏蔽中断。&lt;/p&gt;
&lt;p&gt;缺点是在S&amp;lt;=0时，会出现”忙等”，没有遵循让权等待&lt;/p&gt;
&lt;h4 id=&#34;记录型信号量&#34;&gt;记录型信号量&lt;/h4&gt;
&lt;p&gt;再增加一个进程链表，链接上述的等待进程
P V操作修改为&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-C++&#34; data-lang=&#34;C++&#34;&gt;&lt;span class=&#34;n&#34;&gt;P&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;semaphore&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;S&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;n&#34;&gt;S&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;value&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;S&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;value&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 请求一个资源
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;S&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;value&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;block&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;S&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;L&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 如果资源没了，就调用block阻塞掉，插入到信号量链表S.L中
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;n&#34;&gt;V&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;semaphore&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;S&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;n&#34;&gt;S&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;value&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;S&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;value&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 释放一个资源
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;S&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;value&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;wakeup&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;S&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;L&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 如果释放掉后还是堵着的，那么唤醒一个堵着的资源
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;c1&#34;&gt;//（如果释放掉后不堵了，前一步也是0，说明链表原本就没有东西，所以不存在wakeup）
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;&lt;strong&gt;实现前驱关系&lt;/strong&gt;：比如S1结束才能执行S2，可以设置一个信号量a，初始值为0，S1中V(a)，S2中P(a)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;实现互斥关系&lt;/strong&gt;：比如S1和S2互斥，可以设置一个信号量a，初始值为1，S1、S2都用P(a) V(a)夹紧中间过程&lt;/p&gt;
&lt;p&gt;如果信号量的取值只能为 0 或者 1，那么就成为了  &lt;strong&gt;互斥量（Mutex）&lt;/strong&gt; ，0 表示临界区已经加锁，1 表示临界区解锁。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;k&#34;&gt;typedef&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;semaphore&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;semaphore&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;mutex&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;P1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;down&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;mutex&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;// 临界区
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;n&#34;&gt;up&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;mutex&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;P2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;down&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;mutex&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;// 临界区
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;n&#34;&gt;up&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;mutex&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h3 id=&#34;实现同步互斥&#34;&gt;实现同步互斥&lt;/h3&gt;
&lt;h4 id=&#34;软件实现petersons-algotithm&#34;&gt;软件实现：Peterson&#39;s Algotithm&lt;/h4&gt;
&lt;p&gt;flag表示有这个意愿，turn表示把回合让给谁，这是一个很谦让的算法，进程i要来先打个招呼，说我有执行的打算，然后把回合让给进程j，如果j没打算，那么i直接进去，进去之后，j如果再进来，直接把回合又给了i，j达到了while等待条件，只能等着i的执行完之后，j再进去&lt;/p&gt;
&lt;p&gt;P[i]进程&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span class=&#34;n&#34;&gt;flag&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;TRUE&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;turn&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;while&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;flag&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;turn&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;==&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// j正在访问临界区，i等着
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;critical&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;section&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;flag&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;FALSE&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;remainder&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;section&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;P[j]进程&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span class=&#34;n&#34;&gt;flag&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;TRUE&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;turn&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;while&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;flag&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;turn&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;==&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;critical&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;section&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;flag&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;FALSE&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;remainer&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;section&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h3 id=&#34;典型问题生产者-消费者问题&#34;&gt;典型问题：生产者-消费者问题&lt;/h3&gt;
&lt;p&gt;这是一个非常重要而典型的问题，进程同步60%以上的题目都是生产者消费者的改编&lt;/p&gt;
&lt;p&gt;问题描述：有一群生产者进程在生产产品，并将这些产品提供给消费者进程去进行消费。使用一个缓冲区来保存物品，只有缓冲区没有满，生产者才可以放入物品；只有缓冲区不为空，消费者才可以拿走物品。&lt;/p&gt;
&lt;p&gt;因为缓冲区属于临界资源，因此需要使用一个互斥量 mutex 来控制对缓冲区的互斥访问。（缓冲区用循环队列就可以模拟）&lt;/p&gt;
&lt;p&gt;为了同步生产者和消费者的行为，需要记录缓冲区中物品的数量。数量可以使用信号量来进行统计，这里需要使用两个信号量：empty 记录空缓冲区的数量，full 记录满缓冲区的数量。其中，empty 信号量是在生产者进程中使用，当 empty 不为 0 时，生产者才可以放入物品；full 信号量是在消费者进程中使用，当 full 信号量不为 0 时，消费者才可以取走物品。&lt;/p&gt;
&lt;p&gt;注意，不能先对缓冲区进行加锁，再测试信号量。也就是说，不能先执行 down(mutex) 再执行 down(empty)。如果这么做了，那么可能会出现这种情况：生产者对缓冲区加锁后，执行 down(empty) 操作，发现 empty = 0，此时生产者睡眠。消费者不能进入临界区，因为生产者对缓冲区加锁了，消费者就无法执行 up(empty) 操作，empty 永远都为 0，导致生产者永远等待下，不会释放锁，消费者因此也会永远等待下去。&lt;/p&gt;
&lt;p&gt;顺序执行的时候显然没有任何问题，然而在并发执行的时候，就会出现差错，比如共享变量counter，会出现冲突。解决的关键是将counter作为临界资源来处理。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;cp&#34;&gt;##define N 100
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;typedef&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;semaphore&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;semaphore&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;mutex&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;semaphore&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;empty&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;N&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;semaphore&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;full&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;

&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;producer&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;while&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;TRUE&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;item&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;produce_item&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;down&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;empty&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;down&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;mutex&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;insert_item&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;item&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;up&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;mutex&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;up&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;full&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;consumer&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;while&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;TRUE&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;down&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;full&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;down&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;mutex&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
        &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;item&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;remove_item&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;consume_item&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;item&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;up&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;mutex&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;up&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;empty&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;&lt;strong&gt;实际例子：吃水果问题&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;桌子上有一个盘子，可以放一个水果。爸爸每次放一个苹果，妈妈每次放一个桔子；女儿每次吃一个苹果，儿子每次吃一个桔子。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;30
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;31
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;32
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;33
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;34
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;35
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;36
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;37
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-C++&#34; data-lang=&#34;C++&#34;&gt;&lt;span class=&#34;n&#34;&gt;semaphore&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;S&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;  &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;SA&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;SO&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 盘子的互斥信号量、苹果和桔子的互斥信号量
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;father&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(){&lt;/span&gt;
  &lt;span class=&#34;k&#34;&gt;while&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;){&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;have&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;an&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;apple&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;P&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;S&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;put&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;an&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;apple&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;V&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;SA&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
  &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;n&#34;&gt;mother&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(){&lt;/span&gt;
  &lt;span class=&#34;k&#34;&gt;while&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;){&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;have&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;an&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;orange&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;P&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;S&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;put&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;an&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;orange&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;V&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;SO&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
  &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;n&#34;&gt;daughter&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(){&lt;/span&gt;
  &lt;span class=&#34;k&#34;&gt;while&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;){&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;P&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;SA&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;get&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;an&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;apple&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;V&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;S&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;eat&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;an&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;apple&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
  &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;n&#34;&gt;son&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(){&lt;/span&gt;
  &lt;span class=&#34;k&#34;&gt;while&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;){&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;P&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;SO&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;get&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;an&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;orange&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;V&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;S&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 吃完之后要V(S)才能接着让爸爸妈妈接着放
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;n&#34;&gt;eat&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;an&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;orange&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
  &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h3 id=&#34;典型问题哲学家就餐问题&#34;&gt;典型问题：哲学家就餐问题&lt;/h3&gt;
&lt;p&gt;这是由Dijkstra提出的典型进程同步问题&lt;/p&gt;
&lt;p&gt;5个哲学家坐在桌子边，桌子上有5个碗和5支筷子，哲学家开始思考，如果饥饿了，就拿起两边筷子进餐（两支筷子都拿起才能进餐），用餐后放下筷子，继续思考&lt;/p&gt;
&lt;p&gt;多个临界资源的问题&lt;/p&gt;
&lt;p&gt;只考虑筷子互斥：可能会产生死锁，比如所有人都同时拿起右边筷子，左边无限等待
再考虑吃饭行为互斥：同时只让一个人吃饭，肯定不会冲突或死锁，但是资源比较浪费&lt;/p&gt;
&lt;p&gt;解决方法1：允许4位哲学家同时去拿左边的筷子&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-C++&#34; data-lang=&#34;C++&#34;&gt;&lt;span class=&#34;n&#34;&gt;semaphore&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;chopstick&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;5&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;};&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 筷子信号量
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;semaphore&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;eating&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;4&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 允许四个哲学家可以同时拿筷子
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;
&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;philosopher&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;){&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 第i个哲学家的程序
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;n&#34;&gt;thinking&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
  &lt;span class=&#34;n&#34;&gt;P&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;eating&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
  &lt;span class=&#34;n&#34;&gt;P&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;chopstick&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]);&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 请求左边的筷子
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;n&#34;&gt;P&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;chopstick&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;%&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;5&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]);&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 请求右边的筷子
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;n&#34;&gt;eating&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
  &lt;span class=&#34;n&#34;&gt;V&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;chopstick&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;%&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;5&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]);&lt;/span&gt;
  &lt;span class=&#34;n&#34;&gt;V&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;chopstick&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]);&lt;/span&gt;
  &lt;span class=&#34;n&#34;&gt;V&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;eating&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;解决方式2：奇数位置的哲学家先左后右，偶数位置的哲学家先右后左&lt;/p&gt;
&lt;h3 id=&#34;典型问题读者写者问题&#34;&gt;典型问题：读者写者问题&lt;/h3&gt;
&lt;p&gt;读进程：Reader进程
写进程：Writer进程&lt;/p&gt;
&lt;p&gt;允许多个进程同时读一个共享文件，因为读不会使数据混乱；但同时仅仅允许一个写者在写&lt;/p&gt;
&lt;p&gt;写-写互斥，写-读互斥，读-读允许&lt;/p&gt;
&lt;p&gt;纯互斥问题，没有同步关系没有先后之分&lt;/p&gt;
&lt;p&gt;需要多加一个读者计数器，并且修改这个时要同步，所以要再加一个变量保证修改count时的互斥&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;30
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-C++&#34; data-lang=&#34;C++&#34;&gt;&lt;span class=&#34;n&#34;&gt;semaphore&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;rmutex&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;wmutex&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// readcount的互斥信号量，数据的互斥信号量
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;readcount&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;

&lt;span class=&#34;n&#34;&gt;Reader&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(){&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 每次进入和退出因为涉及readcount变化，要保证同时只有一个，所以分别设置rmutex
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;k&#34;&gt;while&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;){&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;P&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;rmutex&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 抢readcount信号量，防止多个reader同时进入 导致readcount变化不同
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;readcount&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;==&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;){&lt;/span&gt;
      &lt;span class=&#34;n&#34;&gt;P&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;wmutex&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 第一个进来的读者，抢公共缓冲区
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;readcount&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;V&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;rmutex&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 其他reader可以进来了
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;perform&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;read&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;operation&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;

    &lt;span class=&#34;n&#34;&gt;P&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;rmutex&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 再抢一次，使每次只有一个退出
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;n&#34;&gt;readcount&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;readcount&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;==&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;){&lt;/span&gt;
      &lt;span class=&#34;n&#34;&gt;V&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;wmutex&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 最后一个reader走了，释放公共缓冲区
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;V&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;rmutex&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
  &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;n&#34;&gt;Writer&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(){&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 写者很简单，只需要考虑wmutex公共缓冲区
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;k&#34;&gt;while&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;){&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;P&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;wmutex&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;perform&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;write&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;operation&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;V&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;wmutex&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
  &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;上面的算法可能会导致写者可能会被插队，如果是RWR，中间的W被堵了，结果后面的R还能进去，W还要等后面的R读完&lt;/p&gt;
&lt;p&gt;变形：让写者优先，如果有写者，那么后来的读者都要阻塞，实现完全按照来的顺序进行读写操作。
解决方法：再增加一个wfirst信号量，初始为1，在读者的Read()和之前的阶段和写者部分都加一个P(wfirst)作为互斥入口，结尾V(wfirst)释放即可&lt;/p&gt;
&lt;p&gt;变形：让写者真正优先，可以插队
解决方法：增加一个writecount统计，也就是加一个写者队列，写者可以霸占这个队列一直堵着&lt;/p&gt;
&lt;h3 id=&#34;例子汽车过窄桥问题&#34;&gt;例子：汽车过窄桥问题&lt;/h3&gt;
&lt;p&gt;来往各有两条路，但是中间有一个窄桥只能容纳一辆车通过，方向一样的车可以一起过&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;30
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;31
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;32
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;33
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;34
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;35
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;36
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;37
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;38
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;39
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;40
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;41
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;42
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-C++&#34; data-lang=&#34;C++&#34;&gt;&lt;span class=&#34;n&#34;&gt;semaphore&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;mutex1&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;mutex2&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;bridge&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;count1&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;count2&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;

&lt;span class=&#34;n&#34;&gt;Process&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;North&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;){&lt;/span&gt;
  &lt;span class=&#34;k&#34;&gt;while&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;){&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;P&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;mutex1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;count1&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;==&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;){&lt;/span&gt;
      &lt;span class=&#34;n&#34;&gt;P&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;bridge&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 第一辆车来了就抢bridge让对面的车进不来
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;count1&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;V&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;mutex1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;

    &lt;span class=&#34;n&#34;&gt;cross&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;the&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;bridge&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;

    &lt;span class=&#34;n&#34;&gt;P&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;mutex1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;count1&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;--&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;count1&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;==&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;){&lt;/span&gt;
      &lt;span class=&#34;n&#34;&gt;V&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;bridge&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 最后一辆车走了就释放bridge让对面的车可以进来
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;V&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;mutex1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
  &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;n&#34;&gt;Process&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;South&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;){&lt;/span&gt;
  &lt;span class=&#34;k&#34;&gt;while&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;){&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;P&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;mutex2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;count2&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;==&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;){&lt;/span&gt;
      &lt;span class=&#34;n&#34;&gt;P&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;bridge&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;count2&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;V&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;mutex2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;

    &lt;span class=&#34;n&#34;&gt;cross&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;the&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;bridge&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;

    &lt;span class=&#34;n&#34;&gt;P&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;mutex2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;count2&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;--&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;count2&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;==&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;){&lt;/span&gt;
      &lt;span class=&#34;n&#34;&gt;V&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;bridge&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;V&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;mutex2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
  &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h3 id=&#34;管程&#34;&gt;管程&lt;/h3&gt;
&lt;p&gt;使用信号量机制实现的生产者消费者问题需要客户端代码做很多控制，而管程把控制的代码独立出来，不仅不容易出错，也使得客户端代码调用更容易。&lt;/p&gt;
&lt;p&gt;（管程有点像用一个类来封装初始化、共享数据、操作代码等）&lt;/p&gt;
&lt;p&gt;管程有一个重要特性：在一个时刻只能有一个进程使用管程。进程在无法继续执行的时候不能一直占用管程，否者其它进程永远不能使用管程。&lt;/p&gt;
&lt;p&gt;管程定义了一个数据结构和能为并发进程所执行的一组操作，这组操作可以同步进程和改变管程中的数据&lt;/p&gt;
&lt;p&gt;管程引入了  &lt;strong&gt;条件变量&lt;/strong&gt;  以及相关的操作：&lt;strong&gt;wait()&lt;/strong&gt; 和 &lt;strong&gt;signal()&lt;/strong&gt; 来实现同步操作。对条件变量执行 wait() 操作会导致调用进程阻塞，把管程让出来给另一个进程持有。signal() 操作用于唤醒被阻塞的进程。&lt;/p&gt;
&lt;h3 id=&#34;tips-2&#34;&gt;Tips&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;临界资源同一时间只能被一个进程访问，而共享资源一段时间可以被多个访问，磁盘属于共享设备而不是临界资源&lt;/li&gt;
&lt;li&gt;要对并发进程进行同步的原因是：并发进程是异步的&lt;/li&gt;
&lt;li&gt;PV操作由两个不可被中断的过程组成，也就是它们两个，它们都属于低级进程通信原语，不是系统调用&lt;/li&gt;
&lt;li&gt;有五个并发进程涉及到同一个变量A，说明有五段代码，也就是说有5个临界区&lt;/li&gt;
&lt;li&gt;信箱通信是一种间接通信方式&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;四死锁&#34;&gt;四、死锁&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1645944527/os-thread-9.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;多个程序因为竞争共享资源而造成的僵局，若无外力作用，这些进程都将永远无法继续推进&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;★产生死锁的四个条件&lt;/strong&gt;，都满足就会产生：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;互斥条件&lt;/strong&gt;：要求某资源进行排它性占有&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;不剥夺条件&lt;/strong&gt;：进程已经获得的资源在未被使用完前不可被剥夺&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;请求和保持条件&lt;/strong&gt;：已经至少拥有了一个资源，但是又提出了一个新的资源请求&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;循环/环路等待条件&lt;/strong&gt;（必要而非充分）：存在一个进程--资源循环链&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;举个例子，你手上拿着一个苹果，一个苹果只能被一个人拥有，这是互斥条件；别人不能把苹果从你手中抢走，这是不剥夺条件；你抱着这个苹果不放还想去拿别的苹果，这是请求和保持；一圈人都想拿他右边那个人的苹果，陷入循环，这是循环等待条件&lt;/p&gt;
&lt;h3 id=&#34;死锁处理&#34;&gt;死锁处理&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;不让死锁发生：预防死锁、避免死锁&lt;/li&gt;
&lt;li&gt;允许死锁发生，但死锁发生时要能检测到并加以处理：检测死锁、解除死锁&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1645944527/os-thread-8.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;预防死锁&#34;&gt;预防死锁&lt;/h3&gt;
&lt;p&gt;设置某些限制条件，破坏上面四个必要条件的一个或几个：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;（互斥在很多场合下是必须要遵循的，没办法破坏该条件）&lt;/li&gt;
&lt;li&gt;摈弃“请求和保持条件”：所有进程一次性获得所有资源&lt;/li&gt;
&lt;li&gt;摈弃“不可剥夺性”：如果提出新的申请无法满足，则放弃所有已经拥有的资源&lt;/li&gt;
&lt;li&gt;摈弃“环路等待”：资源按顺序编号，进程必须按顺序申请资源&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;避免死锁&#34;&gt;避免死锁&lt;/h3&gt;
&lt;p&gt;在资源的动态分配过程中，用某种方法防止系统进入不安全状态，从而避免死锁&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;银行家算法&lt;/strong&gt;（过程省略，找个例子就很容易理解）（卧槽，看完了才发现不考）
尝试分配，然后检测安全性&lt;/p&gt;
&lt;h3 id=&#34;死锁检测及解除&#34;&gt;死锁检测及解除&lt;/h3&gt;
&lt;p&gt;不采取任何限制措施，允许死锁，通过系统检测机构及时检测出死锁的产生，并采取某些措施解除死锁&lt;/p&gt;
&lt;p&gt;接触死锁的方法：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;剥夺资源&lt;/li&gt;
&lt;li&gt;撤销进程
&lt;br&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;tips-3&#34;&gt;Tips&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;进程产生死锁的主要原因。时间上可能是进程运行中的推进顺序不当，空间上的原因是对独占资源分配不当，而不是系统资源不足&lt;/li&gt;
&lt;li&gt;死锁的避免是根据防止系统进入不安全状态采取措施，实现的结果是让进程推进合理&lt;/li&gt;
&lt;li&gt;结束死锁甚至可以终止所有死锁进程，但是一般不会从非死锁进程处抢夺资源&lt;/li&gt;
&lt;li&gt;死锁状态一定是不安全状态，但是不安全状态不一定有死锁，还可能是其他的&lt;/li&gt;
&lt;li&gt;限制用户申请资源的顺序属于死锁预防的破坏循环等待，限制给进程分配资源的顺序属于死锁避免&lt;/li&gt;
&lt;/ul&gt;
</content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://yichengme.site/categories/%E6%8A%80%E6%9C%AF/" term="技术" label="技术" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://yichengme.site/tags/os/" term="OS" label="OS" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">操作系统基础（一）导论</title>
            <link rel="alternate" type="text/html" href="https://yichengme.site/posts/os-basics-introduction/" />
            <id>https://yichengme.site/posts/os-basics-introduction/</id>
            <updated>2022-03-02T19:00:11&#43;08:00</updated>
            <published>2020-01-04T16:29:53&#43;08:00</published>
            <author>
                    <name>王毅诚</name>
                    <uri>https://yichengme.site/</uri>
                    <email>engine74396@gmail.com</email>
                    </author>
            <rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">概述 操作系统是指控制和管理整个计算机系统的硬件和软件资源，并且合理地组织调度计算机工作和资源的分配，以提供给用户和其他软件方便接口和环境的程序集合。 从底层到上层……</summary>
            
                <content type="html">&lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;
&lt;p&gt;操作系统是指控制和管理整个计算机系统的硬件和软件资源，并且合理地组织调度计算机工作和资源的分配，以提供给用户和其他软件方便接口和环境的程序集合。&lt;/p&gt;
&lt;p&gt;从底层到上层分别是：&lt;/p&gt;
&lt;p&gt;硬件-&amp;gt;操作系统-&amp;gt;计算机程序-&amp;gt;用户&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1645632990/os-1.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;操作系统的特征&#34;&gt;操作系统的特征&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;并发&lt;/strong&gt;：两个或多个事件在同一时间间隔内发生&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;共享&lt;/strong&gt;：系统中的资源可供内存中多个并发执行的进程共同使用&lt;/p&gt;
&lt;p&gt;并发和共享是操作系统两个最基本的特征&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;虚拟&lt;/strong&gt;：把物理实体变为若干个逻辑的对应&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;异步&lt;/strong&gt;：进程的执行走走停停，以不可预知的速度向前推进&lt;/p&gt;
&lt;h2 id=&#34;操作系统的目的和功能&#34;&gt;操作系统的目的和功能&lt;/h2&gt;
&lt;p&gt;功能：处理机管理、存储器管理、设备管理、文件管理以及提供接口给用户。&lt;/p&gt;
&lt;p&gt;操作系统为用户提供操作计算机硬件系统的接口&lt;/p&gt;
&lt;h3 id=&#34;命令接口&#34;&gt;命令接口&lt;/h3&gt;
&lt;p&gt;联机控制方式（适用于分时、实时操作系统）：说一句做一句&lt;/p&gt;
&lt;p&gt;脱机控制方式（适用于批处理）：写在单子上，按单子一个一个做&lt;/p&gt;
&lt;h3 id=&#34;程序接口&#34;&gt;程序接口&lt;/h3&gt;
&lt;p&gt;程序接口由一组&lt;strong&gt;系统调用命令&lt;/strong&gt;组成，在程序中使用这些调用命令来请求操作系统为其提供服务&lt;/p&gt;
&lt;p&gt;系统调用只能用过用户程序间接使用&lt;/p&gt;
&lt;h2 id=&#34;操作系统的发展&#34;&gt;操作系统的发展&lt;/h2&gt;
&lt;h3 id=&#34;1-手工操作阶段&#34;&gt;1. 手工操作阶段&lt;/h3&gt;
&lt;h3 id=&#34;2-批处理阶段&#34;&gt;2. 批处理阶段&lt;/h3&gt;
&lt;p&gt;单道批处理系统：内存中始终保持一道作业
&lt;strong&gt;特征：自动性、顺序性、单道性&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;多道批处理系统：允许多个程序同时进入内存并运行
&lt;strong&gt;特征：多道、宏观并行、微观串行&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;批处理的缺点是缺少交互性&lt;/p&gt;
&lt;h3 id=&#34;3-分时操作系统&#34;&gt;3. 分时操作系统&lt;/h3&gt;
&lt;p&gt;采用分时技术，把处理器的运行时间分为很短的时间片，按照时间片轮转算法把处理器分配给各个联机作业使用。&lt;/p&gt;
&lt;p&gt;分时操作系统可以让多个用户通过终端连接同一个主机，用户之间互不干扰。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;特征：同时性、交互性、独立性、及时性&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;4-实时操作系统&#34;&gt;4. 实时操作系统&lt;/h3&gt;
&lt;p&gt;为了完成紧急任务而不需要时间片排队，通常采用抢占式的优先级高者优先调度&lt;/p&gt;
&lt;p&gt;实时系统必须在被控制对象规定时间内处理来自外部的事件&lt;/p&gt;
&lt;p&gt;通常运用场景是一些需要立即反应的场合，比如股票、订票、机床控制什么的&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;特征：及时性、可靠性&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;5-网络操作系统和分布式计算机系统&#34;&gt;5. 网络操作系统和分布式计算机系统&lt;/h3&gt;
&lt;p&gt;网络中各种资源的共享以及各台计算机之间的通信&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;特征：分布性、并行性&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;操作系统的运行环境&#34;&gt;操作系统的运行环境&lt;/h2&gt;
&lt;h3 id=&#34;内核态与用户态&#34;&gt;内核态与用户态&lt;/h3&gt;
&lt;p&gt;程序分为内核程序和外层应用程序，他们能执行的指令的权限不一样，所以操作系统划分为了用户态（目态）和核心态（管态）来严格区分这两种程序&lt;/p&gt;
&lt;p&gt;操作系统内核运行在核心态，用户程序运行在用户态&lt;/p&gt;
&lt;p&gt;内核包括：&lt;/p&gt;
&lt;h4 id=&#34;1-时钟管理&#34;&gt;1. 时钟管理&lt;/h4&gt;
&lt;h4 id=&#34;2-中断机制&#34;&gt;2. 中断机制&lt;/h4&gt;
&lt;h4 id=&#34;3-原语&#34;&gt;3. 原语&lt;/h4&gt;
&lt;p&gt;处于最底层、运行具有原子性、运行时间较短，有这些特点的程序被称为原语&lt;/p&gt;
&lt;h4 id=&#34;4-系统控制的数据结构及处理&#34;&gt;4. 系统控制的数据结构及处理&lt;/h4&gt;
&lt;h3 id=&#34;运行机制&#34;&gt;运行机制&lt;/h3&gt;
&lt;h3 id=&#34;中断和异常&#34;&gt;中断和异常&lt;/h3&gt;
&lt;h4 id=&#34;中断外中断与当前运行的程序无关比如设备的中断请求时钟中断等等&#34;&gt;中断：外中断，与当前运行的程序无关，比如设备的中断请求、时钟中断等等&lt;/h4&gt;
&lt;h4 id=&#34;异常内中断指令内部导致中断&#34;&gt;异常：内中断，指令内部导致中断&lt;/h4&gt;
&lt;p&gt;中断处理一定会保存程序状态子寄存器&lt;/p&gt;
&lt;p&gt;外部中断，PC值由中断隐指令自动保存，通用寄存器的内容由操作系统保存&lt;/p&gt;
&lt;h3 id=&#34;系统调用&#34;&gt;系统调用&lt;/h3&gt;
&lt;p&gt;按照供功能可以分为设备管理、文件管理、进程控制、进程通信、内存管理等&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1645632990/os-3.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;从用户态转到核心态会用到访管指令，访管指令在用户态使用，所以它不可能是特权指令&lt;/p&gt;
&lt;p&gt;用户态指令：&lt;/p&gt;
&lt;p&gt;核心态指令：输入输出指令&lt;/p&gt;
&lt;p&gt;从用户态转换到核心态，这是由硬件完成的&lt;/p&gt;
&lt;p&gt;置时钟指令只能在核心态下完成&lt;/p&gt;
&lt;p&gt;中断发生后，进入中断处理的程序在核心态执行，是操作系统程序&lt;/p&gt;
&lt;p&gt;广义指令（系统调用指令），必然在核心态执行，调用都可以&lt;/p&gt;
&lt;p&gt;输入输出必然在核心态执行&lt;/p&gt;
&lt;p&gt;分清楚调用和执行，有不少都是用户态可以调用但是执行必须在核心态的&lt;/p&gt;
&lt;p&gt;CPU处于核心态，除了访管指令，其余所有指令都可以调用&lt;/p&gt;
&lt;p&gt;导致用户从用户态切到内核态的操作有：某个东西导致了异常中断、I/O等等&lt;/p&gt;
&lt;h2 id=&#34;tips&#34;&gt;Tips&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;操作系统不关心高级语言编译器&lt;/li&gt;
&lt;li&gt;单处理机系统中，进程与进程不能并行&lt;/li&gt;
&lt;li&gt;用户可以使用命令接口和系统调用来使用计算机&lt;/li&gt;
&lt;li&gt;计算机开机后，操作系统最终被加载到RAM上（内存中的系统区）&lt;/li&gt;
&lt;li&gt;提高单机资源利用率的关键技术是多道程序设计技术&lt;/li&gt;
&lt;li&gt;提到多道批处理就往提交若干作业（清单）上靠，提到分时就往用户靠，提到实时就往响应速度靠&lt;/li&gt;
&lt;li&gt;通用操作系统使用时间片轮转算法&lt;/li&gt;
&lt;li&gt;通道技术是一种硬件技术&lt;/li&gt;
&lt;li&gt;进程调度不需要硬件的支持&lt;/li&gt;
&lt;li&gt;异常处理后不一定会返回到发生异常的地方继续执行，比如除以0会直接跳过&lt;/li&gt;
&lt;/ul&gt;
</content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://yichengme.site/categories/%E6%8A%80%E6%9C%AF/" term="技术" label="技术" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://yichengme.site/tags/os/" term="OS" label="OS" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">Django2&#43;nginx&#43;uwsgi&#43;Ubuntu部署记录</title>
            <link rel="alternate" type="text/html" href="https://yichengme.site/posts/django2&#43;nginx&#43;uwsgi&#43;ubuntu%E9%83%A8%E7%BD%B2%E8%AE%B0%E5%BD%95/" />
            <id>https://yichengme.site/posts/django2&#43;nginx&#43;uwsgi&#43;ubuntu%E9%83%A8%E7%BD%B2%E8%AE%B0%E5%BD%95/</id>
            <updated>2022-02-27T15:21:46&#43;08:00</updated>
            <published>2019-12-22T00:57:19&#43;08:00</published>
            <author>
                    <name>王毅诚</name>
                    <uri>https://yichengme.site/</uri>
                    <email>engine74396@gmail.com</email>
                    </author>
            <rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">Django项目写好了，最后一步就是部署(deployment)，部署十分关键，只有部署在服务器上，别人才能从互联网上通过ip地址或域名直接访问到你的网页。 第一……</summary>
            
                <content type="html">&lt;p&gt;Django项目写好了，最后一步就是部署(deployment)，部署十分关键，只有部署在服务器上，别人才能从互联网上通过ip地址或域名直接访问到你的网页。&lt;/p&gt;
&lt;p&gt;第一步是购买vps（Virtual Private Server 虚拟服务器），这个很简单而且网上教程一大把，这里就不详述，我在vultr购买的海外服务器，这样不用浪费时间去备案了，vultr的一大特色就是按时长收费，如果你的vps出了什么问题，可以随时关停，并且它还支持微信支付宝，价格也很便宜。
&lt;a href=&#34;https://www.vultr.com/?ref=7617179&#34;&gt; （vultr官网） &lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Django的本地预览十分方便，一行&lt;code&gt;python manage.py runserver&lt;/code&gt;就能搞定，但部署上线可没有这么简单。因为网上关于Django部署的教程都很杂乱，当时部署的时候就踩了很多很多坑，为了给之后一个参考，我又重新部署了一次，来记录详细的过程。&lt;/p&gt;
&lt;h2 id=&#34;相关软件版本&#34;&gt;相关软件版本：&lt;/h2&gt;
&lt;p&gt;Django 2.1.3
Python 3.6.6
nginx 1.14.0
uwsgi 2.0.17.1&lt;/p&gt;
&lt;p&gt;服务器：
Ubuntu-server 18.04&lt;/p&gt;
&lt;h2 id=&#34;准备工作&#34;&gt;准备工作&lt;/h2&gt;
&lt;p&gt;首先打开ssh软件，Xshell、Putty什么的都行，通过vultr上vps详情页上给的ip和root密码连接到这台vps。&lt;/p&gt;
&lt;p&gt;刚拿到的船新Linux，第一步先给它来个更新:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;sudo apt-get update
sudo apt-get upgrade
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;建议使用非root用户，部署时最好使用python虚拟环境，具体操作不是本文的重点，便不赘述了&lt;/p&gt;
&lt;p&gt;系统自带Python3.6、vim和git，所以不用装&lt;/p&gt;
&lt;p&gt;安装python3-pip、python3-setuptools、gcc、python3-dev、wheel：
（缺一不可，不然之后用pip安装uwsgi会有各种各样的报错）&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;sudo apt-get install python3-pip python-setuptools python3-dev wheel
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h2 id=&#34;放置django项目&#34;&gt;放置Django项目&lt;/h2&gt;
&lt;p&gt;直接在服务器端用vim什么的写Django当然可取（虽然会很酸爽），但更多的时候我们是在本地写好了Django项目，要把它挪到服务器上。&lt;/p&gt;
&lt;p&gt;在传输之前，要做一些工作：&lt;/p&gt;
&lt;p&gt;先更改一下&lt;code&gt;setting.py&lt;/code&gt;里的&lt;code&gt;ALLOWED_HOSTS&lt;/code&gt;，把服务器的ip加进去，有域名的话顺便把域名也加进去，要不然之后会无法加载Django项目&lt;/p&gt;
&lt;p&gt;在本地的Python虚拟环境上使用&lt;code&gt;pip freeze &amp;gt; requirements.txt&lt;/code&gt;,生成一个txt文件，里面是需要的Python库以及其版本，之后一并传给服务器&lt;/p&gt;
&lt;p&gt;传输文件到服务器的方法非常之多：可以使用Xshell自带的文件传输，也可以使用linux命令scp或安装更直观的lrzsz，或者使用本地的FileZilla、Winscp等软件，当然万能的git也很不错。&lt;/p&gt;
&lt;p&gt;不过考虑到之后这个web项目之后也要修改，用上面的方法感觉都不是特别方便，介绍一个非常好用的方法，那就是使用Pycharm自带的deployment功能，可以实现实时上传以及下载文件，很是方便。&lt;/p&gt;
&lt;p&gt;在&lt;code&gt;Tools&lt;/code&gt;-&amp;gt;&lt;code&gt;Deployment&lt;/code&gt;-&amp;gt;&lt;code&gt;Configuration&lt;/code&gt;中配置好与自己服务器的连接，IP地址、用户名、密码以及对应项目路径&lt;/p&gt;
&lt;center&gt;
&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1543389659/pycharm-deployment-1.jpg&#34; width=60%&gt;
&lt;/center&gt;
&lt;center&gt;
&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1543389659/pycharm-deployment-2.jpg&#34; width=60%&gt;
&lt;/center&gt;
&lt;p&gt;在&lt;code&gt;Settings&lt;/code&gt;-&amp;gt;&lt;code&gt;Project Interpreter&lt;/code&gt;里把项目解释器更改为服务器里的Python，mappings里填写两边项目的目录，再加一条&lt;code&gt;manage.py&lt;/code&gt;的映射&lt;/p&gt;
&lt;center&gt;
&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1543389660/pycharm-deployment-3.jpg&#34; width=60%&gt;
&lt;/center&gt;
&lt;p&gt;apply之后Pycharm右下角会出现上传进度条，会有点慢，喝杯茶等一段时间即可&lt;/p&gt;
&lt;p&gt;传输完毕后会发现本地的项目已经全部上传到服务器了&lt;/p&gt;
&lt;p&gt;但这个毕竟不是这篇文章的重点，不重点介绍，遇到了什么问题可以留言或者私信我。&lt;/p&gt;
&lt;p&gt;最后别忘了把&lt;code&gt;requirements.txt&lt;/code&gt;上传到服务器，用pycharm的话只要直接把文件拖进本地项目目录，Pycharm就会自动帮我们上传到服务器。&lt;/p&gt;
&lt;p&gt;在服务器上使用&lt;code&gt;pip install -r requirements.txt&lt;/code&gt;来安装必要的Python packages
&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&#34;安装与配置uwsgi&#34;&gt;安装与配置uwsgi&lt;/h2&gt;
&lt;p&gt;使用pip3安装uwsgi（注意是pip安装，不是apt-get，否则之后会各种报错）&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;pip3 install uwsgi
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;下面来试一下uwsgi是否好使：
找个位置新建一个py文件，就叫&lt;code&gt;uwsgi_test.py&lt;/code&gt;好了，然后用vim打开&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;touch uwsgi_test.py
vim uwsgi_test.py
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;写入以下内容：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-Python&#34; data-lang=&#34;Python&#34;&gt;&lt;span class=&#34;k&#34;&gt;def&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;application&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;env&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;start_response&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;start_response&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;200 OK&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[(&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;Content-Type&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;text/html&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)])&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;sa&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;Hello Uwsgi&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;wq保存退出（vim的基本操作不赘述，网上教程一大把）&lt;/p&gt;
&lt;p&gt;然后输入以下命令启动uwsgi，把这个部署到某个端口，以9090端口为例&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;uwsgi --http :9090 --wsgi-file uwsgi_test.py
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这时会出现&lt;code&gt;spawned uWSGI worker 1 (and the only) (pid: 11812, cores: 1) &lt;/code&gt;
找个浏览器，访问&lt;code&gt;http://&amp;lt;你的服务器ip&amp;gt;:9090/&lt;/code&gt;，不出意外的话你会看到Hello Uwsgi的字样，说明uwsgi能正常运行。&lt;/p&gt;
&lt;p&gt;在项目目录下新建&lt;code&gt;uwsgi.ini&lt;/code&gt;文件并编辑加入以下内容：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;uwsgi&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;# 直接访问uwsgi的端口号，绕过nginx&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;http&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;8010&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;# 转发给nginx的端口号&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;socket&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mf&#34;&gt;127.0.0.1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;8001&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;# 是否使用主线程&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;master&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;true&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;# 项目的绝对路径&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;chdir&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;var&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;www&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;PROJECT_NAME&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;/&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;# Django项目wsgi.py文件的相对路径&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;wsgi&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;file&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;PROJECT_NAME&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;wsgi&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;py&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;# 进程数&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;processes&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;4&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;# 每个进程的线程数&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;threads&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;# 监听端口&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;stats&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mf&#34;&gt;127.0.0.1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;9191&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;# 每次退出时是否清理环境配置&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;vacuum&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;true&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;# 目录中一旦有文件被改动就自动重启&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;touch&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;reload&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;var&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;www&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;my_site&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;# 存放日志&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;daemonize&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;var&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;www&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;my_site&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;uWSGI&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;log&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;[uwsgi]
# 直接访问uwsgi的端口号，绕过nginx
http = :8010
# 转发给nginx的端口号
socket = 127.0.0.1:8001
# 是否使用主线程
master = true
# 项目的绝对路径
chdir = /var/www/bangumi_project/
# Django项目wsgi.py文件的相对路径
wsgi-file = bangumi_project/wsgi.py
# 进程数
processes = 4
# 每个进程的线程数
threads = 2
# 监听端口
stats = 127.0.0.1:9191
# 每次退出时是否清理环境配置
vacuum = true
# 目录中一旦有文件被改动就自动重启
touch-reload = /var/www/bangumi_project
# 存放日志
daemonize = /var/www/bangumi_project/uWSGI.log
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;加入uwsgi.ini的目的是使让uwsgi对接Django项目的启动变得更简便，否则就得在终端敲很长的代码&lt;/p&gt;
&lt;p&gt;有了&lt;code&gt;uwsgi.ini&lt;/code&gt;我们只需要输入&lt;code&gt;uwsgi --ini uwsgi.ini&lt;/code&gt;就可以运行，浏览器输入ip地址加:8010端口（先绕过nginx因为还没配置呢），发现可以显示我们的项目了，这时css等静态文件可能没获取到，别急&lt;/p&gt;
&lt;h2 id=&#34;安装和配置nginx&#34;&gt;安装和配置nginx&lt;/h2&gt;
&lt;p&gt;先&lt;code&gt;sudo apt-get install nginx&lt;/code&gt;安装nginx，安装后nginx会自动启动，默认端口为80端口，浏览器输入ip地址加:80，可以看到&amp;quot;Welcome to nginx&amp;quot;的欢迎界面&lt;/p&gt;
&lt;p&gt;把/etc/nginx/目录下的&lt;code&gt;uwsgi_params&lt;/code&gt;复制到项目目录下，也可以直接项目目录下新建&lt;code&gt;uwsgi_params&lt;/code&gt;文件，写入以下内容：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;uwsgi_param  QUERY_STRING       &lt;span class=&#34;nv&#34;&gt;$query_string&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
uwsgi_param  REQUEST_METHOD     &lt;span class=&#34;nv&#34;&gt;$request_method&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
uwsgi_param  CONTENT_TYPE       &lt;span class=&#34;nv&#34;&gt;$content_type&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
uwsgi_param  CONTENT_LENGTH     &lt;span class=&#34;nv&#34;&gt;$content_length&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;

uwsgi_param  REQUEST_URI        &lt;span class=&#34;nv&#34;&gt;$request_uri&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
uwsgi_param  PATH_INFO          &lt;span class=&#34;nv&#34;&gt;$document_uri&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
uwsgi_param  DOCUMENT_ROOT      &lt;span class=&#34;nv&#34;&gt;$document_root&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
uwsgi_param  SERVER_PROTOCOL    &lt;span class=&#34;nv&#34;&gt;$server_protocol&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
uwsgi_param  REQUEST_SCHEME     &lt;span class=&#34;nv&#34;&gt;$scheme&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
uwsgi_param  HTTPS              &lt;span class=&#34;nv&#34;&gt;$https&lt;/span&gt; if_not_empty&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;

uwsgi_param  REMOTE_ADDR        &lt;span class=&#34;nv&#34;&gt;$remote_addr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
uwsgi_param  REMOTE_PORT        &lt;span class=&#34;nv&#34;&gt;$remote_port&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
uwsgi_param  SERVER_PORT        &lt;span class=&#34;nv&#34;&gt;$server_port&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
uwsgi_param  SERVER_NAME        &lt;span class=&#34;nv&#34;&gt;$server_name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;前往/etc/nginx/目录，查看&lt;code&gt;nginx.conf&lt;/code&gt;（nginx基础配置），发现里面有这么两行，意思就是包含conf.d文件夹中所有以conf后缀的配置和site-enabled文件夹中的内容&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;include /etc/nginx/conf.d/*.conf;
include /etc/nginx/sites-enabled/*;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;我们不更改nginx.conf基础配置，只需要修改&lt;code&gt;conf.d&lt;/code&gt;目录下的conf文件即可，进入&lt;code&gt;conf.d&lt;/code&gt;文件夹，修改&lt;code&gt;default.conf&lt;/code&gt;文件，没有的话就新建一个（还可以修改site-enabled/default或者sites-available/default，效果都一样的）&lt;/p&gt;
&lt;p&gt;然后写入以下内容：（务必根据自己的情况做相应更改）&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-nginx&#34; data-lang=&#34;nginx&#34;&gt;&lt;span class=&#34;k&#34;&gt;upstream&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;django&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
   &lt;span class=&#34;kn&#34;&gt;server&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;127.0.0.1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;8001&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;k&#34;&gt;server&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;# 监听端口，可改
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;kn&#34;&gt;listen&lt;/span&gt;       &lt;span class=&#34;mi&#34;&gt;80&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;# 修改为你的ip或者域名
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;kn&#34;&gt;server_name&lt;/span&gt;  &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;.2.3.4&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;# 编码方式
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;kn&#34;&gt;charset&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;utf-8&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;

    &lt;span class=&#34;c1&#34;&gt;# 日志记录，可选
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;kn&#34;&gt;access_log&lt;/span&gt;      &lt;span class=&#34;s&#34;&gt;/var/www/&amp;lt;PROJECT_NAME&amp;gt;/nginx_access.log&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;kn&#34;&gt;error_log&lt;/span&gt;       &lt;span class=&#34;s&#34;&gt;/var/www/&amp;lt;PROJECT_NAME&amp;gt;/nginx_error.log&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;

    &lt;span class=&#34;c1&#34;&gt;# 静态文件所在目录（自行修改）
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;kn&#34;&gt;location&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;/static&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;kn&#34;&gt;alias&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;/var/www/my_site/blog/static&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;# 媒体文件所在目录（自行修改）
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;#location /media  {
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;#    alias /home/www/djangotest/Hello/media; # 媒体文件所在文件夹
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;#}
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;kn&#34;&gt;location&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;/&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;kn&#34;&gt;include&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;/var/www/&amp;lt;PROJECT_NAME&amp;gt;/uwsgi_params&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
        &lt;span class=&#34;kn&#34;&gt;uwsgi_pass&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;django&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;运行&lt;code&gt;service nginx restart&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;如果报错&lt;code&gt;nginx.service failed because the control process exited with error code&lt;/code&gt;，那么运行一下&lt;code&gt;nginx -t -c /etc/nginx/nginx.conf&lt;/code&gt;，可以很容易的找到问题在哪。&lt;/p&gt;
&lt;p&gt;浏览器输入ip地址，如果发现看到的还是&amp;quot;Welcome to nginx&amp;quot;，这个是因为在&lt;code&gt;nginx.conf&lt;/code&gt;中还include了一个&lt;code&gt;sites-enabled/*&lt;/code&gt;，它覆盖了我们在&lt;code&gt;default.conf&lt;/code&gt;中的配置，可以干脆直接去&lt;code&gt;nginx.conf&lt;/code&gt;里把&lt;code&gt;include /etc/nginx/sites-enabled/*;&lt;/code&gt;这一行删掉，或者调换两行位置。
如果当时直接修改的sites-available或者sites-enabled中的default，就不会有这个问题&lt;/p&gt;
&lt;p&gt;这时再访问我们的ip，就能看到自己在本地搭建的Django项目了，因为在配置nginx的时候写入了static的路径，所以css什么的都加载进来了。&lt;/p&gt;
&lt;p&gt;至此nginx配置完毕&lt;/p&gt;
&lt;h2 id=&#34;后续工作&#34;&gt;后续工作&lt;/h2&gt;
&lt;p&gt;服务器上的Django还没有执行数据库迁移与管理员创建，所以记得执行&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;python manage.py makemigrations
python manage.py migrate
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;以及&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;python manage.py createsuperuser
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;每次有更新时都要重载uwsgi与nginx才能生效，为了方便uwsgi的重载，在项目目录下新建一个&lt;code&gt;uwsgi&lt;/code&gt;文件夹，然后在里面新建两个文件:&lt;code&gt;uwsgi.pid&lt;/code&gt;（用于重载停止等操作）和&lt;code&gt;uwsgi.status&lt;/code&gt;（用于查看状态）&lt;/p&gt;
&lt;p&gt;修改&lt;code&gt;uwsgi.ini&lt;/code&gt;，把原先的stats那行删掉，下面加上这两行：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;stats=%(chdir)/uwsgi/uwsgi.status
pidfile=%(chdir)/uwsgi/uwsgi.pid
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这样如果项目有更新，就可以使用这两个命令来分别重载uwsgi和nginx了&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;uwsgi --reload uwsgi/uwsgi.pid
systemctl reload nginx.service
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;至此我们的Django项目就部署完成了&lt;/p&gt;
</content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://yichengme.site/categories/%E6%8A%80%E6%9C%AF/" term="技术" label="技术" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://yichengme.site/tags/django/" term="Django" label="Django" />
                            
                        
                            
                            
                            
                                <category scheme="https://yichengme.site/tags/linux/" term="Linux" label="Linux" />
                            
                        
                            
                            
                            
                                <category scheme="https://yichengme.site/tags/nginx/" term="nginx" label="nginx" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">mac软件推荐</title>
            <link rel="alternate" type="text/html" href="https://yichengme.site/posts/mac-software-recommend/" />
            <id>https://yichengme.site/posts/mac-software-recommend/</id>
            <updated>2022-02-12T21:14:52&#43;08:00</updated>
            <published>2019-11-10T15:38:07&#43;08:00</published>
            <author>
                    <name>王毅诚</name>
                    <uri>https://yichengme.site/</uri>
                    <email>engine74396@gmail.com</email>
                    </author>
            <rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">注：以下软件或组件只是自我记录，因为是颜控，所以包含大量主观感情色彩 本篇不含软件资源，如果有需要建议去官网购买正版 多图预警！！！流量党请慎重 科研篇 Xmind 最好用的思维……</summary>
            
                <content type="html">&lt;p&gt;注：以下软件或组件只是自我记录，因为是颜控，所以包含大量主观感情色彩&lt;/p&gt;
&lt;p&gt;本篇不含软件资源，如果有需要建议去官网购买正版&lt;/p&gt;
&lt;p&gt;多图预警！！！流量党请慎重&lt;/p&gt;
&lt;h2 id=&#34;科研篇&#34;&gt;科研篇&lt;/h2&gt;
&lt;h3 id=&#34;xmind&#34;&gt;Xmind&lt;/h3&gt;
&lt;p&gt;最好用的思维导图软件，做出来的图很漂亮。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1641893834/xmind-1.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;如果想放在ppt里，不要直接导出png图片，而应该导出为svg，然后拖进ppt。如果采用放大加平滑会有更好的演示效果。&lt;/p&gt;
&lt;h3 id=&#34;ivysci&#34;&gt;IvySci&lt;/h3&gt;
&lt;p&gt;青藤学术，论文管理软件，功能丰富，支持多端登录，比如论文管理、框选翻译、自动显示引用、笔记记录等等，比老牌的那几个论文管理软件好用。ReadPaper也不错，就是刚起步bug还比较多。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1641872960/IvySci-1.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;mathpix-snip&#34;&gt;Mathpix Snip&lt;/h3&gt;
&lt;p&gt;区域截图，通过Ai识别返回Latex语法，每个月有免费的次数，不过还是够用的，神器&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1641872960/mathpix-1.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;更新：别拿它图片做图床，过段时间后会被清理，当时图省事直接用它的图床，没保存到本地，笔记里的好几十张图片都没了 o(╥﹏╥)o&lt;/p&gt;
&lt;p&gt;图床，我推荐cloudinary&lt;/p&gt;
&lt;h3 id=&#34;texpad&#34;&gt;Texpad&lt;/h3&gt;
&lt;p&gt;mac平台上最好用颜值最高的Latex编辑器，可以自动同步编译，当然云端的Overleaf也不错（如果网好的话）&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1641872968/texpad-1.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;生活篇&#34;&gt;生活篇&lt;/h2&gt;
&lt;h3 id=&#34;cleanmymac-x&#34;&gt;CleanMyMac X&lt;/h3&gt;
&lt;p&gt;界面极其优雅，功能强大的Mac清理软件&lt;/p&gt;
&lt;p&gt;这个软件的易用性、外观和音效颠覆了我对清理类软件的看法，用起来很舒服，比win平台的某些流氓管家不知道高到哪里去了&lt;/p&gt;
&lt;center&gt;
&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1551701107/yicheng.me%20Blog/Screen_Shot_2019-02-22_at_3.29.35_PM.png&#34; width=80%&gt;
&lt;/center&gt;
&lt;h3 id=&#34;fantastical-2&#34;&gt;Fantastical 2&lt;/h3&gt;
&lt;p&gt;想找个同步Google Calendar事件的Mac端日历，最后找到了找个。界面优雅且功能强大的日历应用，曾获年度设计奖，比默认日历多了很多功能，能绑定Google Calendar和Apple日历事件，在菜单栏显示，非常方便。&lt;/p&gt;
&lt;center&gt;
&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1551701106/yicheng.me%20Blog/Screen_Shot_2019-02-22_at_3.25.36_PM.png&#34; width=80%&gt;
&lt;/center&gt;
&lt;h3 id=&#34;network--battery&#34;&gt;Network &amp;amp; Battery&lt;/h3&gt;
&lt;p&gt;最好看的网速菜单栏显示软件，试了就知道&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1641872968/network-and-battery-1.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;网易云音乐spotify在线音乐流媒体&#34;&gt;网易云音乐、Spotify（在线音乐流媒体）&lt;/h3&gt;
&lt;p&gt;可能对我这种找歌靠日推而不是靠歌手的人而言，不粉任何当红歌星，就听听acg、纯音乐什么的，版权基本对我没有影响。相比国内其他音乐软件而言，网易云的界面是最耐看的，日推算法很准确，评论氛围也不错。&lt;/p&gt;
&lt;p&gt;后来接触到了spotify之后就和Spotify结合着用，Spotify的推荐算法很强，多平台播放同步和支持Google home也很酸爽。&lt;/p&gt;
&lt;p&gt;更新：这两年网易云的版权越来越少了，杂七杂八的东西也多了起来，Spotify版权更差，而且大多数没有歌词，后面基本都是本地听无损了。当然网易云可以通过代理的方法从其他地方获取灰掉的歌，只是不太方便。&lt;/p&gt;
&lt;h3 id=&#34;audirvana-plus本地无损音乐播放器&#34;&gt;Audirvana Plus（本地无损音乐播放器）&lt;/h3&gt;
&lt;p&gt;本地无损音乐播放器，墙裂推荐，听起来确实和其他音乐软件的音效不一样，就不只是听个响了，配合wav、ape等无损格式食用更佳（如1G多的加州旅馆）&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1641872958/Audirvana-1.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;hidden-bar&#34;&gt;Hidden Bar&lt;/h3&gt;
&lt;p&gt;开源的菜单栏隐藏工具，可以帮助右上方的菜单栏变得干净。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1641872959/hidden-bar-1.gif&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;fe-file-explorer&#34;&gt;FE File Explorer&lt;/h3&gt;
&lt;p&gt;文件管理、nas连接都很方便&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1641872968/fe-file-explorer-1.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;iina&#34;&gt;IINA&lt;/h3&gt;
&lt;p&gt;mac下很好用的一款开源的颜值很高的视频播放器&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1641872960/IINA-1.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;uniconverter&#34;&gt;UniConverter&lt;/h3&gt;
&lt;p&gt;万兴的文件格式转换软件（万兴真的是国产软件的清流），支持超多格式，界面干净，非常好用。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1641894992/uniconverter-1.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;pdf-expertpdfelement&#34;&gt;PDF Expert、Pdfelement&lt;/h3&gt;
&lt;p&gt;前者是轻量的pdf阅读软件，响应速度非常快。后者是万兴的pdf软件，功能很强大，经常拿它转换一些pdf，让它们的文字可以被搜索到。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1641894993/pdf-expert-1.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;shadowsocksx-ngclashx&#34;&gt;ShadowsocksX-NG、ClashX&lt;/h3&gt;
&lt;p&gt;某科学的上网方法，节点不建议自己撘，还是找个靠谱的服务商比较好，一个月几十块钱，国内程序员、搞学术的必需品。就不细说了。&lt;/p&gt;
&lt;h3 id=&#34;dropbox&#34;&gt;Dropbox&lt;/h3&gt;
&lt;p&gt;赫赫有名的同步云盘，和国内云盘的理念不同，dropbox只是纯粹的做同步和备份工作，不限速，多平台同步、国外支持云盘导入导出的软件基本都支持dropbox，唯一的缺点就是初始空间只有2G，之后可以做任务攒到18G左右（可以去淘宝买），订阅的话很贵，但是体验是真的舒服。我是配合NAS一起食用NAS放大文件（如视频），dropbox储存一些重要的小文件（如笔记、代码）。&lt;/p&gt;
&lt;p&gt;Dropbox的历史文档自动存储救了我好几次，好用到哭泣。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1641894992/dropbox-1.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;telegram&#34;&gt;Telegram&lt;/h3&gt;
&lt;p&gt;优雅的聊天应用，Mac/Win/Android/ios全平台推荐，聊天信息完全加密，（因为不透露用户隐私，tg在老家毛子那都被墙了），另外全平台传文件非常好用，吊打QQ，因为大家都懂的原因，国内用的人确实不是很多，和QQ互补着用挺好，微信就算了吧，文件太拉胯了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1641894992/telegram-1.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;paste&#34;&gt;Paste&lt;/h3&gt;
&lt;p&gt;很方便的复制粘贴工具，可以记录历史复制的内容，提高效率&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1644157207/paste-1.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;downie4allavsoft&#34;&gt;Downie4、Allavsoft&lt;/h3&gt;
&lt;p&gt;都是很好用的视频下载器，可以下载很多网站的视频，比如Bilibili、Youtube等等&lt;/p&gt;
&lt;h3 id=&#34;parallels-desktop&#34;&gt;Parallels Desktop&lt;/h3&gt;
&lt;p&gt;macOS下的最强虚拟机软件，不过说实话，真不建议用mac开虚拟机，太浪费了，有win需求的话建议再买一台win。&lt;/p&gt;
&lt;h2 id=&#34;程序猿篇&#34;&gt;程序猿篇&lt;/h2&gt;
&lt;h3 id=&#34;jetbrains全家桶&#34;&gt;Jetbrains全家桶&lt;/h3&gt;
&lt;p&gt;Pycharm、Idea、WEbstorm、Goland、Clion、Android Studio&lt;/p&gt;
&lt;p&gt;（Jetbrains家的ide，用过的都说好）&lt;/p&gt;
&lt;p&gt;xcode只有做ios、mac app开发的时候的挺好，毕竟垄断了，Visual Studio for mac用起来有点怪，还是乖乖的在win下用宇宙第一IDE吧。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1641894992/jetbrains-1.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;atomvs-code&#34;&gt;Atom/VS Code&lt;/h3&gt;
&lt;p&gt;最开始选的Atom，中途无数次尝试VS Code（毕竟推荐的人很多），但是最后还是选择了Atom，性能确实不如vs code，但也没有感到明显的延迟（插件十来个也是秒开）。&lt;/p&gt;
&lt;p&gt;用的是material ui的darker配色，比较耐看。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1549894263/E8F0C761-0FF4-4739-BFFB-62126E855D78_.png.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;Atom：99分的界面+70分的性能&lt;/p&gt;
&lt;p&gt;VS code：90分的界面+99分的性能&lt;/p&gt;
&lt;p&gt;颜控当然是选择Atom了&lt;/p&gt;
&lt;h3 id=&#34;transmit&#34;&gt;Transmit&lt;/h3&gt;
&lt;p&gt;图形化的ftp软件，在mac与远程服务器之间传输数据，很好用&lt;/p&gt;
&lt;h3 id=&#34;startuml&#34;&gt;StartUML&lt;/h3&gt;
&lt;p&gt;UML分析设计应用，画UML图还不错，虽然有些方面很糟心（比如复制什么的），但是好像找不出更能打的软件了。&lt;/p&gt;
&lt;h3 id=&#34;navicat&#34;&gt;Navicat&lt;/h3&gt;
&lt;p&gt;数据库管理软件，比命令行直观多了&lt;/p&gt;
&lt;h3 id=&#34;postman&#34;&gt;Postman&lt;/h3&gt;
&lt;p&gt;大名鼎鼎的api调试神器，CRUD程序猿必备&lt;/p&gt;
&lt;h3 id=&#34;iterm2&#34;&gt;iTerm2&lt;/h3&gt;
&lt;p&gt;代替自带终端bash的神器，自定义很丰富。&lt;/p&gt;
&lt;h2 id=&#34;命令行组件&#34;&gt;命令行组件&lt;/h2&gt;
&lt;h3 id=&#34;homebrew必装&#34;&gt;HomeBrew（必装）&lt;/h3&gt;
&lt;p&gt;Mac中类似linux的包管理工具，神器&lt;/p&gt;
&lt;p&gt;安装Xcode命令行工具：&lt;code&gt;xcode-select --install&lt;/code&gt;
安装HomeBrew：&lt;code&gt;/usr/bin/ruby -e &amp;quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&amp;quot;&lt;/code&gt;
等待即可，如果连不上可能是wall的原因&lt;/p&gt;
&lt;h3 id=&#34;pythongitnode&#34;&gt;python、git、node...&lt;/h3&gt;
&lt;p&gt;这类必装组件太多了，就不单独提了&lt;/p&gt;
&lt;h3 id=&#34;oh-my-zsh&#34;&gt;oh-my-zsh&lt;/h3&gt;
&lt;p&gt;下载zsh
&lt;code&gt;brew install zsh&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;设置为默认shell
&lt;code&gt;sudo sh -c &amp;quot;echo /usr/local/bin/zsh &amp;gt;&amp;gt; /etc/shells&amp;quot;&lt;/code&gt;
&lt;code&gt;chsh -s /usr/local/bin/zsh&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;zsh进一步配置及美化可以上网搜寻一些文章，我用了一圈主题最后还是回到了zsh的原版主题&lt;/p&gt;
&lt;p&gt;功能很强大，这里不细谈了&lt;/p&gt;
&lt;h3 id=&#34;neofetch&#34;&gt;neofetch&lt;/h3&gt;
&lt;p&gt;显示ASCII形式的logo以及系统和硬件信息，很炫酷，华而不实hh&lt;/p&gt;
&lt;p&gt;安装只需要&lt;code&gt;brew install neofetch&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;使用只需要输入&lt;code&gt;neofetch&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1551701105/yicheng.me%20Blog/Screen_Shot_2019-02-21_at_6.23.13_PM.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;设计狮篇&#34;&gt;设计狮篇&lt;/h2&gt;
&lt;h3 id=&#34;adobe全家桶&#34;&gt;Adobe全家桶&lt;/h3&gt;
&lt;p&gt;PS、Pr、Ae、Au、Ai...不解释了，接触设计、多媒体的应该都会用到Adobe家的软件，Adobe在Mac平台下有加成。（而office在Mac下就是被削了）&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1641819661/adobe-1.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;sip&#34;&gt;Sip&lt;/h3&gt;
&lt;p&gt;屏幕取色器，可以取到屏幕任意位置的颜色数值，rgb、html格式都有，做ppt、PS和前端都很方便&lt;/p&gt;
&lt;h3 id=&#34;sketch&#34;&gt;Sketch&lt;/h3&gt;
&lt;p&gt;mac上最好用的矢量绘图软件，适合画概念图&lt;/p&gt;
&lt;p&gt;未完待续...&lt;/p&gt;
</content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://yichengme.site/categories/%E7%94%9F%E6%B4%BB/" term="生活" label="生活" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://yichengme.site/tags/macos/" term="macOS" label="macOS" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">Precision5510 黑苹果使用体验</title>
            <link rel="alternate" type="text/html" href="https://yichengme.site/posts/precision5510-hackintosh/" />
            <id>https://yichengme.site/posts/precision5510-hackintosh/</id>
            <updated>2022-02-12T21:01:13&#43;08:00</updated>
            <published>2019-09-05T14:33:07&#43;08:00</published>
            <author>
                    <name>王毅诚</name>
                    <uri>https://yichengme.site/</uri>
                    <email>engine74396@gmail.com</email>
                    </author>
            <rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">前年的时候，也就是17年年底，鉴于最低配的苏菲4性能比较羸弱，可怜的4G内存开个Chrome和Office就能吃满，分分钟卡爆，于是原来的电脑出掉了，准备更换一……</summary>
            
                <content type="html">&lt;p&gt;前年的时候，也就是17年年底，鉴于最低配的苏菲4性能比较羸弱，可怜的4G内存开个Chrome和Office就能吃满，分分钟卡爆，于是原来的电脑出掉了，准备更换一台高性能的电脑。&lt;/p&gt;
&lt;p&gt;当时还在原专业读土木，某些软件只有Windows才有，上mbp显然是没想过的，另外宿舍用台式机也比较麻烦，所以只能选Windows笔记本。&lt;/p&gt;
&lt;p&gt;预算其实并不是非常充足，但是内心有一种强烈的想法：买个配置够用的电脑多用几年。说实话五千块的电脑用三四年，真心不如一万的电脑用七八年。&lt;/p&gt;
&lt;p&gt;卡顿是对时间的浪费，崩溃是对心血的亵渎。&lt;/p&gt;
&lt;p&gt;一台电脑，配置固然是核心，但对我这种强迫症而言，工业设计也是一个重要因素。于是最后决定在XPS 15或者precision 5510中选择，它们的模具是一样的，主要区别在于其显卡和定位，前者是搭载游戏显卡，定位是超极本；后者搭载图形显卡，定位是移动图形工作站。&lt;/p&gt;
&lt;p&gt;因为不玩大型游戏，所以最后选择了海淘一款官翻的precision 5510移动图形工作站，虽然买的价格不到国行新机的一半，但还是非常高。最后咬咬牙还是买了，事实证明这台precision 5510确实值这个价。&lt;/p&gt;
&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1550418842/precision5510.jpg&#34; width=100%&gt;
&lt;p&gt;主要部件如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;intel i7 6820HQ 处理器&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;16GB 镁光 DDR4  内存条&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;SK hynix 512GB 固态硬盘&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;夏普 SHP1476 屏幕&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Nvidia Quadro M1000M 图形显卡&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Windows10 pro 系统&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;使用这台工作站，跑了一年多Windows，总的体验当然是很用得很舒服，基本没出现过卡顿的情况，除了Ae渲染时风扇会狂转，其他时候完全无压力啊。win10本身尤其是UWP应用对4k触摸屏还是比较友好的（除了Windows的遗留win7风格界面），但是一些比较老旧或者小众的软件根本没有适配4k，导致那些软件要么字体非常小，看瞎了，要么强行靠缩放来保持尺寸，导致图标和字体发虚严重。4k在windows下的体验只能打80分。&lt;/p&gt;
&lt;p&gt;最开始没想到要装黑苹果，只是偶然在B站看到了科技美学的XPS 15顶配黑苹果评测，瞬间被折服了:
&lt;a href=&#34;https://www.bilibili.com/video/av6079016&#34;&gt;「科技美学」戴尔XPS15顶配版体验测评 黑苹果系统安装&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;当海舟用手开始在屏幕上拖视频块来做FCP剪辑时，弹幕已经沸腾了，就算是顶配定制版MacBook Pro也没有触摸屏，不管原因是为了与ipad的交互区分开，以免造成产品线混淆（正常人理解）还是考虑到抬手触屏不方便 触控板万岁！（果粉理解）亦或只是为了节约屏幕成本 赚更多的钱（果黑理解），事实还是：mbp就是没有配置触摸屏。&lt;/p&gt;
&lt;p&gt;然而有趣的是，Mac OS系统和软件不仅支持高分辨率屏幕触摸操作，甚至比win10还支持的更好。&lt;/p&gt;
&lt;p&gt;前几天通过针大的教程&lt;a href=&#34;https://hyejeong.cn/hackintosh5510mojave&#34;&gt;Dell Precision 5510 Mojave Clover分享&lt;/a&gt;，花了两三天就比较顺利的装上了黑苹果，版本为Mojave 10.14.3，针大不仅写了很详细的教程和分享clover等文件，还通过私信解决了我的很多疑问，非常感激。如果有同样的precision5510想安装黑苹果的，可以去参考针大的这篇文章。&lt;/p&gt;
&lt;p&gt;因为一些软件只能在win上运行，因此装的是双系统，512GB的SSD给Mac OS分了320GB，给win10留了剩下的一百来G。&lt;/p&gt;
&lt;p&gt;下面对precision m5510 4k版黑苹果的各个方面做一个简单的小结，与mbp相比的优势与不足，以及黑苹果的完整程度：&lt;/p&gt;
&lt;h2 id=&#34;屏幕&#34;&gt;屏幕&lt;/h2&gt;
&lt;p&gt;MacBook Pro 15.4英寸的屏幕是 2880 x 1800 P3广色域 Retina视网膜屏
Precision5510 / XPS15 4k版的是 3840 x 2160 100%AdobeRGB UHD 康宁大猩猩玻璃触屏&lt;/p&gt;
&lt;p&gt;单论屏幕素质，Retina的校色更准确，观感更舒适，而Dell的镜面屏分辨率更高，观感更鲜艳。这两款屏幕的素质在笔记本中绝对都在第一梯队，是设计人员的福音，两款屏幕属于神仙打架。&lt;/p&gt;
&lt;p&gt;但有着触摸屏和Mac OS的加持，Precision 4k版本实现了mbp没有加入的触屏功能，感觉像是体验到了未来的mbp。&lt;/p&gt;
&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1550418841/photo_2019-02-17_23.40.37.jpg&#34; width=100%&gt;
&lt;h2 id=&#34;触控板&#34;&gt;触控板&lt;/h2&gt;
&lt;p&gt;mbp的触控板有目共睹，触感和手势交互甩了普通PC一条街，precision/xps的触控板在win本中属于很优秀的，说实话触感虽然和mac是两种感觉，但也十分不错，可喜的是在黑苹果中precision/xps也各种手势操作能够有效执行，比如三指上下划、五指缩放等等，虽然还有一些距离但已经有些接近mbp了。但是前者触控板做工任然有一些瑕疵，看到很多反馈是有一部分比例的x/p本触控板出现轻微的下凹或上凸。&lt;/p&gt;
&lt;p&gt;Mac可以不需要鼠标，只用触控板做大部分工作，但是我尝试了一下搭载Mac OS的5510，还是不能完全脱离鼠标。&lt;/p&gt;
&lt;h2 id=&#34;键盘&#34;&gt;键盘&lt;/h2&gt;
&lt;p&gt;precision/xps的键盘键程太短，说实话敲起来完全没有感觉，而且品控有的有些问题，我的两个Shift键都失灵了，扣下键帽也按不动就很难受，必须接着外接机械键盘，这样确实没问题而且敲得爽，但是外接键盘背来背去很不方便。&lt;/p&gt;
&lt;h2 id=&#34;续航&#34;&gt;续航&lt;/h2&gt;
&lt;p&gt;续航是4k版本的大短板，第一次使用这台电脑时，不插电两个小时后电脑就没电自动关机了，我的内心是绝望的。一方面是电池本身不足，另一方面是屏幕和显卡等（尤其是屏幕）耗电严重，我的这台5510就算开着屏幕什么软件也不运行，也就只能撑两个来小时；中大型软件开几个，80分钟内就能耗光全部电量。平常使用一直都得插着电，电脑要背走，充电器必须跟着，没有插座的地方完全不敢开机。&lt;/p&gt;
&lt;p&gt;也许是我的这台情况过于严重了，其他的4k屏5510可能要好一些，不过也好不到太多，续航确实是硬伤。&lt;/p&gt;
&lt;h2 id=&#34;相关驱动&#34;&gt;相关驱动&lt;/h2&gt;
&lt;p&gt;intel的网卡无法驱动，需要去某宝单独购买，拆机后自动识别和正常苹果没区别。丽台M1000M图形显卡无法驱动，不过i7 6820hq的集显就够用了，只要不玩大游戏就好说，设计软件无压力。其他的驱动基本都可以正常运行。&lt;/p&gt;
&lt;h3 id=&#34;总结&#34;&gt;总结&lt;/h3&gt;
&lt;p&gt;总的说来，precision 5000系列/XPS 15可能是win阵营中，最适合安装黑苹果的机器之一，尤其是4k版本，触摸屏的加持更是更够体验到Mac OS别样的功能，4k下Mac的体验也比win10强太多了。&lt;/p&gt;
&lt;p&gt;另外这个系列的模具工艺质量与工业设计很出色，也是PC本中少见的设计感与mbp有的一拼的产品。&lt;/p&gt;
&lt;p&gt;以上便是我的Precision 5510安装黑苹果后的使用体验，若有任何疑问或错误请联系我，谢谢。&lt;/p&gt;
&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1550418841/photo_2019-02-17_23.40.26.jpg&#34; width=100%&gt;
&lt;p&gt;两天时间陆陆续续装了一些应用上去（未完待续），下一篇不鸽的话会写Mac的应用推荐与资源分享，不见不散&lt;/p&gt;
</content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://yichengme.site/categories/%E7%94%9F%E6%B4%BB/" term="生活" label="生活" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://yichengme.site/tags/%E9%BB%91%E8%8B%B9%E6%9E%9C/" term="黑苹果" label="黑苹果" />
                            
                        
                            
                            
                            
                                <category scheme="https://yichengme.site/tags/%E6%8A%98%E8%85%BE/" term="折腾" label="折腾" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">Atom的Markdown配置与美化</title>
            <link rel="alternate" type="text/html" href="https://yichengme.site/posts/use-atom-as-an-elegant-markdown-editor/" />
            <id>https://yichengme.site/posts/use-atom-as-an-elegant-markdown-editor/</id>
            <updated>2022-02-08T17:27:00&#43;08:00</updated>
            <published>2019-03-22T16:12:25&#43;08:00</published>
            <author>
                    <name>王毅诚</name>
                    <uri>https://yichengme.site/</uri>
                    <email>engine74396@gmail.com</email>
                    </author>
            <rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">Atom介绍 Atom是一个Github出品的一个开源的免费文本编辑器，和VS Code、Sublime Text是对标产品。 Atom和VS Code一样，都是用Ele……</summary>
            
                <content type="html">&lt;h2 id=&#34;atom介绍&#34;&gt;Atom介绍&lt;/h2&gt;
&lt;p&gt;Atom是一个Github出品的一个开源的免费文本编辑器，和VS Code、Sublime Text是对标产品。&lt;/p&gt;
&lt;p&gt;Atom和VS Code一样，都是用Eletron构建的，插件也基本通用，可以认为是平替，我之所以用Atom主要还是因为其界面看上去更清爽，虽然性能比VS Code差，但是内存够大，实际体验也没有什么延迟。&lt;/p&gt;
&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1537506574/atom_1.png&#34; width=100%&gt;
&lt;p&gt;如果不清楚markdown的语法，可以访问 &lt;a href=&#34;https://www.markdownguide.org/basic-syntax/&#34;&gt;Markdown basics&lt;/a&gt;进行学习，markdown的语法和配置都非常简单，比$LaTeX$容易太多了。&lt;/p&gt;
&lt;p&gt;通过安装支持markdown插件就可以进行markdown的笔记写作，下面是一些我认为比较好的插件&lt;/p&gt;
&lt;h2 id=&#34;markdown-preview-enhanced&#34;&gt;Markdown Preview Enhanced&lt;/h2&gt;
&lt;p&gt;Atom有原生对markdown的支持，但是毕竟简陋，Markdown Preview Enhanced可以扩展更多的功能，比如公式、图床、导出等。&lt;/p&gt;
&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1544349042/Annotation_2018-12-09_175025.jpg&#34; width=&#34;90%&#34;&gt;
&lt;h2 id=&#34;material-ui&#34;&gt;Material UI&lt;/h2&gt;
&lt;p&gt;Material UI几乎是我所有编辑器的UI（包括Atom、VS Code、Jetbrains全家桶等），这套UI非常优雅和美观。&lt;/p&gt;
&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1544348243/Annotation_2018-12-09_173501.jpg&#34; width=&#34;90%&#34;&gt;
&lt;h2 id=&#34;title-bar-replacer-windows专用&#34;&gt;Title-bar-replacer (windows专用)&lt;/h2&gt;
&lt;p&gt;Title-bar-replacer可以隐藏掉windows上方比较唐突的白色标题栏，使软件更加一体化。&lt;/p&gt;
&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1544348538/Annotation_2018-12-09_174204.jpg&#34; width=&#34;90%&#34;&gt;
&lt;h2 id=&#34;markdown-table-editor&#34;&gt;Markdown-table-editor&lt;/h2&gt;
&lt;p&gt;Markdown语法写表格非常麻烦，markdown-table-editor可以使得我们在用写表格的时候更加方便，可以通过Tab、Enter等键快速排版&lt;/p&gt;
&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1544348803/Annotation_2018-12-09_174619.jpg&#34; width=&#34;90%&#34;&gt;
&lt;h3 id=&#34;其他的一些操作&#34;&gt;其他的一些操作&lt;/h3&gt;
&lt;h2 id=&#34;修改字体&#34;&gt;修改字体&lt;/h2&gt;
&lt;p&gt;修改软件界面字体，需要手动修改&lt;code&gt;styles.less&lt;/code&gt;，通过&lt;code&gt;File&lt;/code&gt;-&amp;gt;&lt;code&gt;stylesheet&lt;/code&gt;来打开它&lt;/p&gt;
&lt;p&gt;修改字体的属性：&lt;code&gt;atom-text-editor&lt;/code&gt;, 我最喜欢的代码字体是&lt;code&gt;Fira Code&lt;/code&gt;, 需要在本地电脑先安装&lt;a href=&#34;https://github.com/tonsky/FiraCode&#34;&gt;Fira Code&lt;/a&gt;，然后修改为：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-CSS&#34; data-lang=&#34;CSS&#34;&gt;&lt;span class=&#34;nt&#34;&gt;atom-text-editor&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;n&#34;&gt;text-rendering&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;optimizeLegibility&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
  &lt;span class=&#34;kp&#34;&gt;-webkit-&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;font-smoothing&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;antialiased&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
  &lt;span class=&#34;k&#34;&gt;font-family&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;Fira Code&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
  &lt;span class=&#34;k&#34;&gt;font-weight&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;500&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
  &lt;span class=&#34;k&#34;&gt;line-height&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;mf&#34;&gt;1.7&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;nt&#34;&gt;atom-text-editor&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nc&#34;&gt;editor&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;err&#34;&gt;.syntax--storage.syntax--type.syntax--function.syntax--arrow,&lt;/span&gt;
  &lt;span class=&#34;err&#34;&gt;.syntax--keyword.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;syntax--operator&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;not&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;accessor&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt;
  &lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;syntax--punctuation&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;syntax--definition&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;font-family&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;Fira Code&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
  &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

  &lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nc&#34;&gt;syntax--string&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nc&#34;&gt;syntax--quoted&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt;
  &lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nc&#34;&gt;syntax--string&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nc&#34;&gt;syntax--regexp&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;kp&#34;&gt;-webkit-&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;font-feature-settings&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;liga&amp;#34;&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;off&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;calt&amp;#34;&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;off&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
  &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;err&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;如果要修改markdown右侧预览窗口的字体，则需要去markdown-preview-enhanced的theme里修改css。具体的路径为：&lt;/p&gt;
&lt;p&gt;Windows通常在&lt;/p&gt;
&lt;p&gt;&lt;code&gt;C:\Users\&amp;lt;USER&amp;gt;\.atom\packages\markdown-preview-enhanced\node_modules\@shd101wyy\mume\styles\preview_theme&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;macOS通常在&lt;/p&gt;
&lt;p&gt;&lt;code&gt;/Users/&amp;lt;USER&amp;gt;/.atom/packages/markdown-preview-enhanced/node_modules/@shd101wyy/mume/styles/preview_theme&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;选择目前使用的markdown预览样式的css文件，通常是github-light。&lt;/p&gt;
&lt;p&gt;打开这个css，然后修改诸如字体等属性：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-css&#34; data-lang=&#34;css&#34;&gt;&lt;span class=&#34;nt&#34;&gt;html&lt;/span&gt; &lt;span class=&#34;nt&#34;&gt;body&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;k&#34;&gt;font-family&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;Fira Code&amp;#34;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;...&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;最后的样式：&lt;/p&gt;
&lt;p&gt;Windows:&lt;/p&gt;
&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1549894263/E8F0C761-0FF4-4739-BFFB-62126E855D78_.png.jpg&#34; width=100%&gt;
&lt;p&gt;MacOS:&lt;/p&gt;
&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1585187085/aNa4CHec.png&#34; width=&#34;100%&#34;&gt;
</content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://yichengme.site/categories/%E7%94%9F%E6%B4%BB/" term="生活" label="生活" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://yichengme.site/tags/atom/" term="Atom" label="Atom" />
                            
                        
                            
                            
                            
                                <category scheme="https://yichengme.site/tags/markdown/" term="markdown" label="markdown" />
                            
                        
                            
                            
                            
                                <category scheme="https://yichengme.site/tags/%E7%BE%8E%E5%8C%96/" term="美化" label="美化" />
                            
                        
                    
                
            
        </entry>
    
</feed>
