<?xml version="1.0" encoding="utf-8"?>


<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="zh-CN">
    <title type="text">王毅诚的博客</title>
    <subtitle type="html">这里是王毅诚的博客，分享技术文章和生活经历</subtitle>
    <updated>2022-02-12T21:14:56&#43;08:00</updated>
    <id>https://yichengme.site/</id>
    <link rel="alternate" type="text/html" href="https://yichengme.site/" />
    <link rel="self" type="application/atom&#43;xml" href="https://yichengme.site/atom.xml" />
    <author>
            <name>王毅诚</name>
            <uri>https://yichengme.site/</uri>
            
                <email>engine74396@gmail.com</email>
            </author>
    <rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights>
    <generator uri="https://gohugo.io/" version="0.91.1">Hugo</generator>
        <entry>
            <title type="text">Linux网络编程（二） socket网络编程基础</title>
            <link rel="alternate" type="text/html" href="https://yichengme.site/posts/linux-network-programming-2/" />
            <id>https://yichengme.site/posts/linux-network-programming-2/</id>
            <updated>2022-02-08T17:27:08&#43;08:00</updated>
            <published>2022-02-06T20:00:52&#43;08:00</published>
            <author>
                    <name>王毅诚</name>
                    <uri>https://yichengme.site/</uri>
                    <email>engine74396@gmail.com</email>
                    </author>
            <rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">概述 数据链路层、网络层和传输层的协议都是在操作系统内核中完成的，实现网络的系统调用的api目前最主流的就是socket。 socket是应用层与TCP/IP协议之……</summary>
            
                <content type="html">&lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;
&lt;p&gt;数据链路层、网络层和传输层的协议都是在操作系统内核中完成的，实现网络的系统调用的api目前最主流的就是socket。&lt;/p&gt;
&lt;p&gt;socket是应用层与TCP/IP协议之间的软件抽象，将复杂的TCP/IP协议隐藏在socket后面，用户只需要调用合适的socket api，socket就会组织对应的协议进行通信。&lt;/p&gt;
&lt;p&gt;最基本的客户端-服务器网络模型：
&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1643894720/client-server-1.png&#34; alt=&#34;client-server-1&#34;&gt;&lt;/p&gt;
&lt;p&gt;运行的单位都是进程。&lt;/p&gt;
&lt;p&gt;一个连接可以通过客户端-服务端的ip和端口号唯一确定，被称为套接字对：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;(clientAddr:clientPort, serverAddr, serverPort)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1643894720/client-server-2.png&#34; alt=&#34;client-server-2&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;tcp网络&#34;&gt;TCP网络&lt;/h2&gt;
&lt;p&gt;下图是客户端-服务端TCP网络的核心逻辑&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1643896619/socket-1.jpg&#34; alt=&#34;socket-1&#34;&gt;&lt;/p&gt;
&lt;p&gt;客户端和服务端建立TCP通信的过程：&lt;/p&gt;
&lt;p&gt;服务端：初始化socket，bind绑定到ip和port上然后listen等待
客户端：初始化socket，通过connect发起连接请求，与服务端通过&lt;strong&gt;TCP三次握手&lt;/strong&gt;建立连接。&lt;/p&gt;
&lt;p&gt;连接建立好之后，数据可以双向传输，之后通过客户端的close发起关闭连接请求。处于半关闭状态，服务器收到后也执行close，进入全关闭。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;socket是用来建立网络连接，传输数据的唯一途径&lt;/strong&gt;，成为网络互连的标准。&lt;/p&gt;
&lt;p&gt;可以将TCP的网络交互理解为打电话，socket是电话机，bind的过程就是把电话机连上线。listen的过程就是在家听到了铃响，accept的过程就是拿起听筒开始应答。&lt;/p&gt;
&lt;p&gt;TCP的三次握手相当于，客户端说：你好，我是客户端。服务器说：确实是你，我是服务端。客户端说：确实是你，服务器收到了。&lt;/p&gt;
&lt;p&gt;然后就进入了连接的过程，任意一方说话相当于write，接收到电话的相当于read，可以双向交流。&lt;/p&gt;
&lt;p&gt;拨打电话的结束之后，挂断电话，即close。&lt;/p&gt;
&lt;h2 id=&#34;udp网络&#34;&gt;UDP网络&lt;/h2&gt;
&lt;p&gt;UDP面向数据报，不基于连接，不保障顺序性、可靠性、没有拥塞控制、重传机制等。在IP协议的基础上增加的部分很有限。&lt;/p&gt;
&lt;p&gt;但是在很多不需要完全可靠和完全顺序性的场景，如DNS、多人聊天、直播等。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1643899709/socket-3.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;服务端创建和绑定socket之后，客户端和服务端之间直接通过&lt;code&gt;sendto&lt;/code&gt;和&lt;code&gt;recvfrom&lt;/code&gt;来传递数据，没有建立连接的过程。&lt;/p&gt;
&lt;h2 id=&#34;c语言补充&#34;&gt;C语言补充&lt;/h2&gt;
&lt;p&gt;这里只记录一些后面遇到的C语言相关的一些补充。&lt;/p&gt;
&lt;h3 id=&#34;环境搭建&#34;&gt;环境搭建&lt;/h3&gt;
&lt;p&gt;Linux需要安装编译环境：&lt;/p&gt;
&lt;p&gt;Ubuntu&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;sudo apt-get install gcc g++ make cmake
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;CentOS&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;sudo yum install gcc g++ make cmake
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;mac也可以，用clion的话，需要先安装Xcode command line developer tools（不需要完整的Xcode）&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;n&#34;&gt;xcode&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;select&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;--&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;install&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;表明安装成功&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&amp;gt; clang --version
Apple clang version 12.0.0 &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;clang-1200.0.32.29&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;
Target: x86_64-apple-darwin19.6.0
Thread model: posix
InstalledDir: /Library/Developer/CommandLineTools/usr/bin
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;然后去clion配置好gcc（C编译器）和g++（C++编译器）的路径即可&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://resources.jetbrains.com/help/img/idea/2021.3/cl_toolchain_detectok.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;一些c语言补充的内容&#34;&gt;一些C语言补充的内容&lt;/h3&gt;
&lt;p&gt;C语言中，uintx_t表示的是有x/8个字节的数据类型。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;kt&#34;&gt;uint8_t&lt;/span&gt;
&lt;span class=&#34;kt&#34;&gt;uint16_t&lt;/span&gt;
&lt;span class=&#34;kt&#34;&gt;uint32_t&lt;/span&gt;
&lt;span class=&#34;kt&#34;&gt;uint64_t&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;几个表示size的类型
&lt;code&gt;size_t&lt;/code&gt;就是unsigned long（64位）或者unsigned int （32位）
&lt;code&gt;ssize_t&lt;/code&gt;是long或者int，有符号&lt;/p&gt;
&lt;h2 id=&#34;socket数据结构&#34;&gt;socket数据结构&lt;/h2&gt;
&lt;p&gt;首先看一下socket的通用结构：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// 描述地址类型
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;typedef&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;unsigned&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;short&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;sa_family_t&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;cm&#34;&gt;/* 描述通用套接字地址  */&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;sockaddr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;sa_family_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;sa_family&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;  &lt;span class=&#34;cm&#34;&gt;/* 地址族.  16-bit*/&lt;/span&gt;
    &lt;span class=&#34;kt&#34;&gt;char&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;sa_data&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;14&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;];&lt;/span&gt;   &lt;span class=&#34;cm&#34;&gt;/* 具体的地址值 112-bit */&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;地址族就是说明这个socket是属于哪种类型的地址。比如IPv4、iPv6、本地地址等。&lt;/p&gt;
&lt;p&gt;包括AF_和PF_，其中AF_是地址族，PF_是协议族，一一对应，比如ipv4的就是AF_INET和PF_INET。ipv6的就是AF_INET6和PF_INET6，本地的就是AF_LOCAL和PF_LOCAL。它们也是互相对应相等的。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;8
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#define PF_LOCAL	1	&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt;/* Local to host (pipes and file-domain).  #define PF_FILE		PF_LOCAL /* Another non-standard name for PF_LOCAL
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt;#define PF_INET		2	/* IP protocol family.  */&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;#define PF_INET6	10	&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt;/* IP version 6.  */&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;&lt;/span&gt;
&lt;span class=&#34;cp&#34;&gt;#define AF_LOCAL	PF_LOCAL
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;#define AF_FILE		PF_FILE
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;#define AF_INET		PF_INET
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;#define AF_INET6	PF_INET6
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;IPv4套接字格式：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// 地址为4个字节，32个bit
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// 因为ipv4的ip形式最高是255.255.255.255，每一段需要8bit，1字节，总共需要4个字节，32bit
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;typedef&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;uint32_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;in_addr_t&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;in_addr&lt;/span&gt;
  &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;in_addr_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;s_addr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
  &lt;span class=&#34;p&#34;&gt;};&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;// port是两个字节，16bit，因为2^16=65526，所以port是从0-25535
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;typedef&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;uint16_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;in_port_t&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;

&lt;span class=&#34;cm&#34;&gt;/* 描述 IPV4 的套接字地址格式  */&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;sockaddr_in&lt;/span&gt;
  &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;sa_family_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;sin_family&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;cm&#34;&gt;/* 地址族 16-bit */&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;in_port_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;sin_port&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;     &lt;span class=&#34;cm&#34;&gt;/* 端口口  16-bit*/&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;in_addr&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;sin_addr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;    &lt;span class=&#34;cm&#34;&gt;/* Internet address. 32-bit */&lt;/span&gt;
  &lt;span class=&#34;p&#34;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;IPv6的地址结构：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;9
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;cm&#34;&gt;/* 描述 IPV6 的套接字地址格式  */&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;sockaddr_in6&lt;/span&gt;
  &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;sa_family_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;sin6_family&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;cm&#34;&gt;/*地址族 16-bit */&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;in_port_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;sin6_port&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;  &lt;span class=&#34;cm&#34;&gt;/* 传输端口号 # 16-bit */&lt;/span&gt;
    &lt;span class=&#34;kt&#34;&gt;uint32_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;sin6_flowinfo&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;cm&#34;&gt;/* IPv6 流控信息 32-bit 先不管*/&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;in6_addr&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;sin6_addr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;  &lt;span class=&#34;cm&#34;&gt;/* IPv6 地址 从32位升级到128位，提升非常巨大 128-bit */&lt;/span&gt;
    &lt;span class=&#34;kt&#34;&gt;uint32_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;sin6_scope_id&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;cm&#34;&gt;/* IPv6 域 ID 32-bit  先不管*/&lt;/span&gt;
  &lt;span class=&#34;p&#34;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;除了英特网套接字外，还有本地套接字&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;cm&#34;&gt;/* 描述本地套接字的￥地址格式  */&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;sockaddr_un&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;kt&#34;&gt;unsigned&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;short&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;sun_family&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;cm&#34;&gt;/* 固定为 AF_LOCAL */&lt;/span&gt;
    &lt;span class=&#34;kt&#34;&gt;char&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;sun_path&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;108&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;];&lt;/span&gt;   &lt;span class=&#34;cm&#34;&gt;/* 路径名 */&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;有一些保留端口，比如常见的ftp的21端口，ssh的22端口，http的80端口，一般来说大于5000的端口可以自己用。&lt;/p&gt;
&lt;p&gt;下图是各个地址族的结构&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1643894800/socket-2.png&#34; alt=&#34;socket-2&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;转换函数&#34;&gt;转换函数&lt;/h2&gt;
&lt;h3 id=&#34;ip地址转换&#34;&gt;IP地址转换&lt;/h3&gt;
&lt;p&gt;平常习惯使用十进制来描述ipv4的ip，用十六进制描述ipv6的ip，然而实际计算机都要转换为二进制。如果输出日志，为了可理解性又需要转换为合适的十进制或者十六进制。&lt;/p&gt;
&lt;p&gt;Linux内置了二者互相转换的函数：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;inet_aton&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;char&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;cp&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;in_addr&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;inp&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;char&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;inet_ntoa&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;in_addr&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;in&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;&lt;code&gt;inet_aton&lt;/code&gt;可以将点分十进制字符串表示的ipv4 ip转换为网络字节序表示的&lt;code&gt;in_addr&lt;/code&gt;结构&lt;/p&gt;
&lt;p&gt;&lt;code&gt;inet_ntoa&lt;/code&gt;则相反，将网络字节序表示的&lt;code&gt;in_addr&lt;/code&gt;结构转换为点分十进制字符串表示的ipv4 ip&lt;/p&gt;
&lt;p&gt;一对更好的函数是&lt;code&gt;inet_pton&lt;/code&gt;和&lt;code&gt;inet_ntop&lt;/code&gt;，这个对于ipv4和ipv6通用。以inet_pton为例：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;cp&#34;&gt;# 将string类型的十进制字符串表示的ip写成二进制的网络字节序作为server_address的sin_addr
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;inet_pton&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;AF_INET&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ip&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;server_address&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;sin_addr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h3 id=&#34;主机地址到网络地址&#34;&gt;主机地址到网络地址&lt;/h3&gt;
&lt;p&gt;计算机硬件有两种存储方式大端字节序和小端字节序，比如数值&lt;code&gt;0x1234&lt;/code&gt;，用大端字节序表示符合人类习惯，就是&lt;code&gt;0x1234&lt;/code&gt;，高位是&lt;code&gt;0x12&lt;/code&gt;，低位是&lt;code&gt;0x34&lt;/code&gt;，而用小端字节序的话，各个字节的顺序就要反过来，高位是&lt;code&gt;0x34&lt;/code&gt;，低位是&lt;code&gt;0x12&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1644291229/big-endian-little-endian-1.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;因为计算机电路先处理低位字节的效率比较高，所以计算机内部处理都是用的小端字节序，但是除了内部处理，其他场合比如网络传输、文件存储，还是使用的人类更容易理解的大端字节序。&lt;/p&gt;
&lt;p&gt;所以主机字节序采用小端字节序和网络字节序采用大端字节序，需要进行一个转换。&lt;/p&gt;
&lt;p&gt;转换函数如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;8
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;lt;arpa/inet.h&amp;gt;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// 16/32位的主机字节序转换为网络字节序
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// 其实就是字节的高低位互换
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;uint16_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;htons&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;uint16_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;hostlong&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;kt&#34;&gt;uint32_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;htonl&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;uint32_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;hostlong&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;// 16/32位的网络字节序转换为主机字节序
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;uint16_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ntohs&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;uint16_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;hostlong&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;kt&#34;&gt;uint32_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ntohs&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;uint32_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;hostlong&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h2 id=&#34;socket编程api&#34;&gt;socket编程api&lt;/h2&gt;
&lt;h3 id=&#34;socket的创建&#34;&gt;socket的创建&lt;/h3&gt;
&lt;p&gt;通过&lt;code&gt;socket()&lt;/code&gt;函数创建一个socket，具体参数如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;socket&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;domain&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;type&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;protocol&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;domain是地址族，指PF_INET、PF_INET6、PF_LOCAL这种
type指的是类型，比如&lt;code&gt;SOCK_STREAM&lt;/code&gt;表示字节流，对应TCP，&lt;code&gt;SOCK_DGRAM&lt;/code&gt;表示数据报，对应UDP，&lt;code&gt;SOCK_RAW&lt;/code&gt;表示原始套接字
第三个protocol现在已经废弃，默认填0即可，一般只需要前两个参数。&lt;/p&gt;
&lt;p&gt;这样要创建一个ipv4的TCP socket只需要：
&lt;code&gt;socket(PF_INET, SOCK_STREAM, 0)&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&#34;socket绑定bind&#34;&gt;socket绑定：bind&lt;/h3&gt;
&lt;p&gt;bind函数的作用是将套接字和套接字地址绑定，套接字只知道自己的具体结构类型等，并不知道具体的ip和地址。&lt;/p&gt;
&lt;p&gt;bind函数的定义如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;n&#34;&gt;bind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;fd&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;sockaddr&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;addr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;socklen_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;len&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;第一个参数是套接字，第二个参数是sockaddr结构的套接字地址，第三个参数是地址长度。&lt;/p&gt;
&lt;p&gt;需要将本地套接字格式转换为通用套接字格式。比如&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;sockaddr_in&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;bind&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;sock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;sockaddr&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;sizeof&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;比如把ipv4的sockaddr_in结构&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;sockaddr_in&lt;/span&gt;
  &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;__SOCKADDR_COMMON&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;sin_&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;in_port_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;sin_port&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;			&lt;span class=&#34;cm&#34;&gt;/* Port number.  */&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;in_addr&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;sin_addr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;		&lt;span class=&#34;cm&#34;&gt;/* Internet address.  */&lt;/span&gt;

    &lt;span class=&#34;c1&#34;&gt;// 占位符，无作用
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;kt&#34;&gt;unsigned&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;char&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;sin_zero&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;sizeof&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;sockaddr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
			   &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;__SOCKADDR_COMMON_SIZE&lt;/span&gt;
			   &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;sizeof&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;in_port_t&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
			   &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;sizeof&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;in_addr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)];&lt;/span&gt;
  &lt;span class=&#34;p&#34;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;转换为通用的sockaddr结构&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;sockaddr&lt;/span&gt;
  &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;__SOCKADDR_COMMON&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;sa_&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;	&lt;span class=&#34;cm&#34;&gt;/* Common data: address family and length.  */&lt;/span&gt;
    &lt;span class=&#34;kt&#34;&gt;char&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;sa_data&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;14&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;];&lt;/span&gt;		&lt;span class=&#34;cm&#34;&gt;/* Address data.  */&lt;/span&gt;
  &lt;span class=&#34;p&#34;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;地址可以设置为本机的地址，但是假如说程序部署到本机，地址是本机的局域网ip 192.168.x.x，之后假如程序部署到其他机子上，需要修改为公网ip，所以需要一种通配地址的机制，来让所有目标地址是本机的请求都接收到，ipv4通过&lt;code&gt;INADDR_ANY&lt;/code&gt;，ipv6通过&lt;code&gt;IN6ADDR_ANY&lt;/code&gt;来设置。&lt;/p&gt;
&lt;h3 id=&#34;socket监听listen&#34;&gt;socket监听：listen&lt;/h3&gt;
&lt;p&gt;bind函数让套接字和地址关联，但是还需要将套接字进行监听，通过调用listen让服务处于可接听的状态。&lt;/p&gt;
&lt;p&gt;初始化的套接字是主动套接字，可以主动发起请求，而通过listen函数之后会变成被动套接字，用来等待客户的请求。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;listen(int socket, int backlog)&lt;/code&gt;
第一个参数是套接字，第二个参数是未完成连接队列的大小，决定了可以接收的并发数目&lt;/p&gt;
&lt;h3 id=&#34;接受连接accept&#34;&gt;接受连接：accept&lt;/h3&gt;
&lt;p&gt;服务端的操作系统内核监听到了客户端的请求，类比于接电话就是此时听到了铃响，通过accept来接电话。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;accept&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;listensockfd&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;sockaddr&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;cliaddr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;socklen_t&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;addrlen&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;第一个参数是套接字，第二个参数是连接的客户端的socket地址，第三个参数是地址长度，第二和第三个参数都是传入空然后指针改变从而获取，accept会返回一个新的已连接套接字。因为不可能一个服务端只服务一个客户端。&lt;/p&gt;
&lt;h3 id=&#34;发起连接connect&#34;&gt;发起连接：connect&lt;/h3&gt;
&lt;p&gt;前面的是服务端的连接建立的方法，客户端的创建socket一样，不过之后要通过connect来主动连接服务端。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;connect&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;sockfd&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;sockaddr&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;servaddr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;socklen_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;addrlen&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;第一个参数是套接字，第二个参数是指向套接字地址结构的指针和结构的大小。套接字地址结构需要包含服务端的ip和端口。&lt;/p&gt;
&lt;p&gt;客户端不需要调用bind，在创建完socket后就可以直接调用connect，内核会随机分配一个端口给这次连接。&lt;/p&gt;
&lt;h3 id=&#34;关闭连接close-shutdown&#34;&gt;关闭连接：close, shutdown&lt;/h3&gt;
&lt;p&gt;关闭一个连接，实际上就是关闭连接对应的socket。&lt;/p&gt;
&lt;p&gt;可以通过&lt;code&gt;close&lt;/code&gt;来关闭连接：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;close&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;fd&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;但是close不是直接关闭，实际上只是把fd的引用计数-1，如果要完全关闭的话需要在子进程和父进程都调用close。&lt;/p&gt;
&lt;p&gt;立即终止连接则应该使用&lt;code&gt;shutdown&lt;/code&gt;：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;shutdown&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;sockfd&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;howto&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;&lt;code&gt;howto&lt;/code&gt;包括三种关闭方式：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;SHUT_RD：关闭读&lt;/li&gt;
&lt;li&gt;SHUT_WR：关闭写&lt;/li&gt;
&lt;li&gt;SHUT_RDWR：关闭读写&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;tcp的数据发送和接收write-send-sendmsg-read&#34;&gt;TCP的数据发送和接收：write, send, sendmsg, read&lt;/h3&gt;
&lt;p&gt;建立好连接后，接下来就是发送数据。常见的发送数据的函数有write, send, sendmsg&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;n&#34;&gt;ssize_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;write&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;socketfd&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;buffer&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;size_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;size&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;ssize_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;send&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;socketfd&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;buffer&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;size_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;size&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;flags&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;ssize_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;sendmsg&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;sockfd&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;msghdr&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;msg&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;flags&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;write就是普通的写文件，因为套接字也是文件
如果想发送袋外数据（一种基于TCP的紧急数据），可以用带flag的send
如果想指定多重缓冲区就需要用sendmsg，通过结构体msghdr传递数据&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;n&#34;&gt;ssize_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;read&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;socketfd&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;buffer&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;size_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;size&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;read将会从socket中读取最多size个字节，然后将结果存储到buffer中。&lt;/p&gt;
&lt;h3 id=&#34;udp的数据发送和接收sendto-recvfrom&#34;&gt;UDP的数据发送和接收：sendto, recvfrom&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;n&#34;&gt;ssize_t&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;recvfrom&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;sockfd&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;buff&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;size_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;nbytes&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;flags&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
　　　　　　　　　　&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;sockaddr&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;from&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;socklen_t&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;addrlen&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;

&lt;span class=&#34;n&#34;&gt;ssize_t&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;sendto&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;sockfd&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;buff&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;size_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;nbytes&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;flags&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
                &lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;sockaddr&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;to&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;socklen_t&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;addrlen&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;由于UDP不会保存上下文的信息，所以还额外传递对端的地址端口等信息。TCP在accept阶段就拿到了对端的信息。UDP的每次接收和发送都是独立的上下文。&lt;/p&gt;
</content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://yichengme.site/categories/%E7%90%86%E8%AE%BA/" term="理论" label="理论" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://yichengme.site/tags/linux/" term="Linux" label="Linux" />
                            
                        
                            
                            
                            
                                <category scheme="https://yichengme.site/tags/tcp/ip/" term="TCP/IP" label="TCP/IP" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">Linux网络编程（一） 从TCP/IP协议开始</title>
            <link rel="alternate" type="text/html" href="https://yichengme.site/posts/linux-network-programming-1/" />
            <id>https://yichengme.site/posts/linux-network-programming-1/</id>
            <updated>2022-02-08T17:27:00&#43;08:00</updated>
            <published>2022-02-01T14:44:13&#43;08:00</published>
            <author>
                    <name>王毅诚</name>
                    <uri>https://yichengme.site/</uri>
                    <email>engine74396@gmail.com</email>
                    </author>
            <rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">重温计算机网络 TCP/IP协议是目前互联网的主流协议簇，早在计算机网络中我们就已经学习过大部分的内容，现在我们从协议的角度出发再次重温计算机网络的内容，作为后续……</summary>
            
                <content type="html">&lt;h2 id=&#34;重温计算机网络&#34;&gt;重温计算机网络&lt;/h2&gt;
&lt;p&gt;TCP/IP协议是目前互联网的主流协议簇，早在计算机网络中我们就已经学习过大部分的内容，现在我们从协议的角度出发再次重温计算机网络的内容，作为后续内容的基础。&lt;/p&gt;
&lt;p&gt;在物理传输媒介的基础上的四层网络模型，自底向上分别是数据链路层、网络层、传输层、应用层，各层包含的协议如图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1643112994/TCP-IP-1.png&#34; alt=&#34;tcp-ip-1&#34;&gt;&lt;/p&gt;
&lt;p&gt;实体通信用实线表示，逻辑通信用虚线表示。链路层封装了物理传输的细节，网络层封装了路由逐条通信的细节，传输层开始就是端到端的协议&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1643164972/TCP-IP-2.png&#34; alt=&#34;tcp-ip-2&#34;&gt;&lt;/p&gt;
&lt;p&gt;具体的内容在前面的计算机网络基础中已经做了详细的介绍，这里只讨论各层的一部分重要协议。&lt;/p&gt;
&lt;p&gt;ARP协议：链路层协议，完成IP地址到MAC地址的转换
IP协议：网络层协议，完成IP数据报的投递，确定通信路径
ICMP协议：网络层协议，IP协议的补充，用于检测网络连接
TCP协议：传输层协议，提供可靠的、面向连接的基于流的服务
UDP协议：传输层协议，提供不可靠的、无连接的基于数据报的服务
DNS协议：应用层协议，完成域名到IP地址的转换&lt;/p&gt;
&lt;h2 id=&#34;封装与分用&#34;&gt;封装与分用&lt;/h2&gt;
&lt;p&gt;封装指的是上层协议的数据沿协议栈往下传递，每经过一个协议栈就加上头部信息，最终合成以太网帧或令牌环帧在物理层上传递：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1643166755/TCP-IP-3.png&#34; alt=&#34;tcp-ip-2&#34;&gt;&lt;/p&gt;
&lt;p&gt;分用指的是帧到了目的地后的从底向上传递的过程，每个协议栈取出自己的头部，将信息往上传递。头部包含了具体的类型参数，根据头部信息递交给不同的上层。&lt;/p&gt;
&lt;p&gt;比如以太帧用2字节的类型字段来区分IP或ARP
IP数据报根据头部的16位协议编码区分TCP、UDP和ICMP
TCP和UDP通过头部的端口号来区分具体的应用&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1643167303/TCP-IP-4.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;对于顶层应用而言，好像封装和分用没有发生过。&lt;/p&gt;
&lt;h2 id=&#34;arp协议&#34;&gt;ARP协议&lt;/h2&gt;
&lt;p&gt;ARP实现的是网络层IP地址到物理网卡MAC地址的转换，原理是主机向网络广播一个ARP请求，包含目标主机的IP地址，只有被请求到的目标机器才会返回一个ARP应答，包含其物理地址。&lt;/p&gt;
&lt;p&gt;具体的请求和应答的报文格式就不详述，这里ARP会维护一个高速缓存，包含经常访问的机器的IP地址到MAC地址的映射，从而提高效率，避免重复请求。&lt;/p&gt;
&lt;p&gt;Unix（Linux、macOS）可以通过&lt;code&gt;arp&lt;/code&gt;相关命令来管理arp缓存。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;arp -a&lt;/code&gt;：查看所有arp缓存，左边括号内为IP地址，右边为MAC地址。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;? (169.254.72.54) at 60:6d:c7:c6:4c:e5 on en0 [ethernet]
? (169.254.100.233) at 94:e9:79:ff:aa:eb on en0 [ethernet]
file-center.lan (192.168.50.1) at f8:32:e4:84:16:60 on en0 ifscope [ethernet]
? (192.168.50.43) at 3e:cc:9e:13:e6:a4 on en0 ifscope [ethernet]
...
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;arp -d &amp;lt;ip&amp;gt;&lt;/code&gt;：删除某个ip的arp缓存
&lt;code&gt;arp -s &amp;lt;ip&amp;gt; &amp;lt;mac&amp;gt;&lt;/code&gt;：添加某个ip到mac的arp缓存&lt;/p&gt;
&lt;h2 id=&#34;dns协议&#34;&gt;DNS协议&lt;/h2&gt;
&lt;p&gt;DNS协议将域名转换为IP地址，它是一套分布式的域名服务系统，每个DNS服务器都存放大量的域名-IP地址映射，且动态更新。&lt;/p&gt;
&lt;p&gt;Unix下在&lt;code&gt;/etc/resolv.conf&lt;/code&gt;保存了DNS服务器的地址，该文件是随着网络连接状态自动更新的。&lt;/p&gt;
&lt;p&gt;比如连接wifi后，为&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;search lan
nameserver 192.168.50.1
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这里&lt;code&gt;192.168.50.1&lt;/code&gt;是路由器的ip，即依靠局域网的路由器搜索DNS&lt;/p&gt;
&lt;p&gt;而连接了热点之后就立刻变为了&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;nameserver 2409:8938:1610:7763::18
nameserver 192.168.109.2
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;断网之后该文件内容变为空。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;host -t A &amp;lt;host&amp;gt;&lt;/code&gt;：查询某个域名的IP地址，如&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;www.baidu.com is an alias for www.a.shifen.com.
www.a.shifen.com has address 36.152.44.96
www.a.shifen.com has address 36.152.44.95
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;ip协议&#34;&gt;IP协议&lt;/h2&gt;
&lt;p&gt;IP协议是网络层协议，是TCP/UDP的基础，它为上层提供无连接、不可靠、无状态的服务。&lt;/p&gt;
&lt;h3 id=&#34;ipv4的ip头部与分片传输&#34;&gt;ipv4的IP头部与分片传输&lt;/h3&gt;
&lt;p&gt;ipv4的IP头部：
&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1643256162/TCP-IP-5.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;IP的长度超过mtu时会被分片传输，然后在接收端整合，以太帧的mtu通常是1500字节，去掉20字节的头部，还有1480字节可以放数据，数据如果超过1480字节则必须分片传输。&lt;/p&gt;
&lt;p&gt;比如1481字节的ICMP报文，需要分两片来传输：
&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1643256162/TCP-IP-6.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;ip路由机制&#34;&gt;IP路由机制&lt;/h3&gt;
&lt;p&gt;IP协议的核心是路由，即从源机器如何通过网络转发给目标机器。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1643261497/TCP-IP-7.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;接受到了来自链路层的IP数据报后，先通过CRC校验，然后判断是否是发给本机网络或者广播的数据报，如果是的话就依据具体的头部信息传递给TCP/UDP/ICMP模块。如果不是的话就转发给下一跳，具体转发方式是路由协议的内容，比如RIP、OSPF算法等，这个在之前的计算机网络中已经学过了，就不在此细说了。&lt;/p&gt;
&lt;h2 id=&#34;tcp协议&#34;&gt;TCP协议&lt;/h2&gt;
&lt;p&gt;TCP的特征：一对一、全双工、先建立连接、字节流传输、可靠传输&lt;/p&gt;
&lt;p&gt;其他几个很简单，提一下字节流传输，TCP使用字节流传输，而UDP使用数据报传输，字节流的特点就是：发送端执行的写操作次数和接收端执行的读操作次数没有任何数量关系，因为发送缓冲区和接受缓冲区的存在。&lt;/p&gt;
&lt;h3 id=&#34;发送缓冲区与接收缓冲区&#34;&gt;发送缓冲区与接收缓冲区&lt;/h3&gt;
&lt;p&gt;TCP三次握手建立之后，内核会为每一个连接建立配套的基础设施，其中就包括发送缓冲区。&lt;/p&gt;
&lt;p&gt;发送缓冲区的大小可以通过套接字的选项来调整，假如客户端调用write，实际上是将数据从应用程序拷贝到内核中的发送缓冲区中，而不是通过socket。&lt;/p&gt;
&lt;p&gt;如果发送缓冲区足够大，那么write调用成功返回写入的字节数。
如果数据还没发送完，或者缓冲区不够大，内核并不会返回或者报错，而是被阻塞。直到发送完。&lt;/p&gt;
&lt;p&gt;缓冲区类似一条流水线，每次都能不断将数据封装打包为TCP的MSS和IP的MTU包然后从数据链路层打包出去，缓冲区就会空一部分，可以继续搬一部分数据到缓冲区，所以最终总能搬完所有的数据。然后write阻塞就会调用返回，write返回的时候，数据并不是已经发送过去了，而是还有一部分会在缓冲区里，之后会发过去。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1643272895/TCP-IP-9.png&#34; alt=&#34;TCP-IP-9&#34;&gt;&lt;/p&gt;
&lt;p&gt;缓冲区也是TCP字节流传输和UDP数据报传输的一个区别：&lt;/p&gt;
&lt;p&gt;TCP字节流传输：
&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1643272895/TCP-IP-10.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;UDP数据报传输：
&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1643272895/TCP-IP-11.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;tcp的建立三次握手&#34;&gt;TCP的建立：三次握手&lt;/h3&gt;
&lt;p&gt;著名的TCP三次握手：
&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1643272895/TCP-IP-8.png&#34; alt=&#34;tcp三次握手-1&#34;&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;客户端协议栈向服务端发送SYN包，并表明当前发送序列号为j，客户端进入SYN_SENT状态&lt;/li&gt;
&lt;li&gt;服务端的协议栈收到了这个包之后，对客户端的这个SYN进行应答，值为j+1，同时服务器也发送一个SYN包，内容是k，服务器进入SYNC_RCVD状态&lt;/li&gt;
&lt;li&gt;客户端协议栈收到了ACK之后，应用程序的connect调用返回，客户端到服务端的单向通信建立成功。并进入ESTABLISH状态，同时对服务端进行ACK应答，应答值为k+1&lt;/li&gt;
&lt;li&gt;应答包到达服务器，服务器协议端的accept阻塞调用返回，服务器到客户端的单向通信也建立成功。&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;思考一下为什么是三次。
我的理解是，如果A到B的传输连接要成功，至少需要两步，A尝试传一个信息到B，B再返回一个应答。这样就说明了A到B的单向没有问题。反过来也一样。正常来说应该需要四次握手，不过在服务端应答客户端的时候服务端顺便发送请求包，这样节省了一步。所以说最少是三次握手，两次必然不能保证一定连接成功，四次则多浪费了一次。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;tcp的关闭四次挥手与time_wait&#34;&gt;TCP的关闭：四次挥手与TIME_WAIT&lt;/h3&gt;
&lt;p&gt;TCP是全双工的，所以存在一种半关闭状态，也就是A可以接受B发送来的数据，但是A不再发送数据给B，也就是说一端可以告诉对方自己发送的数据已经发完了，但仍然可以接受对方发送的数据，进入半关闭状态，如果对方也发送完了，就进入关闭状态。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1643272895/TCP-IP-12.png&#34; alt=&#34;time_wait-1&#34;&gt;&lt;/p&gt;
&lt;p&gt;一个完整的建立和关闭的过程：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1643549232/TCP-IP-14.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;time_wait&#34;&gt;TIME_WAIT&lt;/h3&gt;
&lt;p&gt;这里提一下TIME_WAIT状态。假设是主机一发送FIN到主机二，在收到FIN n的时候，主机一会进入TIME_WAIT的状态，停留时间是固定的。Linux下是两个最长份节生命周期的时间（即2MSL）。只有发起连接终止的一方会进入TIME_WAIT状态。&lt;/p&gt;
&lt;p&gt;为什么有TIME_WAIT？因为TCP要考虑各种错误情况，假如最后一次挥手客户端的ACK没有传到服务端，那么服务端之后会重发FIN报文。此时如果客户端没有维护TIME_WAIT而是直接关闭，就会失去上下文。坚持2MSL，使得这次连接所有的迟到的报文来得及被丢弃&lt;/p&gt;
&lt;p&gt;但是TIME_WAIT过多，会导致端口资源被占用，有时候可能由于TIME_WAIT导致性能下降。&lt;/p&gt;
&lt;h3 id=&#34;tcp状态转移&#34;&gt;TCP状态转移&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1643273832/TCP-IP-13.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;虚线为服务端，粗实线为客户端。&lt;/p&gt;
&lt;h3 id=&#34;tcp超时重传策略&#34;&gt;TCP超时重传策略&lt;/h3&gt;
&lt;p&gt;每个TCP报文都维护了一个重传定时器，如果超过时间没有收到对方的应答，发送方就会重传TCP报文并reset定时器。&lt;/p&gt;
&lt;p&gt;一般每次重传都比之前的时间间隔更长（比如是上一次的两倍），并且设置最多重传次数，超过这个次数就放弃。&lt;/p&gt;
&lt;h3 id=&#34;tcp拥塞控制&#34;&gt;TCP拥塞控制&lt;/h3&gt;
&lt;p&gt;由于链路层的承载量有限，需要进行控制。&lt;/p&gt;
&lt;p&gt;SWND（Send WiNDow，发送窗口）：指的是发送端向网络一次性发送的数据量。&lt;/p&gt;
&lt;p&gt;如果RWND过小，则延迟会比较大。如果RWND过大，则容易网络拥塞。&lt;/p&gt;
&lt;p&gt;RWND（Receive WiNDow，接收窗口）：指的是接收端一次性能接收的数据量。&lt;/p&gt;
&lt;p&gt;CWND（Congestion WiNDow，拥塞窗口）：不造成拥塞的最大数据量&lt;/p&gt;
&lt;p&gt;实际的 $\text{SWND} = \min(\text{RWND}, \text{CWND})$&lt;/p&gt;
&lt;p&gt;启动阶段包括以下两种算法：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;慢启动&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;设置了一个慢启动门限ssthresh，最开始启动的时候CWND设置一个较小的值（2-4个SMSS），然后慢慢按照指数方式增大CWND的值，直到超过这个门限，然后进入拥塞避免控制。&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;拥塞避免&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;每经过一个轮次，线性增加其大小而不是加倍，让其缓慢增大，出现一次超时后（发生拥塞），就让慢开始门限等于当前cwnd的一半，cwnd重新设为1&lt;/p&gt;
&lt;p&gt;cwnd &amp;gt; ssthresh: 慢启动
cwnd &amp;lt; ssthresh: 拥塞避免&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1643557367/TCP-IP-15.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;拥塞处理包括以下两种算法：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;快重传&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;当发送方连续收到三个重复的ACK报文时，直接重传对方尚未收到的报文段，而不必等待那个报文段设置的重传计时器超时。&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;快恢复&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;快恢复前面和避免算法一样，不同之处是它把cwnd的值设置为慢开始门限ssthresh改变后的数值，然后开始执行拥塞避免算法&lt;/p&gt;
&lt;h2 id=&#34;代理服务器&#34;&gt;代理服务器&lt;/h2&gt;
&lt;p&gt;客户机和目标服务器之间通常需要一些中转服务器进行代理中转访问。&lt;/p&gt;
&lt;h3 id=&#34;正向代理&#34;&gt;正向代理&lt;/h3&gt;
&lt;p&gt;代理服务器的信息需要由客户端设置，每次请求都发送到代理服务器上，然后由代理服务器请求目标资源。
目标服务器并不清楚具体的客户端。
比如科学上网经典的shadowsocks就是这种方式。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1643610218/TCP-IP-17.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;反向代理&#34;&gt;反向代理&lt;/h3&gt;
&lt;p&gt;反向代理由服务端设置，代理服务器接收客户端的连接，然后转发给目标服务器，获得结果后返回给客户端，对外表现就像是目标服务器一样。
客户端并不清楚具体的服务器。很多大型网站都使用反向代理，用户访问该网站，会访问相同地域的反向代理服务器，从而节约时间。以及做负载均衡的nginx、CDN等等。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1643559177/TCP-IP-16.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;http通信&#34;&gt;HTTP通信&lt;/h2&gt;
&lt;h3 id=&#34;http请求&#34;&gt;HTTP请求&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1643611443/TCP-IP-18.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;tcp应答&#34;&gt;TCP应答&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1643698156/HTTP%E7%8A%B6%E6%80%81%E7%A0%81.png&#34; alt=&#34;HTTP状态码&#34;&gt;&lt;/p&gt;
</content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://yichengme.site/categories/%E7%90%86%E8%AE%BA/" term="理论" label="理论" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://yichengme.site/tags/linux/" term="Linux" label="Linux" />
                            
                        
                            
                            
                            
                                <category scheme="https://yichengme.site/tags/tcp/ip/" term="TCP/IP" label="TCP/IP" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">RPC基础</title>
            <link rel="alternate" type="text/html" href="https://yichengme.site/posts/rpc-basics/" />
            <id>https://yichengme.site/posts/rpc-basics/</id>
            <updated>2022-02-08T17:27:00&#43;08:00</updated>
            <published>2022-01-20T13:29:14&#43;08:00</published>
            <author>
                    <name>王毅诚</name>
                    <uri>https://yichengme.site/</uri>
                    <email>engine74396@gmail.com</email>
                    </author>
            <rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">RPC的概念 RPC（Romote Procedure Call），全称是远程过程调用，作为分布式系统中不同节点之间的通信方式，是分布式系统的基石之一，RPC不是具体的方法，而是一种……</summary>
            
                <content type="html">&lt;h2 id=&#34;rpc的概念&#34;&gt;RPC的概念&lt;/h2&gt;
&lt;p&gt;RPC（Romote Procedure Call），全称是远程过程调用，作为分布式系统中不同节点之间的通信方式，是分布式系统的基石之一，RPC不是具体的方法，而是一种解决不同服务之间调用的设计。&lt;/p&gt;
&lt;p&gt;基于RPC开发的框架可以称为RPC框架，典型的有谷歌的gRPC、阿里的Dubbo、Facebook的Thrift等，当然成熟的RPC框架还会有服务注册与发现、服务治理、负载均衡等功能。&lt;/p&gt;
&lt;h2 id=&#34;为何需要rpc&#34;&gt;为何需要RPC&lt;/h2&gt;
&lt;p&gt;大公司的服务往往部署在不同的机器上，调用其他机器的服务如果每次都要走网络通信会给业务开发带来复杂，希望能够将网络通信进行封装，使得远程调用和本地调用一样简单，于是诞生了RPC。&lt;/p&gt;
&lt;p&gt;RPC对应的一个概念就是本地调用，比如最常见的函数调用，当然远程调用比本地调用复杂的多。我们最终的目的就是通过封装调用的底层过程，让远程调用和本地调用一样方便，请求方调用服务方的某个方法就像是调用本地方法一样。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;为什么不采用基于HTTP的Restful api而采用RPC呢？
实际上，广义的RPC也包括了基于HTTP的Restful api，不过默认指的是中间传输形式为二进制流的跨机器通信方式。基于HTTP协议的restful api更通用、可读性更好，但是报文比较冗余，性能不如二进制传输的RPC。RCP更接近直接调用，也更容易拓展和集成一些功能（如注册中心、负载均衡等）应该视具体情况选择，对性能要求非常高的场景可以使用RPC。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;rpc的核心问题&#34;&gt;RPC的核心问题&lt;/h2&gt;
&lt;h3 id=&#34;寻址问题&#34;&gt;寻址问题&lt;/h3&gt;
&lt;p&gt;如果是本地运行，直接可以获得函数的指针，但是远程的不行，一个方法是Server和Client分别维护一个函数&amp;lt;-&amp;gt;call id的映射表。服务器需要将提供的服务接口进行注册，从而让请求方可以获取到。&lt;/p&gt;
&lt;h3 id=&#34;编码方式&#34;&gt;编码方式&lt;/h3&gt;
&lt;p&gt;比如常见的可读性高的JSON、XML或者性能更好的protobuf。&lt;/p&gt;
&lt;h3 id=&#34;序列化和反序列化&#34;&gt;序列化和反序列化&lt;/h3&gt;
&lt;p&gt;Client：
① tcp/http连接
② 对象结构数据序列化
③ 发送json
④ 等待结果
⑤ 解析结果，反序列化为需要的对象结构&lt;/p&gt;
&lt;p&gt;Server：
① 监听对应端口
② 读取数据
③ 反序列化为需要的对象结构
④ 运行对应的函数处理
⑤ 序列化
⑥ 将结果传输返回&lt;/p&gt;
&lt;p&gt;实际上解决好了之后，语言也不重要了，都可以使用不同的语言。&lt;/p&gt;
&lt;h3 id=&#34;网络传输协议&#34;&gt;网络传输协议&lt;/h3&gt;
&lt;p&gt;比如考虑tcp是用长连接还是短连接，http1.0中，对方返回结果之后，会自动断开，下次连接会比较慢。http2.0可以保持长连接，所以gRPC直接用了http2.0。
可以走http，也可以自己基于tcp协议封装一个长连接。&lt;/p&gt;
&lt;h2 id=&#34;rpc的四个要素&#34;&gt;RPC的四个要素&lt;/h2&gt;
&lt;h3 id=&#34;client&#34;&gt;Client&lt;/h3&gt;
&lt;p&gt;服务调用的发起方&lt;/p&gt;
&lt;h3 id=&#34;client-stub&#34;&gt;Client Stub&lt;/h3&gt;
&lt;p&gt;用于存储要调用的服务器地址、以及将要请求的数据信息打包，通过网络请求发送给Server Stub，然后阻塞，直到接受到返回的数据，然后进行解析。&lt;/p&gt;
&lt;h3 id=&#34;server&#34;&gt;Server&lt;/h3&gt;
&lt;p&gt;Server，包含要调用的方法&lt;/p&gt;
&lt;h3 id=&#34;server-stub&#34;&gt;Server Stub&lt;/h3&gt;
&lt;p&gt;用于接受Client Stub发送的请求数据包并进行解析，完成功能调用，最后将结果进行打包并返回给Client Stub。在没有接受到请求数据包时则处于阻塞状态。&lt;/p&gt;
&lt;p&gt;封装了Client Stub和Server Stub后，从Client的角度来看，似乎和本地调用一样。从Server的角度看，似乎就是客户直接调用。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1643108079/rpc-1.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;rpc的具体通信步骤&#34;&gt;RPC的具体通信步骤&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;Client以类似本地调用的方式调Client Stub&lt;/li&gt;
&lt;li&gt;Client Stub序列化生成消息，然后调用本地操作系统的通信模块， Stub阻塞&lt;/li&gt;
&lt;li&gt;本地操作系统与远程Server进行通信，消息传输到远程操作系统&lt;/li&gt;
&lt;li&gt;远程操作系统将消息传递给Server Stub&lt;/li&gt;
&lt;li&gt;Server Stub进行反序列化，然后调用Server的对应方法&lt;/li&gt;
&lt;li&gt;Server程序执行方法，将结果传递给Server Stub&lt;/li&gt;
&lt;li&gt;Server Stub将结果进行序列化，然后传递给Server操作系统&lt;/li&gt;
&lt;li&gt;Server操作系统将结果传递给Client&lt;/li&gt;
&lt;li&gt;Client操作系统将其交给Client Stub， Stub从阻塞状态恢复&lt;/li&gt;
&lt;li&gt;Client Stub对结果进行反序列化，并将值返回给Client程序&lt;/li&gt;
&lt;li&gt;Client程序获得返回结果&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;RPC就是把2-10步进行了封装。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://pic1.zhimg.com/80/v2-619633f1a8ff09c38a0611b1a0d62afc_1440w.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;一些RPC框架可以通过一个接口定义语言（IDL）定义接口和数据类型，然后自动生成各种语言的stub代码。&lt;/p&gt;
&lt;h2 id=&#34;go的rpcnetrpc&#34;&gt;Go的RPC：net/rpc&lt;/h2&gt;
&lt;h3 id=&#34;使用&#34;&gt;使用&lt;/h3&gt;
&lt;p&gt;Go语言的标准库也提供了一个简单的RPC实现:&lt;code&gt;net/rpc&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Go的RPC规则：&lt;strong&gt;方法只能有两个序列化参数，其中第二个参数是指针类型，并且只能返回一个error类型，同时必须是公开的方法。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;即形式只能为：&lt;code&gt;func (t *T) MethodName(argType T1, replyType *T2) error&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;其中第一个参数是调用者收到的参数，第二个参数是方法返回的参数。如果&lt;/p&gt;
&lt;p&gt;RPC的Hello World：
（ip和端口可视情况调整，Server和Client可以在不同机器上运行）&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// Server.go
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// 先声明Service结构
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;helloService&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{}&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;// 定义一个方法，注意只能两个参数，第二个为指针，返回一个error
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;p&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;helloService&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;Hello&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;request&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;reply&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;error&lt;/span&gt;  &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;reply&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;Hello, &amp;#34;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;request&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;  &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;c1&#34;&gt;// 要注册一个名字
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;nx&#34;&gt;_&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;rpc&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;RegisterName&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;HelloService&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;new&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;helloService&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt;
	&lt;span class=&#34;c1&#34;&gt;// 采用tcp通信
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;nx&#34;&gt;listener&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;net&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Listen&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;tcp&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;:1234&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;log&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Fatal&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;conn&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;listener&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Accept&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;log&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Fatal&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;rpc&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;ServeConn&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;conn&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// Client.go
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;Client&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;rpc&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Dial&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;tcp&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;192.168.50.174:1234&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;log&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Fatal&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
	&lt;span class=&#34;kd&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;reply&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;Client&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Call&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;HelloService.Hello&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;engine&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;reply&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;log&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Fatal&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;fmt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Println&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;reply&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;做一些改进，一方面，Server应该是持续保持连接，并且支持多个Client共同连接，不能Client运行完就断开。另一方面，Client做一些封装，比较方便：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;9
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// Server.go
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;//...
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;nx&#34;&gt;conn&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;listener&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Accept&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
  &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;nx&#34;&gt;log&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Fatal&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
  &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
  &lt;span class=&#34;k&#34;&gt;go&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;rpc&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;ServeConn&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;conn&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;30
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;31
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// Client.go
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;HelloServiceName&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;HelloService&amp;#34;&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;HelloServiceClient&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;rpc&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Client&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;HelloServiceDial&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;network&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;address&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;HelloServiceClient&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;error&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;Client&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;rpc&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Dial&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;network&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;address&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;log&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Fatal&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;HelloServiceClient&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Client&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;Client&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;},&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;h&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;HelloServiceClient&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;Hello&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;request&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;reply&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;error&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;h&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Client&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Call&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;HelloServiceName&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;.Hello&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;request&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;reply&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;hs&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;HelloServiceDial&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;tcp&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;192.168.50.174:1234&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;log&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Fatal&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
	&lt;span class=&#34;kd&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;reply&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;hs&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Hello&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;engine&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;reply&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;log&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Fatal&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;fmt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Println&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;reply&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;标准库的rpc采用go语言特有的gob编码，如果需要跨语言的客户端，则可以采用一种通用的编码格式，比如json，Server端可以通过：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// go rpc.ServeConn(conn)
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;go&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;rpc&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;ServeCodec&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;jsonrpc&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;NewServerCodec&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;conn&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;而客户端可以使用：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;nx&#34;&gt;conn&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;net&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Dial&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;tcp&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;localhost:1234&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;log&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Fatal&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;dial error&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;nx&#34;&gt;client&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;rpc&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;NewClientWithCodec&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;jsonrpc&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;NewClientCodec&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;conn&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;</content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://yichengme.site/categories/%E7%90%86%E8%AE%BA/" term="理论" label="理论" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://yichengme.site/tags/rpc/" term="RPC" label="RPC" />
                            
                        
                            
                            
                            
                                <category scheme="https://yichengme.site/tags/%E5%88%86%E5%B8%83%E5%BC%8F/" term="分布式" label="分布式" />
                            
                        
                            
                            
                            
                                <category scheme="https://yichengme.site/tags/golang/" term="Golang" label="Golang" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">无线网络基础</title>
            <link rel="alternate" type="text/html" href="https://yichengme.site/posts/wireless-network-basic/" />
            <id>https://yichengme.site/posts/wireless-network-basic/</id>
            <updated>2022-02-12T21:04:15&#43;08:00</updated>
            <published>2022-01-13T17:34:00&#43;08:00</published>
            <author>
                    <name>王毅诚</name>
                    <uri>https://yichengme.site/</uri>
                    <email>engine74396@gmail.com</email>
                    </author>
            <rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">信息论基础 信息是事物运动状态或存在方式的不确定性的描述 通信系统形式上传递的就是信息，需求来源于： ① 需要告知某信息给对方 ② 需要接受某种信息。通信的结果就是消除不确……</summary>
            
                <content type="html">&lt;h2 id=&#34;信息论基础&#34;&gt;信息论基础&lt;/h2&gt;
&lt;p&gt;信息是事物运动状态或存在方式的不确定性的描述&lt;/p&gt;
&lt;p&gt;通信系统形式上传递的就是信息，需求来源于：&lt;/p&gt;
&lt;p&gt;① 需要告知某信息给对方&lt;/p&gt;
&lt;p&gt;② 需要接受某种信息。通信的结果就是消除不确定性或者获得信息。&lt;/p&gt;
&lt;p&gt;信息论研究的目的在于：通过探索信息传输的规律，提高信息传输的有效性、可靠性和保密性，使得信息系统达到最优化。&lt;/p&gt;
&lt;p&gt;数据：传送信息的实体&lt;/p&gt;
&lt;p&gt;信号：数据的电气或电磁表现，数据在传输过程中的存在形式
（连续变化的称为模拟数据/信号，离散变化的数据称为数字数据/信号）&lt;/p&gt;
&lt;p&gt;码元：用一个固定时长的信号波形代表一位k进制数字&lt;/p&gt;
&lt;p&gt;信源：产生和发送数据的源头&lt;/p&gt;
&lt;p&gt;信道：信号的传输媒介
s
信宿：接收数据的终点&lt;/p&gt;
&lt;p&gt;速率：数据的传输速率，表示单位时间内传输的数据量，码元传输速率单位是波特（Baud），信息运输速率单位是 比特/秒 (b/s)&lt;/p&gt;
&lt;p&gt;$$比特/秒 = 波特 \times \log_2电平数$$&lt;/p&gt;
&lt;p&gt;波特：每秒内信息改变的次数，一波特就表示数字通道系统一秒钟传输一个码元&lt;/p&gt;
&lt;p&gt;带宽：指信号具有的频带宽度，单位是赫兹（Hz），表示单位时间内从网络某一点到另一点所能通过的最高数据率，此时单位是bit/s&lt;/p&gt;
&lt;h2 id=&#34;信息量&#34;&gt;信息量&lt;/h2&gt;
&lt;p&gt;信息量 = 不确定性的减少量 = 收信前的不确定性 - 收信后的不确定性&lt;/p&gt;
&lt;p&gt;某个事件发生的信息量是该事件发生的先验概率的函数：&lt;/p&gt;
&lt;p&gt;$$I(a_i) = f[P(a_i)]$$&lt;/p&gt;
&lt;p&gt;有$I(a_0 = 0) = \infty, I(a_0 = 1) = 0$&lt;/p&gt;
&lt;p&gt;独立事件的联合信息量等于各自的信息量之和&lt;/p&gt;
&lt;p&gt;自信息量的计算公式为：&lt;/p&gt;
&lt;p&gt;$$
I(a_i) = \log \frac{1}{P(a_i)}
$$&lt;/p&gt;
&lt;p&gt;以2为底，单位为比特；以e为底，单位为奈特；以10为底，单位为哈特。&lt;/p&gt;
&lt;h2 id=&#34;熵&#34;&gt;熵&lt;/h2&gt;
&lt;p&gt;反应了信源整体的不确定度&lt;/p&gt;
&lt;p&gt;$$
H(x) = -\sum_x p(x)\log p(x)
$$&lt;/p&gt;
&lt;p&gt;联合熵：
$$
H(X, Y) = -\sum_{x,y} p(x,y)\log p(x,y)
$$&lt;/p&gt;
&lt;p&gt;条件熵：
$$
H(X | Y) = - \sum_y H(X|Y=y) p(y) = -\sum_{y} \sum_{x} p(x \mid y) p(y) \log p(x \mid y)
$$&lt;/p&gt;
&lt;p&gt;互信息：
$$
I(X;Y) = \sum_{x,y} p(x,y) \log \frac{p(x,y)}{p(x)p(y)}
$$&lt;/p&gt;
&lt;p&gt;两个独立的随机变量的互信息等于0&lt;/p&gt;
&lt;h2 id=&#34;信源编码与信道编码&#34;&gt;信源编码与信道编码&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1641283110/xxl-1.png&#34; alt=&#34;xxl-1&#34;&gt;&lt;/p&gt;
&lt;p&gt;信号先经过信源编码，然后进入信道前经过信道编码。&lt;/p&gt;
&lt;p&gt;信源编码的作用：信息量的压缩，减少原信号的冗余&lt;/p&gt;
&lt;p&gt;信道编码的作用：信息量的增加，用于增加可靠性&lt;/p&gt;
&lt;p&gt;带宽受限且有高斯白噪声干扰的信道的极限、无差错的信息传输速率&lt;/p&gt;
&lt;h3 id=&#34;无线通信系统&#34;&gt;无线通信系统&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1641799607/transceiver-1.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;源信号依次经过信源编码、加密、信道编码、调制然后发送出去，接受时依次经过解调、信道解码、解密、信源解码然后接受。&lt;/p&gt;
&lt;h2 id=&#34;调制&#34;&gt;调制&lt;/h2&gt;
&lt;p&gt;调制：将某个信息嵌入到另一个信号的过程，比如模拟信号通过采样、量化、数字化编码到数字信号的过程。&lt;/p&gt;
&lt;p&gt;之所以要调制，是为了提高频率，从而让让信号客户要传播的更远，大气层对低频段的损耗非常高。&lt;/p&gt;
&lt;p&gt;信源的信号有很多低频或者直流成分，很多信道不能直接传输。一方面需要调制成高频信号便于天线发射，一方面可以通过多路传输不同的基带信号，如果频率一样可能会干扰（广播的频率不一样就可以同时发射互不干扰）。&lt;/p&gt;
&lt;p&gt;载波调制就是利用载波进行调制，把基带信号的频率搬移到较高的频段。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://img-blog.csdnimg.cn/img_convert/ba2f942c2de172e4e5e707738f3d08f4.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;码元调制&#34;&gt;码元调制&lt;/h2&gt;
&lt;p&gt;码间串扰：在接收端收到的信号波形就失去了码元和符号之间的清晰的界限。&lt;/p&gt;
&lt;p&gt;进行码元/符号调制的目的：用一个码元代表多个比特，在码元速率一定的情况下提高数据传输速率&lt;/p&gt;
&lt;h3 id=&#34;nyquist定理&#34;&gt;Nyquist定理&lt;/h3&gt;
&lt;p&gt;在绝对理想的信道中，极限码元传输速率为$2W$ &lt;em&gt;Baud&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;$W$是理想低通信道的带宽，单位为Hz
$V$是每个码元离散电平的数目，$V$个电平就需要$log_2V$个二进制位&lt;/p&gt;
&lt;p&gt;理想状态下的极限数据传输率 = $2Wlog_2V$ （单位 &lt;em&gt;b/s&lt;/em&gt;）&lt;/p&gt;
&lt;p&gt;超过这个界限就会出现严重的码间串扰&lt;/p&gt;
&lt;h3 id=&#34;香农定理&#34;&gt;香农定理&lt;/h3&gt;
&lt;p&gt;信道的极限数据传输速率 = $Wlog_2(1+S/N)$&lt;/p&gt;
&lt;p&gt;$S$是信道传输的平均功率
$N$为信道内部的高斯噪声功率&lt;/p&gt;
&lt;h3 id=&#34;例子&#34;&gt;例子&lt;/h3&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;带宽为6MHz，量化等级为4，无噪声，求最大传输速率&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;解：使用Nyquist定理，$C = 2 * W * log_2V = 2 * 6 * log_24 = 24Mbps$&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;带宽为3MHz，信噪比为20dB，二进制，求最大数据传输速率&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;解：使用香农定理&lt;/p&gt;
&lt;p&gt;先化$S/N$的单位，$10lg(S/N) = 20 \to S/N = 100 $&lt;/p&gt;
&lt;p&gt;$C= W * log_2{(1+S/N)} = 3 * log_2{(1+100)} \approx 20Kbps$&lt;/p&gt;
&lt;h2 id=&#34;无线信道&#34;&gt;无线信道&lt;/h2&gt;
&lt;p&gt;传播的时候会遇到很多复杂的情况，造成信号的衰弱，根据信号传播的距离分为大尺度衰弱和小尺度衰弱。&lt;/p&gt;
&lt;h3 id=&#34;大尺度衰弱&#34;&gt;大尺度衰弱&lt;/h3&gt;
&lt;p&gt;大尺度衰弱是发射和接受信号的距离较长，数百数千米&lt;/p&gt;
&lt;p&gt;大尺度衰弱包括路径损耗和阴影效应：&lt;/p&gt;
&lt;p&gt;路径损耗：随着路径长度的平方衰减，和方向等参数无关&lt;/p&gt;
&lt;p&gt;阴影损耗：遇到障碍物时，后面的阴影区信号场比较弱，会造成损耗&lt;/p&gt;
&lt;h3 id=&#34;小尺度衰弱&#34;&gt;小尺度衰弱&lt;/h3&gt;
&lt;p&gt;小尺度衰弱是数个或者数十个波长的距离&lt;/p&gt;
&lt;p&gt;小尺度衰弱更为重要，其中造成小尺度衰弱的主要原因有多径效应和多普勒效应&lt;/p&gt;
&lt;p&gt;包括频率选择性衰弱和时变特性&lt;/p&gt;
&lt;p&gt;多径效应：由于电波传递的过程中有各种反射散射等，会导致到达时的信号是由多个状态叠加的，随机分布的幅度、相位、入角等合成之后使得接收到的信号删除衰弱和失真，比如极端情况刚好差半个波长然后刚好抵消（实际基本不可能，但是能说明其影响）&lt;/p&gt;
&lt;p&gt;多普勒效应：是由于接收端和发射端之间的相对移动产生的&lt;/p&gt;
&lt;h3 id=&#34;蜂窝网络&#34;&gt;蜂窝网络&lt;/h3&gt;
&lt;p&gt;单基站覆盖：早期的移动通信是利用高塔上的天线大功率发射，但是业务通道很少&lt;/p&gt;
&lt;p&gt;蜂窝通信网络：减少单个基站的发射功率，多小区覆盖，不同小区之间频率复用（频率复用是蜂窝移动通信的基石）&lt;/p&gt;
&lt;p&gt;同频段小区之间可能会干扰，需要增加同频段小区之间的距离&lt;/p&gt;
&lt;p&gt;不同簇之间使用相同频率的小区的最小距离$D$称为频率再用比例（就是两个相同频率的，看最接近的路径是多大）&lt;/p&gt;
&lt;p&gt;小区切换，设定某个切换门限，低于门限值则进行切换，需要设定一个时间，持续低于这段时间再切换，从而避免乒乓球切换。&lt;/p&gt;
&lt;p&gt;同频组网&lt;/p&gt;
&lt;p&gt;单工：指的是只有一个方向的交互而没有反方向的交互
半双工：双方都可以发送信息，但是不能同时发送或者接受&lt;/p&gt;
&lt;p&gt;半双工分为FDD（频分双工）和TDD（时分双工），FDD就是在不同的频率上同时发送，TDD用时间片轮转。&lt;/p&gt;
&lt;p&gt;全双工：双方可以同时发送和接收消息&lt;/p&gt;
&lt;h3 id=&#34;多址接入方式&#34;&gt;多址接入方式&lt;/h3&gt;
&lt;p&gt;复用：同样的频谱如何重复使用
多址：同样的频谱如何分给不同用户&lt;/p&gt;
&lt;p&gt;多址其实就是要去找一种方式来分割为多个正交的数据流，从而将它们分开。&lt;/p&gt;
&lt;p&gt;频分多址（FDMA）：在频域复用多个数据流，用于多个用户
时分多址（TDMA）：在时域复用多个数据流，用于多个用户
&lt;strong&gt;码分多址（CDMA）&lt;/strong&gt;：在码域复用多个数据流，用于多个用户
空分多址（SDMA）：在空间上用于多个用户&lt;/p&gt;
&lt;p&gt;把每个频谱比作一个房间，FDMA就是不同的用户去不同的方向聊天，TDMA就是依次排队去房间聊天，CDMA就是一窝蜂的一起说话，但是说的语言不同，只要认准自己的语言就能分开从而交流。&lt;/p&gt;
&lt;p&gt;码片序列，将一个比特时间划分成m个短的间隔，称为码片。每个站被指派一个唯一的m bit码片序列，1则为自己的码片，0则发送自己的反码。&lt;/p&gt;
&lt;p&gt;每个站分配的码片序列必须各不相同且相互正交&lt;/p&gt;
&lt;p&gt;扩频技术，之前的一个bit变成了m个bit，发送的数据率是之前的m倍，宽度也提高到m倍&lt;/p&gt;
&lt;p&gt;扩频通信采用直接序列扩频或者跳频扩频
直接序列扩频DSSS是通过比特率高很多的伪码序列对信号进行二次调频的技术&lt;/p&gt;
&lt;p&gt;OFDM：正交频分复用，运行载波之间紧密相邻甚至部分重合，可以实现很高的频谱效率。通过IFFT，人为建立载波间正交性&lt;/p&gt;
&lt;p&gt;OFDM发射机的两个核心模块：IFFT和加入循环前缀CP&lt;/p&gt;
&lt;h3 id=&#34;mimo与波束赋型&#34;&gt;MIMO与波束赋型&lt;/h3&gt;
&lt;h2 id=&#34;传输途径的分类&#34;&gt;传输途径的分类&lt;/h2&gt;
&lt;p&gt;基站和终端的传输途径有SISO、MISO、SIMO、MIMO。&lt;/p&gt;
&lt;p&gt;MISO是基站多个天线发出相同信号，在终端合成一路，是发送分集技术。&lt;/p&gt;
&lt;p&gt;SIMO是一个天线通过两路路径发送信号，终端收到两个信号，数据也一样，是接受分集技术。
MIMO（Multiple Input Multiple Output，多进多出）
实现多路数据并行发送，获得空间复用增益。
实现多个字信号的有效合并，获得空间分集增益。&lt;/p&gt;
&lt;h2 id=&#34;分集与复用&#34;&gt;分集与复用&lt;/h2&gt;
&lt;h3 id=&#34;分集&#34;&gt;分集&lt;/h3&gt;
&lt;p&gt;分集就是把多个独立衰弱的副本提供给接收机，接受机将同一数据流的不同版本进行合并和恢复。减少深度衰弱的概率，从而提高性能。（提高鲁棒性）&lt;/p&gt;
&lt;p&gt;分为空间分集（同一个信息从多根天线上发射出去）、时间分集（同一个信号以超过相干时间间隔重复发送）&lt;/p&gt;
&lt;p&gt;频率分集就是在多个频域上对同一信号进行重复发送&lt;/p&gt;
&lt;p&gt;分集又分为简单分集（完全相同）、编码分集（不同的版本）、选择分集（选择一个信道较好的天线发送）、波束分集等&lt;/p&gt;
&lt;p&gt;空间分集的算法：
空时块码（STBC，Alamouti空时分组码），各个发射天线上的码字满足正交性。因为正交，所以接收端只需要简单处理。&lt;/p&gt;
&lt;p&gt;接收机是2路发送信号与噪声的线性叠加&lt;/p&gt;
&lt;h3 id=&#34;复用&#34;&gt;复用&lt;/h3&gt;
&lt;p&gt;空分复用就是在多条独立的路径上传输不同的数据，提高系统容量。（提高吞吐率）
高速流分为几个低速数据流分别进行编码和调制，然后在不同的天线发送，接收机将不同天线上接受到的数据流进行合并&lt;/p&gt;
</content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://yichengme.site/categories/%E7%90%86%E8%AE%BA/" term="理论" label="理论" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://yichengme.site/tags/%E9%80%9A%E4%BF%A1/" term="通信" label="通信" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">凸优化（五）算法</title>
            <link rel="alternate" type="text/html" href="https://yichengme.site/posts/convex-5/" />
            <id>https://yichengme.site/posts/convex-5/</id>
            <updated>2022-02-08T17:27:00&#43;08:00</updated>
            <published>2022-01-11T01:09:12&#43;08:00</published>
            <author>
                    <name>王毅诚</name>
                    <uri>https://yichengme.site/</uri>
                    <email>engine74396@gmail.com</email>
                    </author>
            <rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">包括无约束优化问题、带等式约束和不等式约束的凸优化问题的求解 无约束优化问题 无约束优化问题： $$ \text { minimize } f_0(x) $$ 对于凸问题而言，只有一个条件 $$ \nabla f (x^{\star}) = 0 $$ 强凸性 存在一个……</summary>
            
                <content type="html">&lt;p&gt;包括无约束优化问题、带等式约束和不等式约束的凸优化问题的求解&lt;/p&gt;
&lt;h2 id=&#34;无约束优化问题&#34;&gt;无约束优化问题&lt;/h2&gt;
&lt;p&gt;无约束优化问题：&lt;/p&gt;
&lt;p&gt;$$
\text { minimize } f_0(x)
$$&lt;/p&gt;
&lt;p&gt;对于凸问题而言，只有一个条件&lt;/p&gt;
&lt;p&gt;$$
\nabla f (x^{\star}) = 0
$$&lt;/p&gt;
&lt;h3 id=&#34;强凸性&#34;&gt;强凸性&lt;/h3&gt;
&lt;p&gt;存在一个大于0的$m$，使得&lt;/p&gt;
&lt;p&gt;$$\forall x \in C, \nabla ^2 f(x) \geq mI$$
$$
f(y) = f(x) + \nabla f(x)^T (y-x) + \frac{m}2||x-y||_2^2 \newline
f(x) - p^{\star} \leq \frac{1}{2m} ||\nabla f(x)||_2^2
$$&lt;/p&gt;
&lt;p&gt;强凸性的性质：任何梯度足够小的点都是近似最优解（结束条件）&lt;/p&gt;
&lt;h3 id=&#34;下降法&#34;&gt;下降法&lt;/h3&gt;
&lt;p&gt;通用的求解方法都是迭代的下降方法，所谓下降，也就是每次迭代，后一个值都比前一个值对应的目标函数值要低，所以是下降。对于前一个值$x^{k}$，寻找一个方向$d^k$和步长$\alpha^k$，下一个值就是$x^{k+1} = x^k + \alpha^k d^k $，初始点、搜索方向、迭代步长也称为迭代搜索法的三要素。&lt;/p&gt;
&lt;p&gt;由于无约束条件，初始点满足以下两项即可：
① $x^0 \in dom f$
② 下水平集是一个闭集&lt;/p&gt;
&lt;p&gt;初始点确定之后，还需要选择下降方向、步长、终止条件等&lt;/p&gt;
&lt;h3 id=&#34;线搜索&#34;&gt;线搜索&lt;/h3&gt;
&lt;p&gt;$$
x^{k+1} = x^k + \alpha^k d^k
$$&lt;/p&gt;
&lt;p&gt;$d^{k}$是搜索方向。&lt;/p&gt;
&lt;p&gt;希望能在这个方向上有个最大的下降，也就是找到
$$
\alpha^k = \text{argmin}_{\alpha} f(x^k + \alpha^k d^k)
$$
但是实际上相当于每次下降都引入了一个新的优化问题，虽然效果好但是计算量很大。&lt;/p&gt;
&lt;h3 id=&#34;带backtracing的线搜索&#34;&gt;带Backtracing的线搜索&lt;/h3&gt;
&lt;p&gt;算法：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;令步长$t$为允许的最大步长&lt;/li&gt;
&lt;li&gt;如果$f(x^k + t \Delta x) &amp;gt; f(x^k) + \alpha t \nabla f(x^k) \Delta x$（也就是说步长太大了，导致下降的一段比$\alpha * $斜率的长度还小，那就减少步长，右式后面是负数）&lt;/li&gt;
&lt;li&gt;让$t = \beta t$&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;通常$\alpha $取0.5，$\beta$取一个0-1之间的数&lt;/p&gt;
&lt;p&gt;这样就能找到一个比较合适的步长，而不需要非常高的计算量。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1641534854/convex-12.png&#34; alt=&#34;convex-12&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;梯度下降法最速下降法&#34;&gt;梯度下降法（最速下降法）&lt;/h3&gt;
&lt;p&gt;思想很简单，沿着梯度（梯度方向是函数值增加的方向）的反方向走，就可以使目标函数不断减少。&lt;/p&gt;
&lt;p&gt;就像是下山，每次都沿着下降最快的方向走，最后一定能走到局部最低点（如果是凸函数就是全局最低点）&lt;/p&gt;
&lt;p&gt;至于搜索步长，则选择这个一维方向搜索的最佳步长，因此，最速下降法的两个相邻迭代点的函数梯度相互垂直&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1641534854/convex-13.png&#34; alt=&#34;convex-13&#34;&gt;&lt;/p&gt;
&lt;p&gt;优点是可以沿着最快的方向，缺点是关注不到全局的情况，不关注下一个点的情况。&lt;/p&gt;
&lt;p&gt;梯度下降法步骤：
输入：目标函数，目标函数梯度
输出：极小点&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;初始化$x^0$&lt;/li&gt;
&lt;li&gt;计算搜索方向$d^k = - \nabla f(x^{k})$&lt;/li&gt;
&lt;li&gt;如果小于$\epsilon$就停止迭代，否则就沿着$d^k$进行一维搜索，求最佳步长$\lambda^k$：
$$
f(x^k + \lambda^k d^k) = \min_{\lambda \geq 0} f(x^k + \lambda d^k)
$$&lt;/li&gt;
&lt;li&gt;令$x^{k+1} = x^k + \lambda^k d^k$，转步骤2&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;选择最优步长的计算代价比较高&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;用最速下降法求目标函数$f(x) = x_1^2 + 25x_2^2$在$[2,2]^T$处的最速下降方向和步长
解：取初始点$x^0 = [2,2]^T$
初始点函数值和梯度分别为：
$f(x^0) = 104$
$\nabla f(x^0) = [4, 100]^T$
沿负梯度方向进行一维搜索：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;$$x^1 = x^0 - \alpha^0 \nabla f(x^0) = [2-4\alpha^0, 2-100\alpha^0]^T$$&lt;/p&gt;
&lt;p&gt;$\alpha^0$需要满足极值条件：&lt;/p&gt;
&lt;p&gt;$$
\min_\alpha f(x^1) = \min_\alpha ((2-4\alpha)^2 + 25 (2-100\alpha)^2)
$$&lt;/p&gt;
&lt;p&gt;解得$\alpha_0 = 0.02003$&lt;/p&gt;
&lt;h3 id=&#34;牛顿法&#34;&gt;牛顿法&lt;/h3&gt;
&lt;p&gt;牛顿法（Newton&#39;s Method）是一个非常有效的非线性方差的求根方法，主要用于求方程的根和求解最优化问题。&lt;/p&gt;
&lt;p&gt;利用牛顿法，可以迭代求解非常复杂的方程的根：
$$
f(x) = f(x_0) + f&#39;(x_0)(x-x_0) + O((x-x_0)^2)\newline
$$
忽略截断误差后令$f(x)=0$可解得：
$$
x_1 = x_0 - \frac{f(x_0)}{f&#39;(x_0)}
$$
$x_1$一定比$x_0$更接近真实根，从而不断迭代&lt;/p&gt;
&lt;p&gt;对于最优化问题的求解&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;牛顿法的推导&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;当前点$v$，下降向量$v$，下降后的值为：&lt;/p&gt;
&lt;p&gt;$$
f(x+v) \approx f(x)+\nabla f(x)^{T} v+\frac{1}2 v^{T} \nabla^2 f(x) v
$$&lt;/p&gt;
&lt;p&gt;要使该值最小，且$x$已经固定，关于$v$求偏导：&lt;/p&gt;
&lt;p&gt;$$
\nabla f(x)+\nabla^2 f(x) v=0
$$&lt;/p&gt;
&lt;p&gt;得到：&lt;/p&gt;
&lt;p&gt;$$
\Delta x_{nt} = v=-\nabla^2 f(x)^{-1} \nabla f(x)
$$&lt;/p&gt;
&lt;p&gt;从而推出&lt;strong&gt;牛顿法的迭代公式：&lt;/strong&gt;
$$
x^{k+1} = x^k + \Delta x_{nt} = x^k -\nabla^2 f(x)^{-1} \nabla f(x)
$$&lt;/p&gt;
&lt;p&gt;$\nabla^2 f(x)$是$f(x)$的Hessian矩阵&lt;/p&gt;
&lt;p&gt;一维时有：
$$
x^{k+1} = x^k - \frac{f&#39;(x^k)}{f&#39;&#39;(x^k)}
$$&lt;/p&gt;
&lt;p&gt;多元函数保留到二次项得到：
$$
f(x) = f(x^k) + \nabla f(x^k)^T(x-x^k) + \frac{1}2 (x-x^k)^T \nabla^2 f(x^k)(x-x^k)
$$
其中$\nabla^2 f(x^k)$是点$x^k$处的海森矩阵
通过求导得到平稳点，解得
$$
x^{k+1} = x^k - [\nabla^2 f(x^k)]^{-1}\nabla f(x^k)
$$&lt;/p&gt;
&lt;p&gt;求解无约束优化问题&lt;/p&gt;
&lt;p&gt;牛顿法用二阶海森矩阵的逆矩阵求解，收敛更快但是每次迭代的计算时间更长&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;求目标函数$f(x) = x_1^2 + 25x_2^2$在$[2,2]^T$处的牛顿方向&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;解：初始点梯度$\nabla f(x_0) = [2x_1\ 50x_2]^T = [4\ 100]^T$
$$
\nabla^2 f(x^0)=\left[\begin{array}{cc}
2 &amp;amp; 0 \newline
0 &amp;amp; 50
\end{array}\right]
$$
$$
[\nabla^2 f(x^0)]^{-1}=\left[\begin{array}{cc}
\frac{1}2 &amp;amp; 0 \newline
0 &amp;amp; \frac{1}{50}
\end{array}\right]
$$
牛顿方向为
$$- [\nabla^2 f(x^k)]^{-1}\nabla f(x^k) = -\left[\begin{array}{cc}
\frac{1}2 &amp;amp; 0 \newline
0 &amp;amp; \frac{1}{50}
\end{array}\right] \left[\begin{array}{cc}
4 \newline
100
\end{array}\right] = \left[\begin{array}{cc}
-2 \newline
-2
\end{array}\right]$$&lt;/p&gt;
&lt;h3 id=&#34;阻尼牛顿法&#34;&gt;阻尼牛顿法&lt;/h3&gt;
&lt;p&gt;增加了沿牛顿方向的一维搜索，步长$\lambda_k$由一维搜索得到，每次迭代必然下降，不过会增大计算量&lt;/p&gt;
&lt;h3 id=&#34;共轭梯度法&#34;&gt;共轭梯度法&lt;/h3&gt;
&lt;p&gt;$A$是对称正定矩阵，如果有两个方向$d^i, d^j$满足$(d^{i})^T A d^j$，则称这组方向是$A$共轭的
（如果$A$是单位阵，则称两个方向正交）&lt;/p&gt;
&lt;p&gt;依次沿着$d^i$和$d^j$进行一维搜索，经过两次迭代必定到达极小点&lt;/p&gt;
&lt;h3 id=&#34;拟牛顿法&#34;&gt;拟牛顿法&lt;/h3&gt;
&lt;p&gt;计算海森矩阵的逆比较复杂，通过一个$n$阶矩阵来近似代替，就是拟牛顿法的思想。&lt;/p&gt;
&lt;p&gt;$p^k \approx \nabla^2 f(x^{k+1})^{-1}q^k$&lt;/p&gt;
&lt;h2 id=&#34;带等式约束的凸优化问题&#34;&gt;带等式约束的凸优化问题&lt;/h2&gt;
&lt;p&gt;对于带等式约束的凸优化问题：
$$
\begin{array}{ll}
\text{ minimize } &amp;amp; f_0(x) \newline
\text { subject to } &amp;amp; Ax = b
\end{array}
$$&lt;/p&gt;
&lt;p&gt;带等式约束的凸优化问题通常可以采用下面三种方法进行求解：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;消除等式约束&lt;/li&gt;
&lt;li&gt;利用无约束优化方法求解对偶问题&lt;/li&gt;
&lt;li&gt;拓展的Newton法&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;消除等式约束&#34;&gt;消除等式约束&lt;/h3&gt;
&lt;p&gt;等式约束为$Ax = b$&lt;/p&gt;
&lt;p&gt;满足此约束的$x$可以写为$Fy + \hat{x}$的形式，最后变成了：
$$
\text{ minimize } f_0(Fy + \hat{x})
$$&lt;/p&gt;
&lt;p&gt;的无约束优化问题，解得最优解$y^{\star}$之后，就可以通过$x^{\star} = Fy^{\star} + \hat{x}$计算出$x^{\star}$&lt;/p&gt;
&lt;p&gt;比如：
$$
\begin{array}{ll}
\text{ minimize } &amp;amp; f_{1}\left(x_{1}\right)+f_2\left(x_2\right)+\cdots+f_{n}\left(x_{n}\right) \newline
\text { subject to } &amp;amp; x_{1}+x_2+\cdots+x_{n}=b
\end{array}
$$&lt;/p&gt;
&lt;p&gt;可以通过 $x_n = b - x_1 - ... - x_{n-1}$
令$\hat{x} = b e_n$, $F = \left[\begin{array}{c}
I \newline
-\mathbf{1}^{T}
\end{array}\right] \in \mathbf{R}^{n \times(n-1)}$&lt;/p&gt;
&lt;p&gt;问题变为：&lt;/p&gt;
&lt;p&gt;$$
\text{minimize}\  f_{1}\left(x_{1}\right)+\cdots+f_{n-1}\left(x_{n-1}\right)+f_{n}\left(b-x_{1}-\cdots-x_{n-1}\right)
$$&lt;/p&gt;
&lt;h3 id=&#34;通过对偶的方式转换为无约束问题&#34;&gt;通过对偶的方式转换为无约束问题&lt;/h3&gt;
&lt;p&gt;也就是前面对偶的解法&lt;/p&gt;
&lt;p&gt;$$g(v) = -b^T + \inf_x (f(x) + v^T Ax) = -b^Tv - f^{\star} (-A^T v)$$&lt;/p&gt;
&lt;p&gt;其中$f^{\star}$是$f$的共轭，通过解对偶问题：&lt;/p&gt;
&lt;p&gt;$$
\text{maximize}\ -b^T v - f^{\star} (-A^T v)
$$&lt;/p&gt;
&lt;p&gt;就可以使用无约束的优化方法来求解&lt;/p&gt;
&lt;p&gt;通过KKT条件可以知道，最优解$x^{\star}$满足：
$$
Ax^{\star} = b \newline
\nabla f(x^{\star}) + A^T v^{\star} = 0
$$&lt;/p&gt;
&lt;h3 id=&#34;拓展newton法&#34;&gt;拓展Newton法&lt;/h3&gt;
&lt;p&gt;牛顿法除了求解无约束优化问题外，也可以用于求解带等式约束的凸优化问题。&lt;/p&gt;
&lt;p&gt;在此之前先讨论等式约束凸二次规划问题：
$$
\begin{array}{ll}
\text{ minimize } &amp;amp; f(x)=(1 / 2) x^{T} P x+q^{T} x+r \newline
\text { subject to } &amp;amp; A x=b,
\end{array}
$$&lt;/p&gt;
&lt;p&gt;其KKT条件是：
$Ax^{\star} = b, Px^{\star} + q + A^T v^{\star} = 0$&lt;/p&gt;
&lt;p&gt;可以写成矩阵形式：
$$
\left[\begin{array}{cc}
P &amp;amp; A^{T} \newline
A &amp;amp; 0
\end{array}\right]\left[\begin{array}{l}
x^{\star} \newline
\nu^{\star}
\end{array}\right]=\left[\begin{array}{c}
-q \newline
b
\end{array}\right]
$$&lt;/p&gt;
&lt;p&gt;也称为KKT矩阵&lt;/p&gt;
&lt;p&gt;这里有等式约束的拓展牛顿法与无约束的牛顿法不同的是需要保证牛顿方向$\Delta x_{nt}$是可行的，也就是：$A \Delta x_{nt} = 0$&lt;/p&gt;
&lt;p&gt;等式约束问题：
$$
\begin{array}{ll}
\text{ minimize } &amp;amp; f(x) \newline
\text { subject to } &amp;amp; Ax = b
\end{array}
$$&lt;/p&gt;
&lt;p&gt;在可行点$x$处的牛顿方向$\Delta x_{nt}$，目标函数转换为二阶近似：
$$
\begin{array}{ll}
\text{ minimize } &amp;amp; f(x+v) = f(x) + \nabla f(x)^T v + (1/2) v^T \nabla^2 f(x) v\newline
\text { subject to } &amp;amp; A(x+v) = b
\end{array}
$$&lt;/p&gt;
&lt;p&gt;这里的KKT矩阵是：&lt;/p&gt;
&lt;p&gt;$$
\left[\begin{array}{cc}
\nabla^2 f(x) &amp;amp; A^{T} \newline
A &amp;amp; 0
\end{array}\right]\left[\begin{array}{c}
\Delta x_{\mathrm{nt}} \newline
w
\end{array}\right]=\left[\begin{array}{c}
-\nabla f(x) \newline
0
\end{array}\right]
$$&lt;/p&gt;
&lt;p&gt;等式约束的牛顿减量定义为：
$$
\lambda(x)=\left(\Delta x_{\mathrm{nt}}^{T} \nabla^2 f(x) \Delta x_{\mathrm{nt}}\right)^{1 / 2}
$$&lt;/p&gt;
&lt;p&gt;等式约束优化问题的牛顿法：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;计算牛顿方向$\Delta x_{nt}$和牛顿减量$\lambda(x)$&lt;/li&gt;
&lt;li&gt;如果$\frac{\lambda^2}2 \leq \epsilon$就退出&lt;/li&gt;
&lt;li&gt;直线搜索确定步长&lt;/li&gt;
&lt;li&gt;$x = x+t \Delta x_{nt}$&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;带不等式约束的凸优化问题&#34;&gt;带不等式约束的凸优化问题&lt;/h2&gt;
&lt;p&gt;带不等式约束的凸优化问题，通过障碍法将不等式约束加入目标函数，从而把问题转换为带等式约束的优化问题，从而可以使用上一节的方法进行求解。&lt;/p&gt;
&lt;p&gt;对于凸优化问题：
$$
\begin{array}{ll}
\text{ minimize } &amp;amp; f_0(x) \newline
\text { subject to } &amp;amp; f_{i}(x) \leq 0, \quad i=1, \ldots, m \newline
&amp;amp; Ax = b
\end{array}
$$&lt;/p&gt;
&lt;p&gt;对数障碍法：&lt;/p&gt;
&lt;p&gt;将其转换为等式约束问题：
$$
\begin{array}{ll}
\text{ minimize } &amp;amp; f_0(x) + \sum_{i=0}^m I_-(f_i(x)) \newline
\text { subject to } &amp;amp; Ax = b
\end{array}
$$&lt;/p&gt;
&lt;p&gt;其中
$$I_- (x) = \left \{  \begin{array}{ll} 0 &amp;amp; \text{if } x \leq 0 \newline \infty &amp;amp; \text{otherwise} \end{array}   \right . $$&lt;/p&gt;
&lt;p&gt;也就是说不满足不等式约束的话，就让目标函数无限大，否则就没影响。
但是这个函数不可导，所以采用一个对数函数来近似：&lt;/p&gt;
&lt;p&gt;$$I_- (x) = -\frac{1}{t} log(-x)$$&lt;/p&gt;
&lt;p&gt;定义$\phi(x) =  - \sum_{i=1}^m \log(-f_i(x))$为对数障碍函数，其梯度为：
$$
\nabla \phi(x) = \sum_{i=1}^m \frac{1}{-f_i(x)} \nabla f_i(x)
$$
其Hessian矩阵为：
$$
\nabla^2 \phi(x)=\sum_{i=1}^{m} \frac{1}{-f_{i}(x)} \nabla^2 f_{i}(x)+\sum_{i=1}^{m} \frac{1}{f_{i}(x)^2} \nabla f_{i}(x) \nabla f_{i}(x)^{T}
$$&lt;/p&gt;
&lt;h2 id=&#34;例题&#34;&gt;例题&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;给定函数$f(x)=(6+x_1+x_2)^2+(2-3x_1-3x_2-x_1x_2)^2$，求在点$(\hat{X}=(-4,6)^T)$处的牛顿方向$d$&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;$$
\nabla^T f(x) = \left [ \begin{array}{cc} 2(6 + x_1 + x_2) + 2(2-3x_1 - 3x_2 - x_1 x_2 )(-3-x_2) \newline 2(6 + x_1 + x_2) + 2(2-3x_1 - 3x_2 - x_1 x_2 )(-3-x_2) \end{array} \right ] = \left [ \begin{array}{cc} -344 \newline 56 \end{array} \right ]
$$&lt;/p&gt;
&lt;p&gt;$$
\nabla^2 f(x) = \left [ \begin{array}{cc} 2 + 2(3+x_2)^2 &amp;amp; 2 + 2(3+x_1)(3+x_2) -2 (2-3x_1 - 3x_2 -x_1 x_2)\newline 2 + 2(3+x_2)(3+x_1) -2 (2-3x_1 - 3x_2 -x_1 x_2) &amp;amp; 2 + 2(3+x_1)^2 \end{array} \right ] = \left [ \begin{array}{cc} 164 &amp;amp; -56 \newline -56 &amp;amp; 4 \end{array} \right ]
$$&lt;/p&gt;
&lt;p&gt;$$
[\nabla^2 f(x)]^{-1} = -\frac{1}{2480} \left [ \begin{array}{cc} 4 &amp;amp; 56 \newline 56 &amp;amp; 164 \end{array} \right ]
$$&lt;/p&gt;
&lt;p&gt;$$
\begin{array}{ll}
\triangle x_{nt} &amp;amp;= -(\nabla^2 f(x))^{-1} \nabla f^T(x)\newline
&amp;amp;=\frac{1}{2480} \left [ \begin{array}{cc} 4 &amp;amp; 56 \newline 56 &amp;amp; 164 \end{array} \right ] \left [ \begin{array}{cc} -344 \newline 56 \end{array} \right ] = \left [ \begin{array}{cc} -0.709677 \newline 4.064516 \end{array} \right ]
\end{array}
$$&lt;/p&gt;
&lt;p&gt;牛顿方向为$d = \left [ \begin{array}{cc} -0.709677 \newline 4.064516 \end{array} \right ]$&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;利用牛顿法求解$\min f(x) = (x_1 - 4)^2 + x_2^4$并给出迭代过程，初始点为$[0\ 1]^T$&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;第一次迭代：
$$
\nabla^T f(x^0) = \left [ \begin{array}{cc} 2(x_1 -4)\newline 4x_2^3 \end{array} \right ] = \left [ \begin{array}{cc} -8 \newline 4 \end{array} \right ]
$$&lt;/p&gt;
&lt;p&gt;$$
\nabla^2 f(x^0) = \left [ \begin{array}{cc} 2 &amp;amp; 0\newline 0 &amp;amp; 12x_2^2 \end{array} \right ] = \left [ \begin{array}{cc} 2 &amp;amp; 0\newline 0 &amp;amp; 12 \end{array} \right ]
$$&lt;/p&gt;
&lt;p&gt;$$
[\nabla^2 f(x^0)]^{-1} = \left [ \begin{array}{cc} \frac{1}2 &amp;amp; 0 \newline 0 &amp;amp; \frac{1}{12} \end{array} \right ]
$$&lt;/p&gt;
&lt;p&gt;$$
\begin{array}{ll}
x^1 &amp;amp;= x^0 + \triangle x^0_{nt} = x^0 -(\nabla^2 f(x^0))^{-1} \nabla f^T(x^0)\newline
&amp;amp;=\left [ \begin{array}{cc} 0 \newline 1 \end{array} \right ] - \left [ \begin{array}{cc} \frac{1}2 &amp;amp; 0 \newline 0 &amp;amp; \frac{1}{12} \end{array} \right ]  \left [ \begin{array}{cc} -8 \newline 4 \end{array} \right ] = \left [ \begin{array}{cc} 4 \newline \frac2{3} \end{array} \right ]
\end{array}
$$&lt;/p&gt;
&lt;p&gt;第二次迭代：&lt;/p&gt;
&lt;p&gt;$$
\nabla^T f(x^1) = \left [ \begin{array}{cc} 2(x_1 -4)\newline 4x_2^3 \end{array} \right ] = \left [ \begin{array}{cc} 0 \newline \frac{32}{27} \end{array} \right ]
$$&lt;/p&gt;
&lt;p&gt;$$
\nabla^2 f(x^1) = \left [ \begin{array}{cc} 2 &amp;amp; 0\newline 0 &amp;amp; 12x_2^2 \end{array} \right ] = \left [ \begin{array}{cc} 2 &amp;amp; 0\newline 0 &amp;amp; \frac{16}{3} \end{array} \right ]
$$&lt;/p&gt;
&lt;p&gt;$$
[\nabla^2 f(x^1)]^{-1} = \left [ \begin{array}{cc} \frac{1}2 &amp;amp; 0 \newline 0 &amp;amp; \frac{3}{16} \end{array} \right ]
$$&lt;/p&gt;
&lt;p&gt;$$
\begin{array}{ll}
x^2 &amp;amp;= x^1 + \triangle x^1_{nt} = x^1 -(\nabla^2 f(x^1))^{-1} \nabla f^T(x^1)\newline
&amp;amp;=\left [ \begin{array}{cc} 4 \newline \frac2{3} \end{array} \right ] - \left [ \begin{array}{cc} \frac{1}2 &amp;amp; 0 \newline 0 &amp;amp; \frac{3}{16} \end{array} \right ]  \left [ \begin{array}{cc} 0 \newline \frac{32}{27} \end{array} \right ] = \left [ \begin{array}{cc} 4 \newline \frac{4}{9} \end{array} \right ]
\end{array}
$$&lt;/p&gt;
&lt;p&gt;第三次迭代：
同理
$$
\begin{array}{ll}
x^3 &amp;amp;= x^2 + \triangle x^2_{nt} = x^2 -(\nabla^2 f(x^2))^{-1} \nabla f^T(x^2)\newline
&amp;amp;=\left [ \begin{array}{cc} 4 \newline \frac{4}{9} \end{array} \right ] - \left [ \begin{array}{cc} \frac{1}2 &amp;amp; 0 \newline 0 &amp;amp; \frac{27}{64} \end{array} \right ]  \left [ \begin{array}{cc} 0 \newline \frac{256}{729} \end{array} \right ] = \left [ \begin{array}{cc} 4 \newline \frac{8}{27} \end{array} \right ]
\end{array}
$$&lt;/p&gt;
&lt;p&gt;之后同理&lt;/p&gt;
</content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://yichengme.site/categories/%E7%90%86%E8%AE%BA/" term="理论" label="理论" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://yichengme.site/tags/%E5%87%B8%E4%BC%98%E5%8C%96/" term="凸优化" label="凸优化" />
                            
                        
                            
                            
                            
                                <category scheme="https://yichengme.site/tags/%E6%95%B0%E5%AD%A6/" term="数学" label="数学" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">凸优化（四）对偶</title>
            <link rel="alternate" type="text/html" href="https://yichengme.site/posts/convex-4/" />
            <id>https://yichengme.site/posts/convex-4/</id>
            <updated>2022-02-08T17:27:00&#43;08:00</updated>
            <published>2022-01-09T21:25:05&#43;08:00</published>
            <author>
                    <name>王毅诚</name>
                    <uri>https://yichengme.site/</uri>
                    <email>engine74396@gmail.com</email>
                    </author>
            <rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">Lagrange函数 原优化问题： $$ \begin{array}{ll} \text{ minimize } &amp;amp; f_0(x) \newline \text { subject to } &amp;amp; f_{i}(x) \leq 0, \quad i=1, \ldots, m \newline &amp;amp; h_i(x) = 0, \quad i=1, \ldots, p \end{array} $$ Lagrange函数是在优化目标中考虑约束条件，添加约束条件的加……</summary>
            
                <content type="html">&lt;h2 id=&#34;lagrange函数&#34;&gt;Lagrange函数&lt;/h2&gt;
&lt;p&gt;原优化问题：&lt;/p&gt;
&lt;p&gt;$$
\begin{array}{ll}
\text{ minimize } &amp;amp; f_0(x) \newline
\text { subject to } &amp;amp; f_{i}(x) \leq 0, \quad i=1, \ldots, m \newline
&amp;amp; h_i(x) = 0, \quad i=1, \ldots, p
\end{array}
$$&lt;/p&gt;
&lt;p&gt;Lagrange函数是在优化目标中考虑约束条件，添加约束条件的加权和：&lt;/p&gt;
&lt;p&gt;$$L(x, \lambda, v) = f_0(x) + \sum^m_{i=1}\lambda_if_i(x) + \sum^p_{i=1}v_i h_i(x)$$&lt;/p&gt;
&lt;p&gt;其中包含三个自变量，$x$是原来优化问题的自变量，$\lambda$对应不等式约束，向量维度和不等式约束个数相同，$v$对应等式约束，向量维度和等式约束个数相同&lt;/p&gt;
&lt;p&gt;如果$x$确定了，对于$\lambda$和$v$相当于线性函数&lt;/p&gt;
&lt;h2 id=&#34;拉格朗日对偶函数&#34;&gt;拉格朗日对偶函数&lt;/h2&gt;
&lt;p&gt;拉格朗日对偶函数的形式为：&lt;/p&gt;
&lt;p&gt;$$g(\lambda, v) = \inf_{x \in \mathcal{D}} L(x, \lambda, v) = \inf_{x \in \mathcal{D}}(f_0(x) + \sum^m_{i=1}\lambda_if_i(x) + \sum^p_{i=1}v_i h_i(x))$$&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. 不管原问题是什么问题，对偶函数一定是凹函数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;因为是取inf的分段线性函数&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2. 对偶函数构成了原优化问题的下界，也就是$g(\lambda, v) \leq p^\star $&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;$p^\star $是原优化问题的最优值&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;证明：
假设最优解为$x^\star $，对应的最优值是$f_0(x^\star ) = p^\star $，最优解必然满足约束：
$$
f_i(x) \leq 0, g_i(x) = 0 \to
\sum^m_{i=1}\lambda_if_i(x) + \sum^p_{i=1}v_i h_i(x) \leq 0
$$
将最优解$x^\star $代入拉格朗日函数：
$$
\begin{array}{ll}
L(x^\star , \lambda, v) &amp;amp;=  f_0(x^\star ) + \sum^m_{i=1}\lambda_if_i(x^\star ) + \sum^p_{i=1}v_i h_i(x^\star ) \newline &amp;amp;\leq p^\star  g(\lambda, v) \leq L(x^\star , \lambda, v) \leq p^\star
\end{array}
$$&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;为了获得最大的下界，可以对$g$求极大，极大化凹函数也是一个凸问题。也就是将原问题转变为求解它的对偶函数：&lt;/p&gt;
&lt;p&gt;$$
\begin{array}{ll}
\text{ maximize } &amp;amp; g(\lambda, v) \newline
\text { subject to } &amp;amp; \lambda \geq 0
\end{array}
$$&lt;/p&gt;
&lt;p&gt;拉格朗日对偶问题的最优解$d^\star $，对应的解称为最优拉格朗日乘子$\lambda^\star , v^\star $
原问题的最优解$p^\star $，有以下式子成立：&lt;/p&gt;
&lt;p&gt;$$
\begin{array}{ll}
d^\star  \leq p^\star
\end{array}
$$&lt;/p&gt;
&lt;h3 id=&#34;例&#34;&gt;例&lt;/h3&gt;
&lt;p&gt;$$
\begin{array}{ll}
\text { minimize } &amp;amp; x^T x \newline
\text { subject to } &amp;amp; Ax = b
\end{array}
$$&lt;/p&gt;
&lt;p&gt;其拉格朗日函数为：（这里没有不等式约束，所以没有$\lambda$只有$v$）
$$
L(x, v) = x^T x + v^T(Ax - b )
$$&lt;/p&gt;
&lt;p&gt;拉格朗日对偶函数为
$$
g(v) = \inf_{x \in \mathcal{D}} L(x, v) = \inf_{x \in \mathcal{D}} x^T x + v^T Ax - v^T b
$$&lt;/p&gt;
&lt;p&gt;求极小值有：&lt;/p&gt;
&lt;p&gt;$$\frac{\partial L(x, v)}{\partial x} = 2x + A^T v = 0 \to x = - \frac{A^T v}2$$&lt;/p&gt;
&lt;p&gt;代入$x$有&lt;/p&gt;
&lt;p&gt;$$
\frac{v^T AA^Tv}{4} - \frac{v^T AA^Tv}2 - v^Tb = -\frac{v^T AA^Tv}{4} - bv^T
$$&lt;/p&gt;
&lt;p&gt;变成了一个关于$v$的凹二次函数&lt;/p&gt;
&lt;h3 id=&#34;例-1&#34;&gt;例&lt;/h3&gt;
&lt;p&gt;$$
\begin{array}{ll}
\text { minimize } &amp;amp; c^T x \newline
\text { subject to } &amp;amp; Ax = b \newline
&amp;amp; x \geq 0
\end{array}
$$&lt;/p&gt;
&lt;p&gt;先转换为标准形式：
$$
\begin{array}{ll}
\text { minimize } &amp;amp; c^T x \newline
\text { subject to } &amp;amp; Ax - b = 0 \newline
&amp;amp;  -x \leq 0
\end{array}
$$&lt;/p&gt;
&lt;p&gt;拉格朗日函数为：
$$
L(x, \lambda, v) = c^T x - \lambda^T x + v^T(Ax-b) = -b^Tv + (c + A^T v - \lambda)x
$$&lt;/p&gt;
&lt;p&gt;是$x$的线性函数，如果$x$系数是0，那么极小值就是$-b^Tv$，如果不是0，那么就是$-\infty$&lt;/p&gt;
&lt;p&gt;拉格朗日对偶函数为：
$$
g(\lambda, v) = \inf_x L(x, \lambda, v) = \begin{cases}
-b^T v , &amp;amp; \text{if } A^Tv + c - \lambda = 0\newline
-\infty, &amp;amp; \text{otherwise } \end{cases} $$&lt;/p&gt;
&lt;p&gt;上面是仿射函数，加上其他情况的负无穷拓展是凹函数&lt;/p&gt;
&lt;p&gt;要求它的极大值，负无穷的情况可以直接不考虑，也就是原问题转换为：
$$
\begin{array}{ll}
\text { max } &amp;amp; -b^T v \newline
\text { subject to } &amp;amp; \lambda \geq 0 \newline
&amp;amp; A^Tv + c - \lambda = 0
\end{array}
$$&lt;/p&gt;
&lt;p&gt;即：
$$
\begin{array}{ll}
\text { max } &amp;amp; -b^T v \newline
\text { subject to } &amp;amp; A^Tv + c \geq 0
\end{array}
$$&lt;/p&gt;
&lt;p&gt;和原问题的最优解相同，最优值不同&lt;/p&gt;
&lt;h3 id=&#34;例-2&#34;&gt;例&lt;/h3&gt;
&lt;p&gt;$$
\begin{array}{ll}
\text { minimize } &amp;amp; f_0(x) \newline
\text { subject to } &amp;amp; Ax \leq b \newline
&amp;amp; cx = d
\end{array}
$$&lt;/p&gt;
&lt;p&gt;拉格朗日函数为：
$$
L(x, \lambda, v) = f_0(x) + \lambda^T(Ax-b) + v^T(cx-d)
$$&lt;/p&gt;
&lt;p&gt;对$x$求极小&lt;/p&gt;
&lt;p&gt;$$
g(\lambda, v) = \inf_{x\in dom f} L(x, \lambda, v) = \inf_{x\in dom f} f_0(x) + \lambda^T(Ax-b) + v^T(cx-d)
$$&lt;/p&gt;
&lt;p&gt;之后可以使用共轭函数（略）&lt;/p&gt;
&lt;h2 id=&#34;强对偶与弱对偶&#34;&gt;强对偶与弱对偶&lt;/h2&gt;
&lt;p&gt;之前说，对偶问题的最优解$d^\star $必然小于等于原问题的最优解$p^\star $&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;弱对偶&lt;/strong&gt;：满足$p^\star  \geq d^\star $，原问题不管是否为凸，该式总成立
&lt;strong&gt;强对偶&lt;/strong&gt;：满足$p^\star  = d^\star $，需要满足一些条件才能达到强对偶&lt;/p&gt;
&lt;p&gt;在凸优化问题中，能够保证强对偶成立的条件被称为constraint qualiﬁcations&lt;/p&gt;
&lt;p&gt;其中一种就是Slater条件&lt;/p&gt;
&lt;h2 id=&#34;slater条件&#34;&gt;Slater条件&lt;/h2&gt;
&lt;p&gt;有时简称为SCQ，该条件表述为：&lt;/p&gt;
&lt;p&gt;对于凸优化问题：
$$
\begin{array}{ll}
\text{ minimize } &amp;amp; f_0(x) \newline
\text { subject to } &amp;amp; f_{i}(x) \leq 0, \quad i=1, \ldots, m \newline
&amp;amp; Ax = b
\end{array}
$$&lt;/p&gt;
&lt;p&gt;如何存在可行解$x \in int \mathcal{D}$，使得：
$$
Ax = b, f_i(x) &amp;lt; 0, i = 1, ...m
$$
那么就能保证强对偶性&lt;/p&gt;
&lt;h2 id=&#34;kkt条件&#34;&gt;KKT条件&lt;/h2&gt;
&lt;p&gt;KKT条件给出了最优解需要满足的必要条件，是求解优化问题最优解的一个重要方式。&lt;/p&gt;
&lt;p&gt;对偶问题是：
$$
d^\star  = \sup_{\lambda, v} \inf_{x} L(x,\lambda, v)
$$&lt;/p&gt;
&lt;p&gt;原问题是：
$$
p^\star  = \inf_x \sup_{\lambda, v} L(x, \lambda, v)
$$&lt;/p&gt;
&lt;p&gt;弱对偶性实际上就是max-min不等式：
$$
\sup_{\lambda, v} \inf_{x} L(x,\lambda, v) \leq \inf_x \sup_{\lambda, v} L(x, \lambda, v)
$$&lt;/p&gt;
&lt;p&gt;强对偶性就是：
$$
\sup_{\lambda, v} \inf_{x} L(x,\lambda, v) = \inf_x \sup_{\lambda, v} L(x, \lambda, v) = L(x^\star , \lambda^\star , v^\star )
$$&lt;/p&gt;
&lt;p&gt;$x^\star , \lambda^\star , v^\star $也就是拉格朗日函数的鞍点，强对偶性下，$f_0(x^\star ) = g(\lambda^\star , v^\star )$&lt;/p&gt;
&lt;p&gt;有：&lt;/p&gt;
&lt;p&gt;$$
f_0(x^\star ) = g(\lambda^\star , v^\star ) = \inf_x (f_0(x) + \lambda^{\star T}f(x) + v^{\star T}h(x)) \leq f_0(x) + \lambda^{\star T}f(x) + v^{\star T}h(x) \leq f_0(x^\star )
$$&lt;/p&gt;
&lt;p&gt;也就是要让这两个$\leq$都变成$=$&lt;/p&gt;
&lt;p&gt;第一个不等号取等号的条件是：
$$
\nabla_{x}\left(f_0(x)+\lambda^{\star T} f(x)+\nu^{\star T} h(x)\right)=0
$$&lt;/p&gt;
&lt;p&gt;第二个不等式取等号的条件是：
$$
\lambda_i^{\star T} f_i(x) = 0, \forall i
$$&lt;/p&gt;
&lt;p&gt;上面一个条件共同构成了KKT条件：&lt;/p&gt;
&lt;h3 id=&#34;1-原始约束&#34;&gt;1. 原始约束&lt;/h3&gt;
&lt;p&gt;$f_i(x) \leq 0, i = 0, ..., m$
$h_i(x) = 0, i = 1, ..., p$&lt;/p&gt;
&lt;h3 id=&#34;2-对偶约束&#34;&gt;2. 对偶约束&lt;/h3&gt;
&lt;p&gt;$\lambda \geq 0$&lt;/p&gt;
&lt;h3 id=&#34;3-互补松弛性&#34;&gt;3. 互补松弛性&lt;/h3&gt;
&lt;p&gt;$\lambda_i f_i(x) = 0, i, ..., m$&lt;/p&gt;
&lt;h3 id=&#34;4-极值条件稳定性条件&#34;&gt;4. 极值条件（稳定性条件）&lt;/h3&gt;
&lt;p&gt;$\nabla_{x}\left(f_0(x)+\lambda_i f_i(x)+\nu_i h_i(x)\right)=0$&lt;/p&gt;
&lt;p&gt;对于一般情况而言，KKT条件只是必要条件。
但对于凸优化问题而言，如果有强对偶性，即满足Slater条件，则KKT条件是最优化性的&lt;strong&gt;充要条件&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;例题&#34;&gt;例题&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;注水问题，将值为1的总功率分配给不同的信道，使得总的通信功率最大，即考虑如下优化问题：
$$
\begin{array}{ll}
\text { minimize } &amp;amp; -\sum_{i=1}^{n} \log (x_{i}+\alpha_{i}) \newline
\text { subject to } &amp;amp; x \succcurlyeq 0 \newline
&amp;amp; 1^{T} x=1
\end{array}
$$&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;拉格朗日函数为：
$$
L(x, \lambda, v) = -\sum_{i=1}^{n} \log s(x_{i}+\alpha_{i}) - \lambda^T x + v^T(1^T x - 1)
$$
拉格朗日对偶函数为：
$$
g(\lambda, v) = \inf_{x\in D} L(x, \lambda, v) = \inf_{x\in D} (-\sum_{i=1}^{n} \log s(x_{i}+\alpha_{i}) - \lambda^T x + v^T(1^T x - 1))
$$
KKT条件为：
$$
x \succcurlyeq 0 \newline
1^{T} x=1 \newline
\lambda \succcurlyeq 0 \newline
\lambda_i^T x_i = 0, i = 1, ... ,n \newline
\frac{1}{x_i + \alpha_i} + \lambda_i = v, i = 1, ... ,n \newline
$$
如果$v \geq \frac{1}{\alpha_i}$，那么只有可能$x_i = 0$
如果$v &amp;lt; \frac{1}{\alpha_i}$，那么$\lambda_i = 0$，$x = \frac{1}{v} - \alpha_i$
最后有：
$$
x^{\star}=\left\{\begin{array}{l}
1 / v^{\star}-\alpha_{i} \quad v^{\star}&amp;lt;1 / \alpha_{i} \newline
0 \quad v^{\star} \geq 1 / \alpha_{i}
\end{array}\right.
$$&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;考虑问题：
$$
\begin{array}{ll}
\underset{\boldsymbol{x} \in \mathbb{R}^{n}}{\operatorname{minimize}} &amp;amp; f(\boldsymbol{x})=\boldsymbol{c}^{T} \boldsymbol{x} \newline
\text { subject to } &amp;amp; \boldsymbol{A} \boldsymbol{x} \geq \boldsymbol{b} \newline
&amp;amp; \boldsymbol{x} \geq \mathbf0
\end{array}
$$
分别基于集合约束$x \in X=\left\{\boldsymbol{x} \in \mathbb{R}^{n} \mid \boldsymbol{x} \geq \mathbf0\right\}$和$x \in X=\mathbb{R}^{n}$写出该问题的对偶问题。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;首先看第一个集合约束，此时第二个约束因为已经在集合约束里了，不需要单独考虑了，拉格朗日函数为：
$$
L(x, \lambda) = c^T x + \lambda(b - Ax) = (c^T - \lambda^T A)x + \lambda^T b
$$
对偶函数$$
g(\lambda) = \inf_x L(x, \lambda)
$$&lt;/p&gt;
&lt;p&gt;因为$x \geq 0$，如果$c^T - \lambda^T A &amp;lt; 0$的话，只要取$x = + \infty$，就会使得对偶函数为$- \infty$，因此对偶问题要增加约束$c^T - \lambda^T A \geq 0$，在此约束下，需要取$x=0$使得$g(\lambda)$最小，值为$\lambda^T b$&lt;/p&gt;
&lt;p&gt;对偶问题为：
$$\begin{array}{ll}\underset{\boldsymbol{\lambda} \in \mathbb{R}^m}{\operatorname{maximize}} &amp;amp; \boldsymbol{b}^{T} \boldsymbol{\lambda} \newline \text { subject to } &amp;amp; \boldsymbol{\lambda}^{T} \boldsymbol{A} \leq \boldsymbol{c}^{T} \newline &amp;amp; \boldsymbol{\lambda} \geq \mathbf0\end{array}$$&lt;/p&gt;
&lt;p&gt;第二个集合约束，没有对$x$的限制，拉格朗日函数为：
$$
c^T x + \lambda_1(b-Ax) - \lambda_2 x = (c^T - \lambda_1^T A -\lambda_2)x +\lambda_1^T b
$$
对偶函数$$
g(\lambda_1, \lambda_2) = \inf_x L(x, \lambda_1, \lambda_2)
$$&lt;/p&gt;
&lt;p&gt;如果$c \neq 0$，那么$g(\lambda_1, \lambda_2)$就是$- \infty$，所以对偶问题为：
$$\begin{array}{ll}\underset{\boldsymbol{\lambda_1, \lambda_2} \in \mathbb{R}^m}{\operatorname{maximize}} &amp;amp; \boldsymbol{b}^{T} \boldsymbol{\lambda_1} \newline \text { subject to } &amp;amp; \boldsymbol{c^T} - \boldsymbol{\lambda_1^T A} -\boldsymbol{\lambda_2} = 0\newline &amp;amp; \boldsymbol{\lambda_1, \lambda_2} \geq \mathbf0\end{array}$$&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;一般线性规划的对偶，求解线性规划
$$
\begin{array}{ll}
\operatorname{minimize} &amp;amp; c^{T} x \newline
\text { subject to } &amp;amp; G x \preceq h \newline
&amp;amp; A x=b
\end{array}
$$
的对偶函数，并将隐式等式约束显式表达&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;拉格朗日函数：
$$
L(x, \lambda, v) = c^T x + \lambda^T(Gx - h) + v^T(Ax - b)
$$&lt;/p&gt;
&lt;p&gt;对偶函数：&lt;/p&gt;
&lt;p&gt;$$
g(\lambda, v) = \inf_{x \in D} L(x, \lambda, v) = \inf_{x \in D} (c^T x + \lambda^T(Gx - h) + v^T(Ax - b)) $$&lt;/p&gt;
&lt;p&gt;$$= \left \{ \begin{array}{ll} -\lambda^T h - v^T b &amp;amp; \text{if}\ c+G^T \lambda + A^T v = 0\newline -\infty &amp;amp; \text{otherwise}  \end{array} \right .
$$&lt;/p&gt;
&lt;p&gt;对偶问题变为：&lt;/p&gt;
&lt;p&gt;$$
\begin{array}{ll}
\text { maximize } &amp;amp; g(\lambda, \nu) \newline
\text { subject to } &amp;amp; \lambda \geq 0
\end{array}
$$&lt;/p&gt;
&lt;p&gt;由于不能取负无穷的其他情况，所以增加的约束为：&lt;/p&gt;
&lt;p&gt;$$
\begin{array}{ll}
\text { maximize} &amp;amp; -\lambda^{T} h-\nu^{T} b \newline
\text { subject to } &amp;amp; c+G^{T} \lambda+A^{T} \nu=0 \newline
&amp;amp; \lambda \geq 0
\end{array}
$$&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;解析中心，考虑优化问题：
$$
\text {minimize} -\sum_{i=1}^m \log(b_i - a_i^T x)
$$
其定义域为${ x | a_i^T x &amp;lt; b_i, i = 1, ..., m }$，推导其对偶问题&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;代入$y_i = b_i - a_i^T x$ 得：&lt;/p&gt;
&lt;p&gt;$$
\begin{array}{ll}
\text { maximize} &amp;amp; -\sum_{i=1}^m \log y_i \newline
\text { subject to } &amp;amp; y_i = b_i - a_i^T x , i = 1, ... m\newline
\end{array}
$$&lt;/p&gt;
&lt;p&gt;拉格朗日函数为：&lt;/p&gt;
&lt;p&gt;$$
L(x, y, v) = -\sum_{i=1}^m \log y_i + \sum_{i=1}^n v^T(y_i - b_i + a_i x)
$$&lt;/p&gt;
&lt;p&gt;对偶函数为：
$$
g(v) = \inf_{x, y}(-\sum_{i=1}^m \log y_i + \sum_{i=1}^n v^T(y_i - b_i + a_i x))
$$&lt;/p&gt;
&lt;p&gt;如果$\sum_{i=1}^m v^T a_i \neq 0$，那么$x$可以让$g(v)$取$-\infty$，如果$v \leq 0$，那么$y$可以让$g(v)$取$-\infty$，取最大时$y_i = \frac{1}{v_i}$&lt;/p&gt;
&lt;p&gt;有：&lt;/p&gt;
&lt;p&gt;$$
g(v) = \left \{ \begin{array}{ll} \sum_{i=1}^m (\log v_i) -v^T b + m &amp;amp; \sum_{i=1}^m v^T a_i = 0, v &amp;gt; 0\newline -\infty &amp;amp; \text{otherwise}  \end{array} \right .
$$&lt;/p&gt;
&lt;p&gt;对偶问题为：
$$
\begin{array}{ll}
\text { maximize} &amp;amp; \sum_{i=1}^m (\log v_i) -v^T b + m \newline
\text { subject to } &amp;amp; \sum_{i=1}^m v_i^T a_i = 0 , i = 1, ... m\newline
&amp;amp; v &amp;gt; 0, i = 1, ... m\newline
\end{array}
$$&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;写出下面优化问题的KKT条件，并求出最优解
$$
\begin{array}{ll}
\text { minimize } &amp;amp; -3 x_{1}^2+x_2^2+2 x_{3}^2+2\left(x_{1}+x_2+x_{3}\right) \newline
\text { subject to } &amp;amp; x_{1}^2+x_2^2+x_{3}^2=1
\end{array}
$$&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;KKT条件：&lt;/p&gt;
&lt;p&gt;1、原始约束：$x_{1}^2+x_2^2+x_{3}^2=1$&lt;/p&gt;
&lt;p&gt;2、对偶约束：无&lt;/p&gt;
&lt;p&gt;3、互补松弛性约束：无&lt;/p&gt;
&lt;p&gt;4、稳定性条件：$(-3+v)x_1 + 1 = 0, (1+v)x_2 + 1 = 0, (2+v)x_3 + 1 = 0$&lt;/p&gt;
&lt;p&gt;通过稳定性条件将$x_1, x_2, x_3$全部替换成$v$然后代入原始约束，解出四个解：
$v = -3.15, v = 0.22, v = 1.89, v = 4.04$&lt;/p&gt;
&lt;p&gt;代入，最大的是$(v, x_1, x_2, x_3) = (-3.15, 0.16, 0.47, -0.87)$，$f_0^\star(x^\star) = 1.17$&lt;/p&gt;
</content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://yichengme.site/categories/%E7%90%86%E8%AE%BA/" term="理论" label="理论" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://yichengme.site/tags/%E5%87%B8%E4%BC%98%E5%8C%96/" term="凸优化" label="凸优化" />
                            
                        
                            
                            
                            
                                <category scheme="https://yichengme.site/tags/%E6%95%B0%E5%AD%A6/" term="数学" label="数学" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">凸优化（三）凸优化问题</title>
            <link rel="alternate" type="text/html" href="https://yichengme.site/posts/convex-3/" />
            <id>https://yichengme.site/posts/convex-3/</id>
            <updated>2022-02-08T17:27:00&#43;08:00</updated>
            <published>2022-01-06T21:25:05&#43;08:00</published>
            <author>
                    <name>王毅诚</name>
                    <uri>https://yichengme.site/</uri>
                    <email>engine74396@gmail.com</email>
                    </author>
            <rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">基本形式 一般的优化问题的形式： $$ \begin{array}{ll} \text { minimize } &amp;amp; f_0(x) \newline \text { subject to } &amp;amp; f_{i}(x) \leq 0, \quad i=1, \ldots, m \newline &amp;amp; h_{i}(x)=0, \quad i=1, \ldots, p \end{array} $$ 其中$x$是优化变量，$f_0(x)$是目标函数 ，$f_i(x)\l……</summary>
            
                <content type="html">&lt;h2 id=&#34;基本形式&#34;&gt;基本形式&lt;/h2&gt;
&lt;p&gt;一般的优化问题的形式：
$$
\begin{array}{ll}
\text { minimize } &amp;amp; f_0(x) \newline
\text { subject to } &amp;amp; f_{i}(x) \leq 0, \quad i=1, \ldots, m \newline
&amp;amp; h_{i}(x)=0, \quad i=1, \ldots, p
\end{array}
$$&lt;/p&gt;
&lt;p&gt;其中$x$是优化变量，$f_0(x)$是目标函数 ，$f_i(x)\leq 0$是不等式约束，$h_i(x) = 0$是等式约束。如果$m=p=0$，就是无约束问题。&lt;/p&gt;
&lt;p&gt;定义域为
$$
\mathcal{D}=\bigcap_{i=0}^{m} \operatorname{dom} f_{i} \cap \bigcap_{i=1}^{p} \operatorname{dom} h_{i}
$$&lt;/p&gt;
&lt;p&gt;如果满足目标函数是凸函数，不等式约束也是凸函数，等式约束函数是仿射函数。就是凸优化问题。
$$
\begin{array}{ll}
\text{ minimize } &amp;amp; f_0(x) \newline
\text { subject to } &amp;amp; f_{i}(x) \leq 0, \quad i=1, \ldots, m \newline
&amp;amp; a_{i}^{T} x=b_{i}, \quad i=1, \ldots, p
\end{array}
$$&lt;/p&gt;
&lt;p&gt;定义域为：
$$
\mathcal{D}=\bigcap_{i=0}^{m} \operatorname{dom} f_{i}
$$&lt;/p&gt;
&lt;p&gt;可行解集（feasible set），即在目标函数的定义域中的满足所有约束的解集：
$$
X_f = \{x | x满足所有约束\}
$$&lt;/p&gt;
&lt;p&gt;问题的最优值（optimal value），如果可行解集不是空集，总能在可行解集中找到一个值，使目标函数最小，这个解就是最优解：
$$p^\star  = inf\{f_0(x)|x \in X_f\}$$&lt;/p&gt;
&lt;p&gt;这里inf是下确界的意思，和min类似但是不完全相同。有可能有下确界但是无限趋近取不到，也就是有inf没有min。&lt;/p&gt;
&lt;p&gt;凸优化问题的最重要性质（为什么要研究凸优化，为什么要转换为凸优化问题）：&lt;strong&gt;局部最优 = 全局最优&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;证明凸优化问题的局部最优=全局最优：
$$\newline$$
一句话说明就是反证法假设在局部最优之外还能找到一个全局最优，根据凸函数的性质，就可以在局部最优的领域内找到更低的点，从而与局部最优矛盾，具体过程如下：
$$\newline$$
反证法：假设局部最优解x不是全局最优解y。
$$\newline$$
因为局部最优，所以一定能找到一个正数$R$，使得在$R$的范围内，$f_0(x)$是最小的，即：
$$ \exists R &amp;gt; 0 , f_0(x) = inf { f_0(z), ||x-z||_2\leq R }$$
假设全局最优解是$y$
$$y \neq x, f_0(y) &amp;lt; f_0(x), ||y-x||_2 &amp;gt; R$$
由于是凸函数，在$x、y$中间的一点$ z= (1-\theta) x + \theta y$，有:
$$f_0(z) \leq (1-\theta)f_0(x) + \theta f_0(y)$$
令$\theta = \frac{R}{2||y-x||_2}$
因为可行域是凸集，z一定是可行解。
计算得$||z-x||_2 = \frac{R}2$（实际上前面取$\theta$等于那个的目的就是为了让这里 z在x的邻域内）
因为在邻域内x一定最优，所以$f_0(z) &amp;gt; f_0(x)$。最优点y的$f_0(y) &amp;lt; f_0(x)$
结合前面的式子，有$f_0(z) \leq (1-\theta)f_0(x) + \theta f_0(y) &amp;lt; f_0(z) $，矛盾了，找不到z，也就是说局部最优就是全局最优。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;可微的目标函数的最优解x，当且仅当：
$$\triangledown f_0(x)^T (y-x) \geq 0\ \ \ \text{for all feasible}\ y$$&lt;/p&gt;
&lt;p&gt;用凸函数的一阶等价定义$f(y) \geq f(x) + \triangledown f^T(x) (y-x)$即可直接证明&lt;/p&gt;
&lt;h2 id=&#34;等价问题&#34;&gt;等价问题&lt;/h2&gt;
&lt;h3 id=&#34;box-constraint&#34;&gt;Box constraint&lt;/h3&gt;
&lt;p&gt;例：
$$
\begin{array}{ll}
\text { minimize } &amp;amp; f_0(x) \newline
\text { subject to } &amp;amp; l_i \leq x \leq u_i, i = 1, ... ,n
\end{array}
$$&lt;/p&gt;
&lt;p&gt;改写为标准形式为&lt;/p&gt;
&lt;p&gt;$$
\begin{array}{ll}
\text { minimize } &amp;amp; f_0(x) \newline
\text { subject to } &amp;amp; l_i - x \leq 0, i = 1, ... ,n \newline
&amp;amp; x - u_i \leq 0, i = 1, ... ,n
\end{array}
$$&lt;/p&gt;
&lt;h3 id=&#34;函数等价变换&#34;&gt;函数等价变换&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;$\psi_0$&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;$R \to R$&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;单增&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;$\psi_1, \dots \psi_m$&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;$R \to R$&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;$\psi_{i}(u) \leq 0 \Leftrightarrow u \leq 0$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;$ϱ_1,\dots ϱ_p$&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;$R \to R$&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;$ϱ_{i}(u) = 0 \Leftrightarrow u = 0$&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;变为：
$$
\begin{array}{lll}
\min &amp;amp; \psi_0\left(f_0(x)\right) &amp;amp; \newline
\text { s.t. } &amp;amp; \psi_{i}\left(f_{i}(x)\right) \leq 0 &amp;amp; i=1, \ldots, m \newline
&amp;amp; \varrho_{i}\left(h_{i}(x)\right)=0 &amp;amp; i=1, \ldots, p
\end{array}
$$&lt;/p&gt;
&lt;p&gt;比如
$$
\min |A x-b|_2 \Leftrightarrow|A x-b|_2^2
$$&lt;/p&gt;
&lt;h3 id=&#34;消除或引入等式约束&#34;&gt;消除或引入等式约束&lt;/h3&gt;
&lt;p&gt;比如
$$
\begin{array}{ll}
\text { minimize } &amp;amp; f_0(x) \newline
\text { subject to } &amp;amp; f_i (x) \leq 0, i = 1, ... ,m \newline
&amp;amp; Ax = b
\end{array}
$$&lt;/p&gt;
&lt;p&gt;可以等价于：
$$
\begin{array}{ll}
\text { minimize } &amp;amp; f_0(Fz + x_0) \newline
\text { subject to } &amp;amp; f_i (Fz + x_0) \leq 0, i = 1, ... ,m
\end{array}
$$&lt;/p&gt;
&lt;p&gt;从而消除一个等式约束，也可以从下往上，增加一个等式约束&lt;/p&gt;
&lt;h3 id=&#34;松弛变量&#34;&gt;松弛变量&lt;/h3&gt;
&lt;p&gt;将不等号通过松弛变量变为等号
比如
$$
\begin{array}{ll}
\text { minimize } &amp;amp; f_0(x) \newline
\text { subject to } &amp;amp; a^T_i (x) \leq b, i = 1, ... ,m \newline
\end{array}
$$&lt;/p&gt;
&lt;p&gt;可以等价于：
$$
\begin{array}{ll}
\text { minimize } &amp;amp; f_0(Fz + x_0) \newline
\text { subject to } &amp;amp; a^T_i (x) + s_i = b, i = 1, ... ,m \newline
&amp;amp; s_i \geq 0, i = 1, ... ,m
\end{array}
$$&lt;/p&gt;
&lt;h2 id=&#34;如何把实际问题转换为标准凸优化问题形式&#34;&gt;如何把实际问题转换为标准凸优化问题形式&lt;/h2&gt;
&lt;p&gt;极大化一个凹目标函数，实际上就是凸优化问题&lt;/p&gt;
&lt;h2 id=&#34;典型的凸优化问题&#34;&gt;典型的凸优化问题&lt;/h2&gt;
&lt;h3 id=&#34;线性规划&#34;&gt;线性规划&lt;/h3&gt;
&lt;p&gt;目标函数、等式约束、不等式约束均为线性&lt;/p&gt;
&lt;p&gt;$$
\begin{array}{ll}
\text{ minimize } &amp;amp; c^{T} x+d \newline
\text { subject to } &amp;amp; G x \preceq h \newline
&amp;amp; A x=b
\end{array}
$$&lt;/p&gt;
&lt;p&gt;至少有一个最优解在顶点上&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1641474386/convex-10.png&#34; alt=&#34;convex-10&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;二次规划&#34;&gt;二次规划&lt;/h3&gt;
&lt;p&gt;目标是二次凸函数，约束函数均为线性&lt;/p&gt;
&lt;p&gt;$$
\begin{array}{ll}
\text{ minimize } &amp;amp; (1 / 2) x^{T} P x+q^{T} x+r \newline
\text { subject to } &amp;amp; G x \preceq h \newline
&amp;amp; A x=b
\end{array}
$$&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1641474386/convex-11.png&#34; alt=&#34;convex-11&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;例题&#34;&gt;例题&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;考虑优化问题：
$$
\begin{array}{ll}
\text { minimize} &amp;amp; f_0\left(x_{1}, x_2\right) \newline
\text { subject to } &amp;amp; 2 x_{1}+x_2 \geqslant 1 \newline
&amp;amp; x_{1}+3 x_2 \geqslant 1 \newline
&amp;amp; x_{1} \geqslant 0, \quad x_2 \geqslant 0
\end{array}
$$
对下面每个目标函数给出最优解和最优值&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;（a）
最优解$x^* = (\frac2{5}, \frac{1}{5})$
最优值$f(x^*) = \frac{3}{5}$&lt;/p&gt;
&lt;p&gt;（b）
目标函数没有下界&lt;/p&gt;
&lt;p&gt;（c）
最优解为$x^* = (0, x_2), x_2 \geq 1$
最优值$f(x^*) = 0$&lt;/p&gt;
&lt;p&gt;（d）
最优解$x^* = (\frac{1}{3}, \frac{1}{3})$
最优值$f(x^*) = \frac{1}{3}$&lt;/p&gt;
&lt;p&gt;（e）
最优解$x^* = (\frac{1}2, \frac{1}{6})$
最优值$f(x^*) = \frac{1}2$&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;考虑线性规划
$$
\begin{array}{ll}
\text { minimize } &amp;amp; c^{T} A^{-1} y \newline
\text { subject to } &amp;amp; y \preceq b
\end{array}
$$
A是方阵且不奇异，说明其最优值由：
$$
p^{\star}= \begin{cases}c^{T} A^{-1} b &amp;amp; A^{-T} c \preceq 0 \newline -\infty &amp;amp; \text { 其他情况 }\end{cases}
$$
给出&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;令$Ax = y$，则有$x = A^{-1}y$&lt;/p&gt;
&lt;p&gt;$$
\begin{array}{ll}
\text { minimize } &amp;amp; c^{T} A^{-1} y \newline
\text { subject to } &amp;amp; y \preceq b
\end{array}
$$&lt;/p&gt;
&lt;p&gt;如果$A^{-T} c \preceq 0$，最优解即为$y=b$，否则y取$- \infty$，函数无下界。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;网络流问题，网络总费用为$C = \sum_{1,j=1}^n c_{ij}x_{ij}$，每个边流量$x_{ij}$同时收到下界$l_{ij}$和上界$u_{ij}$的约束，流出和流入的流量守恒。建模成一个线性规划问题&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;目标函数为：
$$
\text{minimize}\ C = \sum_{1,j=1}^n c_{ij}x_{ij}
$$
约束有：
$$
\left \{  \begin{array}{ll}
l_{ij} \leq x_{ij} \leq u_{ij} \newline
b_i + \sum_{j=1}^n x_{ij} - \sum_{j=1}^n x_{ji} = 0
\end{array} \right .
$$&lt;/p&gt;
&lt;p&gt;线性规划即为：
$$
\begin{array}{ll}
\text { minimize } &amp;amp; C = \sum_{1,j=1}^n c_{ij}x_{ij} \newline
\text { subject to } &amp;amp; l_{ij} \leq x_{ij} \leq u_{ij} \newline
&amp;amp; b_i + \sum_{j=1}^n x_{ij} - \sum_{j=1}^n x_{ji} = 0， i = 1, ... n
\end{array}
$$&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Gauss广播信道的最优功率与带宽配置，建模为凸优化问题&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;目标函数为：
$$
\sum_{i=1}^{n} u_{i}\left(R_{i}\right) = \sum_{i=1}^{n} u_{i}(\alpha_{i} W_{i} \log \left(1+\beta_{i} P_{i} / W_{i}\right))
$$&lt;/p&gt;
&lt;p&gt;约束有：
$$
\left \{ \begin{array}{ll}
\sum P_{i=1}^n = P_{tol}\newline
\sum W_{i=1}^n = W_{tol}\newline
\end{array} \right .
$$&lt;/p&gt;
&lt;p&gt;R的Hassain矩阵为$$
\nabla^2 R_{i}=\frac{-\alpha_{i} \beta_{i}^2}{W_{i}\left(1+\beta_{i} P_{i} / W_{i}\right)^2}\left[\begin{array}{c}
1 \newline
-P_{i}
\end{array}\right]\left[\begin{array}{c}
1 \newline
-P_{i}
\end{array}\right]^{T}$$
是负定的，说明$R_i$是凹的。总效用是凹函数的和，也是凹函数。&lt;/p&gt;
</content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://yichengme.site/categories/%E7%90%86%E8%AE%BA/" term="理论" label="理论" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://yichengme.site/tags/%E5%87%B8%E4%BC%98%E5%8C%96/" term="凸优化" label="凸优化" />
                            
                        
                            
                            
                            
                                <category scheme="https://yichengme.site/tags/%E6%95%B0%E5%AD%A6/" term="数学" label="数学" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">凸优化（二）凸函数</title>
            <link rel="alternate" type="text/html" href="https://yichengme.site/posts/convex-2/" />
            <id>https://yichengme.site/posts/convex-2/</id>
            <updated>2022-02-08T17:27:00&#43;08:00</updated>
            <published>2022-01-03T20:22:23&#43;08:00</published>
            <author>
                    <name>王毅诚</name>
                    <uri>https://yichengme.site/</uri>
                    <email>engine74396@gmail.com</email>
                    </author>
            <rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">凸函数的定义 定义一（基本定义） 函数$f: R^n \to R$是凸函数，当且仅当： $f$的定义域是凸集 $\forall x_1, x_2 \in dom(f), \forall \theta \in [0,1]$ $f(\theta x_1+(1-\theta)x_2) \leq \theta f(x_1) + (1-\theta)f(x_2)$ 该式也叫Jenson不等式： $$f(\theta x + (1-\theta) y) \leq……</summary>
            
                <content type="html">&lt;h2 id=&#34;凸函数的定义&#34;&gt;凸函数的定义&lt;/h2&gt;
&lt;h3 id=&#34;定义一基本定义&#34;&gt;定义一（基本定义）&lt;/h3&gt;
&lt;p&gt;函数$f: R^n \to R$是凸函数，当且仅当：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;$f$的定义域是凸集&lt;/li&gt;
&lt;li&gt;$\forall x_1, x_2 \in dom(f), \forall \theta \in [0,1]$
$f(\theta x_1+(1-\theta)x_2) \leq \theta f(x_1) + (1-\theta)f(x_2)$&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;该式也叫Jenson不等式：
$$f(\theta x + (1-\theta) y) \leq \theta f(x) + (1-\theta)f(y)$$&lt;/p&gt;
&lt;p&gt;拓展，对于任意随机变量z，有
$$f(Ez) \leq Ef(z)$$&lt;/p&gt;
&lt;p&gt;通俗来讲，就是函数上任取两点，它们之间的连线都在函数的上面&lt;/p&gt;
&lt;p&gt;如果2的$\leq$换成$&amp;lt;$就是严格凸函数&lt;/p&gt;
&lt;h3 id=&#34;定义二降至一维&#34;&gt;定义二（降至一维）&lt;/h3&gt;
&lt;p&gt;函数$f: R^n \to R$是凸函数，当且仅当：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;$f$的定义域是凸集&lt;/li&gt;
&lt;li&gt;$\forall x \in dom\ f, \forall v, g(t) = f(x+tv)$为凸函数，$dom\ g \in dom\ f$&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;相当于从高维降到一维，可以通过证明一维的函数$g(t)$来反证原函数$f(x)$，当然这个定义用的不多&lt;/p&gt;
&lt;h3 id=&#34;定义三凸函数的一阶条件&#34;&gt;定义三（凸函数的一阶条件）&lt;/h3&gt;
&lt;p&gt;若$f: R^n \to R$一阶可微，则它是凸函数，当且仅当：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;$f$的定义域是凸集&lt;/li&gt;
&lt;li&gt;$\forall x, y \in dom(f), f(y) \geq f(x) + \triangledown f(x)^T (y-x)$&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;通俗来讲，就是任何一点的切线，切线上的任何一点都小于等于函数&lt;/p&gt;
&lt;p&gt;证明定义三：&lt;/p&gt;
&lt;p&gt;充分性：首先因为是凸函数，定义域为凸集。代入$y \to x+$即可
必要性：构造$z = \theta x + (1-\theta)y$，然后代入f(x)和f(y)的一阶不等式到$\theta f(x) + (1-\theta) f(y)$中即可得到结果。&lt;/p&gt;
&lt;h3 id=&#34;定义四凸函数的二阶条件&#34;&gt;定义四（凸函数的二阶条件）&lt;/h3&gt;
&lt;p&gt;实际上用的最多，前提是二阶可微&lt;/p&gt;
&lt;p&gt;若$f: R^n \to R$二阶可微，则它是凸函数，当且仅当：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;$f$的定义域是凸集&lt;/li&gt;
&lt;li&gt;$\forall x \in dom(f), \triangledown f^2(x) \geq 0$，即$f$的Hessian矩阵半正定（特征值均$\geq 0$）&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;如何判断矩阵的正定或负定？
$$\newline$$
方法一、正定矩阵的顺序主子式均为正
$$\newline$$
例：
$$
\begin{array}{ccc}
\end{array}
\left |
\begin{array}{ccc}
6 &amp;amp; -3 &amp;amp; 1 \newline
-3 &amp;amp; 2 &amp;amp; 0 \newline
1 &amp;amp; 0 &amp;amp; 4 \newline
\end{array}
\right |
$$
三个顺序主子式依次为：
$$
\left |
\begin{array}{ccc}
6 \newline
\end{array}
\right | = 6 &amp;gt; 0
$$
$$
\left |
\begin{array}{ccc}
6 &amp;amp; -3 \newline
-3 &amp;amp; 2 \newline
\end{array}
\right | = 3 &amp;gt; 0
$$
$$
\left |
\begin{array}{ccc}
6 &amp;amp; -3 &amp;amp; 1 \newline
-3 &amp;amp; 2 &amp;amp; 0 \newline
1 &amp;amp; 0 &amp;amp; 4 \newline
\end{array}
\right | = 10 &amp;gt; 0
$$
所以为正定矩阵
$$\newline$$
方法二：$x^T H x \geq 0$
（一般用来求二阶的情况，高阶不好求。）
$$\newline$$
例：
$$
H =
\begin{array}{ccc}
\end{array}
\left [
\begin{array}{ccc}
3 &amp;amp; 2 \newline
2 &amp;amp; 1 \newline
\end{array}
\right ]
$$
对于任意$x$，构造
$$
x^T \begin{array}{ccc}
\end{array}
\left [
\begin{array}{ccc}
3 &amp;amp; 1 \newline
1 &amp;amp; 1 \newline
\end{array}
\right ] x = 3x_1^2 + 2x_1 x_2 + x_2^2 = 2x_1^2 + (x_1+x_2)^2 \geq 0
$$
所以是半正定的&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;注意，使用该方法时需要定义域是凸集，且二阶可微&lt;/strong&gt;，比如$f(x)=\frac{1}{x^2}$，即使二阶导数$\geq0$，因为在0不连续，定义域不是凸集，所以不是凸函数。&lt;/p&gt;
&lt;p&gt;第一个要判断的就是定义域是否为凸集。然后看定义域内是否可导，比如某分段函数的某点是尖不可导，当然不能说一定凸/非凸，只是说不能用这个定义判断，要用基本定义来求。&lt;/p&gt;
&lt;p&gt;如果取$&amp;gt;$，那么是严格凸的，但是并不是凸函数都能取$&amp;gt;$，比如$x^4$在0处的二阶导就是0&lt;/p&gt;
&lt;h3 id=&#34;凸函数拓展&#34;&gt;凸函数拓展&lt;/h3&gt;
&lt;p&gt;如果$f(x)$是凸函数，那么凸函数的拓展&lt;/p&gt;
&lt;p&gt;$$
\bar{f}(x)= \begin{cases}f(x) &amp;amp; x \in \operatorname{dom}(f) \newline \infty &amp;amp; x \notin \operatorname{dom}(f)\end{cases}
$$&lt;/p&gt;
&lt;p&gt;也是凸函数，比较直观&lt;/p&gt;
&lt;h2 id=&#34;常见的凸函数&#34;&gt;常见的凸函数&lt;/h2&gt;
&lt;h3 id=&#34;仿射函数&#34;&gt;仿射函数&lt;/h3&gt;
&lt;p&gt;$ f(x) = Ax + b$&lt;/p&gt;
&lt;p&gt;$\nabla^{2} f(x) = 0$
仿射函数既是凸函数，又是凹函数&lt;/p&gt;
&lt;h3 id=&#34;指数函数&#34;&gt;指数函数&lt;/h3&gt;
&lt;p&gt;$f(x) = e^{ax}$&lt;/p&gt;
&lt;p&gt;$\nabla^{2} f(x) = a^2 e^{ax} &amp;gt; 0$&lt;/p&gt;
&lt;h3 id=&#34;幂函数&#34;&gt;幂函数&lt;/h3&gt;
&lt;p&gt;$f(x) = x^a$&lt;/p&gt;
&lt;p&gt;分情况讨论&lt;/p&gt;
&lt;p&gt;$$\nabla^{2} f(x)=a(a-1) x^{a-2}=\left\{\begin{array}{ll}\geq 0 &amp;amp; a \geq 1, a \leq 0 &amp;amp; 凸\newline \leq 0 &amp;amp; a \in[0,1]&amp;amp; 凹\end{array}\right.$$&lt;/p&gt;
&lt;h3 id=&#34;绝对值幂函数&#34;&gt;绝对值幂函数&lt;/h3&gt;
&lt;p&gt;$f(x) = |x|^p$&lt;/p&gt;
&lt;p&gt;$$
f^{\prime \prime}(x)= \begin{cases}p(p-1) x^{p-2} &amp;amp; x \geq 0 \newline -p(p-1)(-x)^{p-2} &amp;amp; x&amp;lt;0\end{cases}
$$&lt;/p&gt;
&lt;p&gt;情况比较复杂，需要对$p$分类讨论。&lt;/p&gt;
&lt;h3 id=&#34;范数&#34;&gt;范数&lt;/h3&gt;
&lt;p&gt;$R^n$空间的范数$P(x)$&lt;/p&gt;
&lt;p&gt;有如下性质：
① $P(ax) = |a|P(x)$
② $P(x+y) \leq P(x) + P(y)$
③ $P(x) = 0 \Leftrightarrow x = 0$&lt;/p&gt;
&lt;p&gt;范数是凸函数，按照定义用性质②即可证明（零范数除外，零范数不满足①）&lt;/p&gt;
&lt;h3 id=&#34;极大值函数&#34;&gt;极大值函数&lt;/h3&gt;
&lt;p&gt;$f(x) = max\{x_1, x_2, ...x_n\}$&lt;/p&gt;
&lt;p&gt;极大值函数是凸函数，所以会有极小极大问题，即极小化一个极大值函数&lt;/p&gt;
&lt;h3 id=&#34;共轭函数&#34;&gt;共轭函数&lt;/h3&gt;
&lt;h2 id=&#34;保凸运算&#34;&gt;保凸运算&lt;/h2&gt;
&lt;h3 id=&#34;非负加权和&#34;&gt;非负加权和&lt;/h3&gt;
&lt;p&gt;$f_1, ..., f_m$为凸，$\omega_i \geq 0$，则$f = \sum_{i=1}^{m} \omega_i f_i$为凸&lt;/p&gt;
&lt;h3 id=&#34;仿射映射&#34;&gt;仿射映射&lt;/h3&gt;
&lt;p&gt;$f: R^n \to R$为凸，则$g(x) = f(Ax+b)$为凸&lt;/p&gt;
&lt;h3 id=&#34;凸函数的逐点最大&#34;&gt;凸函数的逐点最大&lt;/h3&gt;
&lt;p&gt;$f_1, f_2$为凸，则$f = \max{{f_1(x), f_2(x)}}$为凸&lt;/p&gt;
&lt;p&gt;可以用定义一证明，可以推广到无数个&lt;/p&gt;
&lt;p&gt;比如分段线性函数就是凸函数&lt;/p&gt;
&lt;h3 id=&#34;复合函数&#34;&gt;复合函数&lt;/h3&gt;
&lt;p&gt;$f(x) = h(g(x))$&lt;/p&gt;
&lt;p&gt;$
f^{\prime \prime}(x)=h^{\prime \prime}(g(x)) g^{\prime 2}(x)+h^{\prime}(g(x)) g^{\prime \prime}(x)
$&lt;/p&gt;
&lt;p&gt;然后分情况讨论&lt;/p&gt;
&lt;h2 id=&#34;拟凸函数与拟凹函数&#34;&gt;拟凸函数与拟凹函数&lt;/h2&gt;
&lt;p&gt;$\alpha$-下水平集：$$
C_{\alpha}={x \in \operatorname{dom} f \mid f(x) \leq \alpha}
$$&lt;/p&gt;
&lt;p&gt;指的是&lt;strong&gt;定义域&lt;/strong&gt;是凸集！&lt;/p&gt;
&lt;p&gt;如果作一条水平线，交点数&amp;gt;2，必然不是拟凸&lt;/p&gt;
&lt;p&gt;考虑函数的$\alpha-$下水平集，凸函数的所有$\alpha$-下水平集是凸集，但是$\alpha$-下水平集是凸集的函数不一定是凸函数&lt;/p&gt;
&lt;p&gt;拟凸有时候也称为单模态函数，如下图左图为拟凸函数，右图则不是拟凸函数
&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1640604308/convex-7.png&#34; alt=&#34;convex-7&#34;&gt;&lt;/p&gt;
&lt;p&gt;定义函数$f: R^n \to n$是拟凸函数，如果其定义域和所有$\alpha$-下水平集都是凸集：
$$S_\alpha = { x\in dom f | f(x) \leq \alpha }$$&lt;/p&gt;
&lt;p&gt;对于拟凸函数$f$，有：（Jensen不等式）
$$f(\theta x + (1-\theta)y) \leq max{ f(x), f(y)}, 0 \leq \theta \leq 1$$&lt;/p&gt;
&lt;p&gt;凸函数一定是拟凸函数，但是拟凸函数不一定是凸函数。&lt;/p&gt;
&lt;p&gt;拟凹函数同理，即为上水平集均为凸的函数。&lt;/p&gt;
&lt;h2 id=&#34;例题&#34;&gt;例题&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;假设$f :R \to R$是凸函数，$$a,b \in \textbf{dom} f, a &amp;lt; b$$
（a）证明对于任意$x\in [a,b]$，下式成立：
$$
f(x) \leq \frac{b-x}{b-a} f(a)+\frac{x-a}{b-a} f(b)
$$
（b）证明对于任意$x \in (a,b)$，下式成立（并画一个草图说明）：
$$
\frac{f(x)-f(a)}{x-a} \leq \frac{f(b)-f(a)}{b-a}\leq \frac{f(b)-f(x)}{b-x}
$$
（c）假设$f$可微，利用（b）的结论证明：
$$
f&#39;(a) \leq \frac{f(b)-f(a)}{b-a} \leq f&#39;(b)
$$
（d）假设$f$二次可微，利用（c）的结论证明$f&#39;&#39;(a)\geq 0$和$f&#39;&#39;(b)\geq 0$&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;（a）
由凸函数的定义可知，定义域上任意两点$x, y$，对任意$\theta \in [0,1]$有：
$f(\theta x + (1-\theta)y) \leq \theta f(x) + (1-\theta)f(y)$&lt;/p&gt;
&lt;p&gt;$a, b \in dom f, x\in[a,b]$
取$\theta = \frac{b-x}{b-a} \in dom f$
有$f(x) = f(\frac{b-x}{b-a}a + \frac{x-a}{b-a}b) \leq \frac{b-x}{b-a} f(a)+\frac{x-a}{b-a} f(b)$&lt;/p&gt;
&lt;p&gt;（b）
（a）中的式子左右两边都减去$f(a)$，即可得到$\frac{f(x)-f(a)}{x-a} \leq \frac{f(b)-f(a)}{b-a}$，左右两边都减去$f(b)$，即可得到$\frac{f(b)-f(a)}{b-a} \leq \frac{f(b)-f(x)}{b-x}$
草图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1641472076/convex-homework-1.png&#34; alt=&#34;convex-homwork-1&#34;&gt;&lt;/p&gt;
&lt;p&gt;不等式描述了斜率：$\overline{ax} \leq \overline{ab} \leq \overline{xb}$&lt;/p&gt;
&lt;p&gt;（c）
取$x \to a+$，代入（b）的前半部分即有$f&#39;(a) = \lim_{x\to a+} \frac{f(x)-f(a)}{x-a} \leq \frac{f(b)-f(a)}{b-a}$，同理，取$x \to b-$，代入（b）的后半部分即有$\frac{f(b)-f(a)}{b-a} \leq \lim_{x\to b-} = f&#39;(b)$&lt;/p&gt;
&lt;p&gt;（d）&lt;/p&gt;
&lt;p&gt;（c）的结果为：
$f&#39;(a) \leq \frac{f(b)-f(a)}{b-a} \leq f&#39;(b)$&lt;/p&gt;
&lt;p&gt;在此基础上令$b \to a+$
$f&#39;&#39;(a) = \lim_{b\to a+} \frac{f&#39;(b) - f&#39;(a)}{b-a} \geq 0 $&lt;/p&gt;
&lt;p&gt;同理可得$f&#39;&#39;(b) \geq 0$&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;证明连续函数$f: R^n \to R$是凸函数的充要条件是，对于任意线段，函数在线段上的平均值不大于线段端点函数值的平均，也就是对于任意$x, y \in R^n$，下式成立：
$$
\int_{0}^{1} f(x+\lambda(y-x)) d \lambda \leqslant \frac{f(x)+f(y)}{2}
$$&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;先证明必要性，如果连续函数$f$是凸函数，即任取两点$x,y$，任取$\theta \in [0,1]$，必然有：
$$\theta f(x) + (1-\theta) f(y) \geq f(\theta x + (1-\theta) y)$$&lt;/p&gt;
&lt;p&gt;即：&lt;/p&gt;
&lt;p&gt;$$\int_{0}^{1} f(x+\lambda(y-x)) d \lambda \leq \int_{0}^{1}(f(x)+\lambda(f(y)-f(x))) d \lambda=\frac{f(x)+f(y)}{2}$$&lt;/p&gt;
&lt;p&gt;然后是充分性，即满足后式，必然能保证是凸函数，使用凸函数的第一定义证明：
任取两点$x,y$，任取$\theta \in [0,1]$，需要证明$\theta f(x) + (1-\theta) f(y) \geq f(\theta x + (1-\theta y))$&lt;/p&gt;
&lt;p&gt;用反证法，也就是说函数不是凸函数，至少能找到一个$x, y \in dom f $和$\theta \in [0,1]$，使得
$$\theta f(x) + (1-\theta) f(y) &amp;lt; f(\theta x + (1-\theta) y)$$
也就是说存在$x^*, y^*, \theta^*$关于$\theta$的函数：
$$g(\theta) = f(\theta x + (1-\theta) y) - \theta f(x) - (1-\theta) f(y) &amp;gt;0$$&lt;/p&gt;
&lt;p&gt;由于$\theta = 0$和$1$时上式均为0。所以一定在 $\theta^*$的左右存在两点$p,q$，使得$g(p) = 0, g(q) = 0, g(i)_{p \leq i \leq q} &amp;gt; 0$&lt;/p&gt;
&lt;p&gt;取$x = p, y =q$，在原函数上有$\int_{0}^{1} f(p+\theta(p-q)) d \theta&amp;gt;\int_{0}^{1}(f(p)+\theta(f(p)-f(q))) d \theta=\frac{f(p)+f(q)}{2}$，与初始矛盾，所以反证法成立。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;判断下列函数是否为凸函数、凹函数、拟凸函数与拟凹函数：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;（a）$f(x) = e^x - 1, \textbf{dom}\ f = R$&lt;/p&gt;
&lt;p&gt;（b）$f(x_1,x_2) = x_1 x_2, \textbf{dom}\ f = R_{++}^2$&lt;/p&gt;
&lt;p&gt;（c）$f(x_1,x_2) = 1/(x_1 x_2), \textbf{dom}\ f = R_{++}^2$&lt;/p&gt;
&lt;p&gt;（d）$f(x_1,x_2) = x_1 / x_2, \textbf{dom}\ f = R_{++}^2$&lt;/p&gt;
&lt;p&gt;（e）$f(x_1,x_2) = x_1^2/ x_2, \textbf{dom}\ f = R \times R_{++}$&lt;/p&gt;
&lt;p&gt;（f）$f(x_1,x_2) = x_1^{\alpha} x_2^{1-\alpha}, 0 \leq \alpha \leq 1, \textbf{dom}\ f = R_{++}^2$&lt;/p&gt;
&lt;p&gt;（a）
由于原函数二阶可导
$f&#39;&#39;(x) = e^x &amp;gt; 0$
为凸函数，凸函数也一定是拟凸函数，同时还是拟凹函数&lt;/p&gt;
&lt;p&gt;（b）&lt;/p&gt;
&lt;p&gt;Hessain矩阵为：$$
\nabla^{2} f(x)=\left[\begin{array}{ll}
0 &amp;amp; 1 \newline
1 &amp;amp; 0
\end{array}\right]
$$
既非正定，又非负定，所以不是凸函数也不是凹函数。&lt;/p&gt;
&lt;p&gt;$\alpha$-上水平集为凸集，是拟凹函数，下水平集不是凸集，所以不是拟凸函数&lt;/p&gt;
&lt;p&gt;（c）
Hessain矩阵为：
$$
\nabla^{2} f(x)=\frac{1}{x_{1} x_{2}}\left[\begin{array}{cc}
2 /\left(x_{1}^{2}\right) &amp;amp; 1 /\left(x_{1} x_{2}\right) \newline
1 /\left(x_{1} x_{2}\right) &amp;amp; 2 / x_{2}^{2}
\end{array}\right] \geq 0
$$
是正定的，所以是凸函数，也是拟凸函数。不是凹函数，也不是拟凹函数。&lt;/p&gt;
&lt;p&gt;（d）
Hessain矩阵为：
$$
\nabla^{2} f(x)=\left[\begin{array}{cc}
0 &amp;amp; -1 / x_{2}^{2} \newline
-1 / x_{2}^{2} &amp;amp; 2 x_{1} / x_{2}^{3}
\end{array}\right]
$$
既非正定，又非负定，所以不是凸函数也不是凹函数。
上水平集和下水平集均为半空间，所以既是拟凸的又是拟凹的。&lt;/p&gt;
&lt;p&gt;（e）
$$
\nabla^{2} f(x)=\left[\begin{array}{cc}
2 / x_{2} &amp;amp; -2 x_{1} / x_{2}^{2} \newline
-2 x_{1} / x_{2}^{2} &amp;amp; 2 x_{1}^{2} / x_{2}^{3}
\end{array}\right] \geq 0
$$
是凸函数，也是拟凸函数，不是拟凹函数&lt;/p&gt;
&lt;p&gt;（f）
$$
\nabla^{2} f(x)=\left[\begin{array}{cc}
\alpha(\alpha-1) x_{1}^{\alpha-2} x_{2}^{1-\alpha} &amp;amp; \alpha(1-\alpha) x_{1}^{\alpha-1} x_{2}^{-\alpha} \newline
\alpha(1-\alpha) x_{1}^{\alpha-1} x_{2}^{-\alpha} &amp;amp; (1-\alpha)(-\alpha) x_{1}^{\alpha} x_{2}^{-\alpha-1}
\end{array}\right] \leq 0
$$&lt;/p&gt;
&lt;p&gt;是凹函数，也是拟凹函数。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;函数的积或比，证明以下结论：
$$\newline$$
（a）在某区间上的函数$f$和$g$都是凸函数，且都非减（或者都非增），二者都大于0，则函数$fg$在此区间上也是凸函数
$$\newline$$
（b）函数$f$和$g$都是凹函数，一个非减，一个非增，二者都大于0，则函数$fg$是凹函数
$$\newline$$
（c）函数$f$是凸函数，非减且大于0，$g$是凹函数，非增且大于0，那么函数$f/g$是凸函数&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;要证明$fg$的凹凸性，根据定义，则要证明：
$$\theta f(x)g(x) + (1-\theta) f(y)g(y) 和 f(\theta x + (1-\theta)y)g(\theta x + (1-\theta)y) 的关系$$&lt;/p&gt;
&lt;p&gt;要证明$f/g$的凹凸性，根据定义，则要证明：
$$\theta f(x)/g(x) + (1-\theta) f(y)/g(y) 和 f(\theta x + (1-\theta)y)/g(\theta x + (1-\theta)y) 的关系$$&lt;/p&gt;
&lt;p&gt;（a）&lt;/p&gt;
&lt;p&gt;都凸，所以对于$x, y \in dom$， $\theta \in [0,1]$
$$\begin{array}{ll} f(\theta x + (1-\theta)y)g(\theta x + (1-\theta)y) &amp;amp;\leq (\theta f(x)+(1-\theta) f(y))(\theta g(x)+(1-\theta) g(y)) \newline &amp;amp; = \theta^2 f(x) g(x) + (1-\theta)^2 f(y) g(y) + \theta(1-\theta)(f(y)-f(x))(g(x)-g(y)) \end{array}$$&lt;/p&gt;
&lt;p&gt;且非减且大于0，即$\theta(1-\theta)(f(y)-f(x))(g(x)-g(y)) \leq 0$，有：
$$
\theta(1-\theta)(f(y)-f(x))(g(x)-g(y)) \leq 0
$$
有
$$\theta f(x)g(x) + (1-\theta) f(y)g(y) \geq f(\theta x + (1-\theta)y)g(\theta x + (1-\theta)y)$$&lt;/p&gt;
&lt;p&gt;即$fg$为凸函数&lt;/p&gt;
&lt;p&gt;（b）&lt;/p&gt;
&lt;p&gt;都凹，所以对于$x, y \in dom$， $\theta \in [0,1]$
$$\begin{array}{ll} f(\theta x + (1-\theta)y)g(\theta x + (1-\theta)y) &amp;amp;\geq (\theta f(x)+(1-\theta) f(y))(\theta g(x)+(1-\theta) g(y)) \newline &amp;amp; = \theta^2 f(x) g(x) + (1-\theta)^2 f(y) g(y) + \theta(1-\theta)(f(y)-f(x))(g(x)-g(y)) \end{array}$$&lt;/p&gt;
&lt;p&gt;一个非减一个非增，有
$$
\theta(1-\theta)(f(y)-f(x))(g(x)-g(y)) \geq 0
$$
有
$$\theta f(x)g(x) + (1-\theta) f(y)g(y) \leq f(\theta x + (1-\theta)y)g(\theta x + (1-\theta)y)$$&lt;/p&gt;
&lt;p&gt;$fg$为凹函数&lt;/p&gt;
&lt;p&gt;（c）&lt;/p&gt;
&lt;p&gt;因为$f$为凸，非减且大于0，$g$为凹，非增且大于0，有
$$\begin{array}{ll} f(\theta x + (1-\theta)y)/g(\theta x + (1-\theta)y) &amp;amp;\leq (\theta f(x)+(1-\theta) f(y))/(\theta g(x)+(1-\theta) g(y)) \newline &amp;amp; \leq \theta f(x)/g(x) + (1-\theta) f(y)/g(y) \end{array}$$&lt;/p&gt;
&lt;p&gt;有
$$\theta f(x)/g(x) + (1-\theta) f(y)/g(y) \geq f(\theta x + (1-\theta)y)/g(\theta x + (1-\theta)y)$$&lt;/p&gt;
&lt;p&gt;$f/g$为凸函数&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;证明凸函数的二阶条件，也就是凸函数的充要条件是Hessian矩阵半正定&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;先证充分性，即凸函数可以推导出Hessain矩阵半正定：&lt;/p&gt;
&lt;p&gt;根据凸函数的一阶定义
$$
f(y) \geq f(x) + \nabla f(x)(y-x) \newline
f(x) \geq f(y) + \nabla f(y)(x-y)
$$&lt;/p&gt;
&lt;p&gt;有：&lt;/p&gt;
&lt;p&gt;$$\nabla f(x) (y-x) \leq f(y) - f(x) \leq \nabla f(y)(y-x)$$&lt;/p&gt;
&lt;p&gt;可得&lt;/p&gt;
&lt;p&gt;$$\frac{\nabla f(y) - \nabla f(x)}{y-x} \geq 0$$&lt;/p&gt;
&lt;p&gt;取$y \to x^+$，得：&lt;/p&gt;
&lt;p&gt;$$\nabla^2 f(x) \geq 0$$&lt;/p&gt;
&lt;p&gt;证明必要性，这里先考虑$n=1$的情况&lt;/p&gt;
&lt;p&gt;取$x &amp;lt; y$，根据分部积分法，有：&lt;/p&gt;
&lt;p&gt;$$
\begin{array}{ll}
0 &amp;amp; \leq \int_{x}^{y} f^{\prime \prime}(z)(y-z) dz \newline
&amp;amp;= \left.\left(f^{\prime}(z)(y-z)\right)\right|_{z=x} ^{z=y} + \int_x^y f^{\prime}(z) dz \newline
&amp;amp;=-f^{\prime}(x)(y-x)+f(y)-f(x),
\end{array}
$$&lt;/p&gt;
&lt;p&gt;注： 第一个等号是分部积分法，即
$$f(x)g(x) = \int( f&#39;(x)g(x) + f(x)g&#39;(x)) \newline
\int f&#39;(x)g(x) = f(x)g(x) - \int f(x)g&#39;(x)
$$&lt;/p&gt;
&lt;p&gt;有$$
f(y) \geq f(x) + f&#39;(x)(y-x)
$$
通过一阶条件可知是凸函数&lt;/p&gt;
&lt;p&gt;然后拓展到$n&amp;gt;1$的情况，根据凸函数的第二定义，如果$g(t) = f(x_0 + vt)$对于每个$x_0$和$v$而言都是凸函数的话，就可以得到$f(x)$是凸函数。&lt;/p&gt;
&lt;p&gt;$g(t)$是凸函数也就是说它的二阶导大于等于0：&lt;/p&gt;
&lt;p&gt;$$
g^{\prime \prime}(t)=v^{T} \nabla^{2} f\left(x_{0}+t v\right) v \geq 0
$$&lt;/p&gt;
&lt;p&gt;因为有$\nabla^{2} f \geq 0$，所以上式成立，也就是说$f$是凸函数&lt;/p&gt;
</content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://yichengme.site/categories/%E7%90%86%E8%AE%BA/" term="理论" label="理论" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://yichengme.site/tags/%E5%87%B8%E4%BC%98%E5%8C%96/" term="凸优化" label="凸优化" />
                            
                        
                            
                            
                            
                                <category scheme="https://yichengme.site/tags/%E6%95%B0%E5%AD%A6/" term="数学" label="数学" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">凸优化（一）绪论与凸集</title>
            <link rel="alternate" type="text/html" href="https://yichengme.site/posts/convex-1/" />
            <id>https://yichengme.site/posts/convex-1/</id>
            <updated>2022-02-08T17:27:00&#43;08:00</updated>
            <published>2021-12-27T21:10:31&#43;08:00</published>
            <author>
                    <name>王毅诚</name>
                    <uri>https://yichengme.site/</uri>
                    <email>engine74396@gmail.com</email>
                    </author>
            <rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">凸优化的笔记专栏，预计会分为五个部分，分别是： 绪论与凸集 凸函数 凸优化问题 对偶 算法 参考： Stanford《convex optimization》 中科大 凌青 凸优化 优……</summary>
            
                <content type="html">&lt;p&gt;凸优化的笔记专栏，预计会分为五个部分，分别是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;绪论与凸集&lt;/li&gt;
&lt;li&gt;凸函数&lt;/li&gt;
&lt;li&gt;凸优化问题&lt;/li&gt;
&lt;li&gt;对偶&lt;/li&gt;
&lt;li&gt;算法&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;参考：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Stanford《convex optimization》&lt;/li&gt;
&lt;li&gt;中科大 凌青 凸优化&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;优化问题&#34;&gt;优化问题&lt;/h2&gt;
&lt;p&gt;优化问题：从一系列可行解集合中，寻找出最优的元素&lt;/p&gt;
&lt;p&gt;优化问题的形式：&lt;/p&gt;
&lt;p&gt;$$
\begin{array}{ll}
\text{ minimize } &amp;amp; f_0(x) \newline
\text { subject to } &amp;amp; f_{i}(x) \leq b_i
\end{array}
$$&lt;/p&gt;
&lt;p&gt;$f_0$是目标函数（$R^n \to R$）&lt;/p&gt;
&lt;p&gt;优化问题在现实生活中各个领域都非常常见，深度学习中也是要使Loss最小，也是优化问题。&lt;/p&gt;
&lt;h2 id=&#34;优化问题的分类&#34;&gt;优化问题的分类&lt;/h2&gt;
&lt;h3 id=&#34;线性优化非线性优化&#34;&gt;线性优化/非线性优化&lt;/h3&gt;
&lt;p&gt;（有时候也叫规划，和优化是一个意思）&lt;/p&gt;
&lt;p&gt;目标函数由多个线性函数组合成，就是线性优化问题，否则就是非线性优化问题。&lt;/p&gt;
&lt;p&gt;线性优化问题，最优解不是在顶点就是在整条边上&lt;/p&gt;
&lt;h3 id=&#34;凸优化非凸优化&#34;&gt;凸优化/非凸优化&lt;/h3&gt;
&lt;p&gt;凸优化：&lt;/p&gt;
&lt;p&gt;$$
\begin{array}{ll}
\text{ minimize } &amp;amp; f_0(x) \newline
\text { subject to } &amp;amp; f_{i}(x) \leq 0, \quad i=1, \ldots, m \newline
&amp;amp; a_{i}^{T} x=b_{i}, \quad i=1, \ldots, p
\end{array}
$$&lt;/p&gt;
&lt;p&gt;优化问题里面，比较好求解的是凸优化问题，非凸优化问题难解决&lt;/p&gt;
&lt;h3 id=&#34;光滑非光滑&#34;&gt;光滑/非光滑&lt;/h3&gt;
&lt;p&gt;目标函数每个点都可微就是光滑的，否则是非光滑的&lt;/p&gt;
&lt;h3 id=&#34;连续离散&#34;&gt;连续/离散&lt;/h3&gt;
&lt;p&gt;按照可行域连续或者离散分类&lt;/p&gt;
&lt;h3 id=&#34;单目标多目标&#34;&gt;单目标/多目标&lt;/h3&gt;
&lt;p&gt;对多个目标进行优化&lt;/p&gt;
&lt;p&gt;这门课只研究单目标连续光滑的凸优化问题&lt;/p&gt;
&lt;p&gt;判断是否为凸问题的一个关键，就是看约束集合、目标函数是否是凸集。所以凸集是凸优化问题最基本的一个概念。&lt;/p&gt;
&lt;h2 id=&#34;仿射集-affine-set&#34;&gt;仿射集 Affine set&lt;/h2&gt;
&lt;p&gt;集合中任取两个点，形成的&lt;strong&gt;直线&lt;/strong&gt;，如果整条线上的点也都在集合中，那么称该集合为仿射集
要求任意两点连成的直线在集合中，也就是说&lt;/p&gt;
&lt;p&gt;$$x_1, x_2 \in C, \theta\in R \to \theta x_1 + (1- \theta)x_2 \in C$$&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1640604307/convex-1.png&#34; alt=&#34;convex-1&#34;&gt;&lt;/p&gt;
&lt;p&gt;仿射组合：不仅限两个点，而是多个点：
$$x_1,...x_k \in C , \theta_1 + ... \theta_k = 1 \to \theta_1 x_1 + ... \theta_k x_k \in C$$&lt;/p&gt;
&lt;p&gt;利用
$$
(\theta_1 + \theta_2)(\frac{\theta_1}{\theta_1 + \theta_2}x_1 + \frac{\theta_2}{\theta_1 + \theta_2}x_2) + (1-\theta_1 - \theta_2)x_3 \in C
$$即可证明&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;任意线性方程组$Ax = b$的解集都是仿射集，任意仿射集都可以写成线性方程组的解集&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;假设该线性方程组有两个解$x_1, x_2$，则直线上的任意一点$\theta x_1+(1-\theta)x_2$代入得$A(\theta x_1+(1-\theta)x_2) = b$，说明也是该线性方程组的解&lt;/p&gt;
&lt;p&gt;仿射包：从非仿射集合中构造一个最小的仿射集&lt;/p&gt;
&lt;p&gt;比如两个点的集合不是仿射集，构造一个经过它们的直线，就是仿射集了，这条直线就是仿射包。三个不同直线的点，它们的最小的仿射包就是经过它们的二维平面。如果本身就是仿射集，那么仿射包就是它自己。&lt;/p&gt;
&lt;h2 id=&#34;凸集-convex-set&#34;&gt;凸集 convex set&lt;/h2&gt;
&lt;p&gt;凸集相比于仿射集条件放松，要求任意两点连成的&lt;strong&gt;线段&lt;/strong&gt;在集合中。凸集的定义为：&lt;/p&gt;
&lt;p&gt;$$x_1, x_2 \in C, \theta\in[0,1] \to \theta x_1 + (1- \theta_2)x_2 \in C$$&lt;/p&gt;
&lt;p&gt;仿射集必然是凸集，可以认为是一种特殊的凸集，凸集包含的更广。&lt;/p&gt;
&lt;p&gt;凸组合：不仅限两个点，而是多个点：
$$x_1,...x_k \in C , \theta_1 + ... \theta_k = 1, \theta_i\in[0,1] \to \theta_1 x_1 + ... \theta_k x_k \in C$$&lt;/p&gt;
&lt;p&gt;凸包：包含集合S的最小凸集&lt;/p&gt;
&lt;p&gt;下图2.2，只有左边的凸多边形是凸集。不过如果右图只少了角点，是凸集，少了边上或者内部的点就不是凸集了。&lt;/p&gt;
&lt;p&gt;下图2.3是凸包，包括一组离散点的凸包，以及非凸形状的凸包。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1640604308/convex-2.png&#34; alt=&#34;convex-2&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;典型凸集&#34;&gt;典型凸集&lt;/h2&gt;
&lt;h3 id=&#34;凸锥-convex-cone&#34;&gt;凸锥 Convex cone&lt;/h3&gt;
&lt;p&gt;锥：$\forall x \in C, \theta \geq 0, \theta x \in C$（锥尖需要在原点）&lt;/p&gt;
&lt;p&gt;凸锥：$x_1, x_2 \in C, \theta_1 x_1 + \theta_2 x_2 \in C, \theta_1 &amp;gt; 0, \theta_2 &amp;gt; 0$&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1640604308/convex-cone-1.png&#34; alt=&#34;convex-cone-1&#34;&gt;&lt;/p&gt;
&lt;p&gt;图形理解，任取两点$x_1, x_2$，如果$x_1,x_2,o$不在一条直线上，那么在$\overset{\frown}{x_1 o x_2}$的扇形区域内的所有的点都在凸锥集上&lt;/p&gt;
&lt;p&gt;过原点的直线和原点发出的射线是凸锥&lt;/p&gt;
&lt;p&gt;凸锥组合：$x_1,... x_k \in C, \theta_1 x_1 + ... \theta_k x_k \in C, \theta_1 &amp;gt; 0, ...  \theta_k &amp;gt; 0$&lt;/p&gt;
&lt;p&gt;凸锥包：和前面一样，如下图所示&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1640604308/convex-cone-2.png&#34; alt=&#34;convex-cone-2&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;对比一下前面几种组合：&lt;/strong&gt;
仿射组合：$\theta_1 + ... + \theta_k = 1$
凸组合：$\theta_1 + ... + \theta_k = 1, \theta_1, ... , \theta_k &amp;gt; 0$
凸锥组合：$\theta_1, ... , \theta_k \geq 0$&lt;/p&gt;
&lt;h3 id=&#34;超平面-hyperplane&#34;&gt;超平面 Hyperplane&lt;/h3&gt;
&lt;p&gt;${x|a^T x = b}$&lt;/p&gt;
&lt;p&gt;是仿射集，也是凸集，不一定凸锥（除非过原点）&lt;/p&gt;
&lt;h3 id=&#34;半空间-halfspace&#34;&gt;半空间 Halfspace&lt;/h3&gt;
&lt;p&gt;${ x|a^T x \leq b }$&lt;/p&gt;
&lt;p&gt;半空间是凸集，不是仿射集，不一定凸锥（除非过原点）&lt;/p&gt;
&lt;p&gt;下图分别为超平面和半空间：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1640604308/convex-5.png&#34; alt=&#34;convex-5&#34;&gt;&lt;/p&gt;
&lt;p&gt;证明：
假设$x_1, x_2$在空间上：
$a^T x_1 \leq b$
$a^T x_2 \leq b$
对于$x_1,x_2$上的任意一点$\theta x_1 + (1-\theta) x_2$有：
$a^T(\theta x_1 + (1-\theta) x_2) = \theta (a^T x_1 -b) + (1-\theta) (a^T x_2 - b) +b \leq b$，也在集合中，所以半空间是凸集&lt;/p&gt;
&lt;p&gt;法线的反方向&lt;/p&gt;
&lt;h3 id=&#34;空间球-euclidean-ball&#34;&gt;空间球 Euclidean Ball&lt;/h3&gt;
&lt;p&gt;欧几里得球，就是一个空间球&lt;/p&gt;
&lt;p&gt;$$
B\left(x_{c}, r\right)=\newline{x |\ ||x-x_{c}||_2\leq r \newline} $$&lt;/p&gt;
&lt;p&gt;$$=\newline{x |\ (x-x_{c})^{T}(x-x_{c} ) \leq r^2\newline}
$$&lt;/p&gt;
&lt;p&gt;证明：
假设$x_1, x_2$在空间上：
$|| x_1 - x_c ||_2 \leq r$
$|| x_2 - x_c ||_2 \leq r$
对于$x_1,x_2$上的任意一点$\theta x_1 + (1-\theta) x_2 $，（其中$\theta \in [0,1]$），有：
$$|| \theta x_1 + (1-\theta) x_2 - x_c ||_r = || \theta (x_1 - x_c) + (1-\theta)(x_2 - x_c)||\newline
\leq \theta ||x_1 - x_c||_2 + (1-\theta) ||x_2 - x_c||_2 \leq r
$$
这里用到了范数的三角不等式&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;范数性质
假设$x$的范数是$f(x)$，$f(x)\geq 0$，满足下面三条性质：
$\text{if}\ f(x)=0 \to x=0$
$kf(x) = |k|f(x)$
$f(x+y) \leq f(x) + f(y)$（三角不等式）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;椭球-ellipsoids&#34;&gt;椭球 Ellipsoids&lt;/h3&gt;
&lt;p&gt;$$\mathcal{E} = \{ x \mid\left(x-x_{c}\right)^{T} P^{-1}\left(x-x_{c}\right) \leq 1 \}$$&lt;/p&gt;
&lt;p&gt;矩阵P是一个 $n\times n$ 的对称正定矩阵&lt;/p&gt;
&lt;p&gt;（特征值，奇异值）&lt;/p&gt;
&lt;h3 id=&#34;多面体-polyhedra&#34;&gt;多面体 Polyhedra&lt;/h3&gt;
&lt;p&gt;多面体：有限个线性等式和不等式的解集
多面体是有限个半空间和超平面的交集&lt;/p&gt;
&lt;p&gt;$$
\mathcal{P}=\newline{x \mid a_{j}^{T} x \leq b_{j}, j=1, \ldots, m, c_{j}^{T} x=d_{j}, j=1, \ldots, p\newline}
$$&lt;/p&gt;
&lt;h3 id=&#34;范数球-norm-ball--范数锥-norm-cone&#34;&gt;范数球 Norm Ball &amp;amp; 范数锥 Norm Cone&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;范数：满足以下条件的函数$||\cdot||$
1、$||x||\geq 0$，$||x||=0$当且仅当$x=0$
2、$||tx|| = t||x||$，对于任何$t\in R$成立
3、$||x+y|| \leq ||x|| + ||y||$&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;$$
C={(x, t) \mid|x| \leq t} \subseteq \mathbf{R}^{n+1}
$$&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1640604308/convex-6.png&#34; alt=&#34;convex-6&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;其他的例子&#34;&gt;其他的例子&lt;/h3&gt;
&lt;p&gt;n*n的对称矩阵组成的集合，是凸锥，也是凸集&lt;/p&gt;
&lt;p&gt;n*n的半正定矩阵组成的集合，是凸集&lt;/p&gt;
&lt;p&gt;n*n的正定矩阵组成的集合不是凸集（取值只能&amp;gt;=0，不属于正定了）&lt;/p&gt;
&lt;p&gt;线性矩阵不等式的解集也是凸集&lt;/p&gt;
&lt;h2 id=&#34;保凸运算&#34;&gt;保凸运算&lt;/h2&gt;
&lt;p&gt;如果要证明是凸集可以用定义法，不过复杂情况会很难证明。
另一种方法是证明集合是多个凸集的保凸运算的简单组合，保凸运算包括以下几个：&lt;/p&gt;
&lt;h3 id=&#34;交集-intersection&#34;&gt;交集 Intersection&lt;/h3&gt;
&lt;p&gt;$C_1$, $C_2$是凸集，其交集$C = C_1 \cap C_2$也一定是凸集。&lt;/p&gt;
&lt;p&gt;拓展到n个也是。&lt;/p&gt;
&lt;h3 id=&#34;仿射函数-affine&#34;&gt;仿射函数 Affine&lt;/h3&gt;
&lt;p&gt;$f$是仿射变换：$\mathbf{R}^{n} \rightarrow \mathbf{R}^{m}$&lt;/p&gt;
&lt;p&gt;如果有$S \in R^n$是凸集，那么$f(S)=\newline{f(x) \mid x \in S\newline}$也是凸集，用定义证明即可。
逆函数$f^{-1}(S)=\newline{x \mid f(x) \in S\newline}$也是凸集。&lt;/p&gt;
&lt;h3 id=&#34;透视函数-perspective-functions&#34;&gt;透视函数 Perspective functions&lt;/h3&gt;
&lt;p&gt;透视函数 $P: \mathbf{R}^{n+1} \rightarrow \mathbf{R}^{n}$，相当于通过变换（所有元素除以最后一个元素）将最后一个维度的元素变为1，然后去掉这个维度的一种变换。降低一个维度。&lt;/p&gt;
&lt;p&gt;$P(\mathbf{X}, t) = \mathbf{X}/t, dom P = \newline{(\mathbf{X}, t), t &amp;gt; 0\newline}$
这里t是一个标量，X是矩阵，相当于P是dom(X)+1维度的，去掉最后一个维度t，X里的每一个元素除以t。&lt;/p&gt;
&lt;p&gt;类比于针孔相机，3维的点$(x_1, x_2, x_3)$会通过孔映射到二维的平面 $-(x_1/x_3, x_2/x_3, 1)$ 上，就是一个透视函数的过程。&lt;/p&gt;
&lt;p&gt;任意凸集的反透视映射也是凸集&lt;/p&gt;
&lt;h3 id=&#34;线性分段函数-linear-fractional&#34;&gt;线性分段函数 Linear-fractional&lt;/h3&gt;
&lt;p&gt;一个Linear-fractional function是由perspective function和一个affine function组成的&lt;/p&gt;
&lt;p&gt;$g(x)=\left[\begin{array}{c}A \newline c^{T}\end{array}\right] x+\left[\begin{array}{l}b \newline d\end{array}\right]$&lt;/p&gt;
&lt;h2 id=&#34;超平面分离定理与支撑超平面&#34;&gt;超平面分离定理与支撑超平面&lt;/h2&gt;
&lt;h3 id=&#34;超平面分离定理&#34;&gt;超平面分离定理&lt;/h3&gt;
&lt;p&gt;如果$C$和$D$是两个不相交的凸集，那么必然存在一个超平面$\newline{x|a^Tx = b\newline}$能够分离$C$和$D$，这超平面被称为分割超平面&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1641388051/convex-8.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;支撑超平面&#34;&gt;支撑超平面&lt;/h3&gt;
&lt;p&gt;集合C边界上的点$x_0$的支撑超平面：$\newline{x | a^Tx = a^T x_0\newline}$&lt;/p&gt;
&lt;p&gt;其中$a \neq 0$，对于所有的$x \in C$满足$a^Tx \leq a^T x_0$&lt;/p&gt;
&lt;p&gt;如果$C$是凸的，那么C边界上的每一个点都存在一个支撑超平面。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1641388051/convex-9.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;例题&#34;&gt;例题&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;设$C \subseteq R^n$是一个凸集，证明对于任意$k$的情况，满足$\theta_i \geq 0, \theta_1 + ... \theta_k = 1$的情况下，有$\theta_1 x_1 + ... + \theta_k x_k \in C$。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;证明：使用数学归纳法，
$k=2$时，根据凸集的定义性质可知，任取$\theta_1, \theta_2$，满足$\theta_1+\theta_2=1$，有$\theta_1 x_1 + \theta_2 x_2 \in C$&lt;/p&gt;
&lt;p&gt;假设$k=n-1$时上式成立，即满足$\theta_1+ ... +\theta_{n-1}=1$，有$\theta_1 x_1 + ... +  \theta_{n-1} x_{n-1} \in C$&lt;/p&gt;
&lt;p&gt;下面考虑$k=n$的情况，构造下面的式子：&lt;/p&gt;
&lt;p&gt;$$
(\sum_{i=1}^{k-1} \theta_i) \frac{\sum_{i=1}^{k-1} \theta_i x_i}{\sum_{i=1}^{k-1}\theta_i} + (1-\sum_{i=1}^{k-1} \theta_i)x_i
$$&lt;/p&gt;
&lt;p&gt;其中$\frac{\sum_{i=1}^{k-1} \theta_i x_i}{\sum_{i=1}^{k-1}\theta_i}$完全符合$n-1$的条件，所以$\frac{\sum_{i=1}^{k-1} \theta_i x_i}{\sum_{i=1}^{k-1}\theta_i} \in C$，整个式子又满足$k=2$的凸集的定义，所以有：
$$
(\sum_{i=1}^{k-1} \theta_i) \frac{\sum_{i=1}^{k-1} \theta_i x_i}{\sum_{i=1}^{k-1}\theta_i} + (1-\sum_{i=1}^{k-1} \theta_i)x_i \in C
$$&lt;/p&gt;
&lt;p&gt;即证明了只要$k=n-1$时成立，就有$k=n$时成立，数学归纳法得证&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;判断下面的哪些集合是凸集&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;（a）平板，形如$\newline{x \in \mathbf{R}^{n} \mid \alpha \leqslant a^{T} x \leqslant \beta\newline}\newline$&lt;/p&gt;
&lt;p&gt;（b）矩形，形如$\newline{x \in \mathbf{R}^{n} \mid \alpha_i \leqslant x_i \leqslant \beta_i\ , i = 1, ..., n \newline}$&lt;/p&gt;
&lt;p&gt;（c）楔形，形如$\newline{x \in \mathbf{R}^{n} \mid \alpha_1^T x \leqslant b_1 , \alpha_2^T x \leqslant b_2, i = 1, ..., n \newline}$&lt;/p&gt;
&lt;p&gt;（d）距离给定点比距离给定集合近的点构成的集合：
$ \newline{ x \mid ||x-x_0||_2 \leq ||x-y||_2, \forall y \in S \newline}$&lt;/p&gt;
&lt;p&gt;（e）距离一个集合比另一个集合更近的点的集合：$\newline{x \mid \operatorname{dist}(x, S) \leqslant \operatorname{dist}(x, T)\newline}$&lt;/p&gt;
&lt;p&gt;（f）集合$\newline{x \mid x + S_2 \subseteq S_1 \newline}$，其中$S_1, S_2 \subseteq R^n$，并且$S_1$是凸集&lt;/p&gt;
&lt;p&gt;（g）到 $a$ 的距离与到 $b$ 的距离之比不超过到某一固定分数$\theta$的点的集合，即集合$\newline{x \mid|x-a|_2 \leqslant \theta |x-b|_2\newline}$&lt;/p&gt;
&lt;p&gt;（a）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用定义证明：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;任取$x_1, x_2 \in C$，有$\alpha \leqslant a^{T} x_1 \leqslant \beta, \alpha \leqslant a^{T} x_2 \leqslant \beta$&lt;/p&gt;
&lt;p&gt;对于$\theta \in [0, 1]$，对于$ (\theta x_1 + (1-\theta) x_2)$，有：
$$\alpha = \theta \alpha + (1-\theta) \alpha \leq \alpha^T (\theta x_1 + (1-\theta) x_2) \leq \theta  \beta + (1-\theta) \beta = \beta$$&lt;/p&gt;
&lt;p&gt;即$ (\theta x_1 + (1-\theta) x_2) \in C$，是凸集&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用保凸性证明：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因为平板是两个半空间的交集，半空间是凸集，交集是保凸运算，所以平板也是凸集&lt;/p&gt;
&lt;p&gt;（b）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用定义证明：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;任取$x_1, x_2 \in C$，有$\alpha_i \leqslant x_1 \leqslant \beta_i, \alpha_i \leqslant x_2 \leqslant \beta_i$&lt;/p&gt;
&lt;p&gt;对于$\theta \in [0, 1]$，对于$ (\theta x_1 + (1-\theta) x_2)$，有：
$$\alpha_i \leq (\theta x_1 + (1-\theta) x_2) \leq \beta_i$$&lt;/p&gt;
&lt;p&gt;即$ (\theta x_1 + (1-\theta) x_2) \in C$，是凸集&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用保凸性证明：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;矩形是多个半空间的交集，半空间是凸集，交集是保凸运算，所以矩形也是凸集&lt;/p&gt;
&lt;p&gt;（c）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用定义证明：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;任取$x_1, x_2 \in C$，有$a_1^{T} x_1 \leqslant b_1, a_2^{T} x_1 \leqslant b_2$、$a_1^{T} x_2 \leqslant b_1, a_2^{T} x_2 \leqslant b_2$&lt;/p&gt;
&lt;p&gt;对于$\theta \in [0, 1]$，对于$ (\theta x_1 + (1-\theta) x_2)$，有：
$$a_1^T (\theta x_1 + (1-\theta) x_2) \leq \theta b_1 + (1-\theta) b_1 = b_1\newline
a_2^T (\theta x_1 + (1-\theta) x_2) \leq \theta b_2 + (1-\theta) b_2 = b_2$$&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用保凸性证明：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;楔形是多个半空间的交集，半空间是凸集，交集是保凸运算，所以楔形也是凸集&lt;/p&gt;
&lt;p&gt;（d）
对于固定的$y$而言，有：
$$
\begin{array}{ll}
&amp;amp;||x-x_0||_2 \leqslant ||x-y||_2\newline
\Leftrightarrow &amp;amp; (x-x_0)^T(x-x_0) \leqslant (x-y)^T (x-y)\newline
\Leftrightarrow &amp;amp; x^T x - 2x_0^T x + x_0^T x_0 \leqslant x^T x - 2y^T x + y^T y\newline
\Leftrightarrow &amp;amp; 2(y^T - x_0^T)x \leqslant y^T y - x_0^T x_0 \newline
\end{array}
$$
s
说明该集合是多个半空间的交集，交集为保凸运算，所以该集合为凸集&lt;/p&gt;
&lt;p&gt;（e）
不是凸集，可以举反例，比如$S = {(x, y)|x^2 + y^2 = 1}$，$T = {(0, 0)}$，那么这个集合就是$R^2$平面挖空一个圆心在原点，半径为$\frac{1}2$的孔，比如集合上取$(0, 1),(0, -1)$两点，取$\theta=0.5$，$(0,0)$不在这个集合内，很显然它不是凸集。&lt;/p&gt;
&lt;p&gt;（f）
令$y \in S_2$，集合相当于是多个凸集$(S_1 - y)$的交集，交集为保凸运算，所以也是凸集。&lt;/p&gt;
&lt;p&gt;（g）
是凸集
$$
\begin{array}{ll}
&amp;amp; ||x-a||_2 \leqslant \theta||x-b||_2\newline
\Leftrightarrow &amp;amp; (1-\theta^2)x^Tx - 2 (a-\theta^2b)^Tx + (a^Ta - \theta^2b^Tb) \leq 0
\end{array}
$$&lt;/p&gt;
&lt;p&gt;如果$\theta \leq 1$，集合是一个球
如果$\theta = 1$，集合是半空间
都是凸集&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;一些概率分布集合，令$x$为服从分布 $\textbf{prob}(x=a_i) = p_1, i = 1, ... ,n$ 的实数随机变量，$p \in R^n$在一个标准概率单纯形$P=\{p \mid \mathbf{1}^{T} p=1, p \succeq 0\}$，下面哪些条件在$p$中是凸的？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;（a）$\alpha \leqslant \textbf{E} f(x) \leqslant \beta$&lt;/p&gt;
&lt;p&gt;（b）$\textbf{prob}(x&amp;gt;\alpha) \leqslant \beta$&lt;/p&gt;
&lt;p&gt;（c）$\textbf{E} |x^3| \leqslant \alpha \textbf{E} |x|$&lt;/p&gt;
&lt;p&gt;（d）$\textbf{E} x^2 \leqslant \alpha$&lt;/p&gt;
&lt;p&gt;（e）$\textbf{E} x^2 \geqslant \alpha$&lt;/p&gt;
&lt;p&gt;（f）$\textbf{var} (x) \leqslant \alpha$&lt;/p&gt;
&lt;p&gt;（g）$\textbf{var} (x) \geqslant \alpha$&lt;/p&gt;
&lt;p&gt;（h）$\textbf{quartile} (x) \geqslant \alpha$，$\textbf{quartile} (x) = \text{inf} \{ \beta | \textbf{prob}(x\leqslant \beta) \geqslant 0.25\}$&lt;/p&gt;
&lt;p&gt;（i）$\textbf{quartile} (x) \leqslant \alpha$&lt;/p&gt;
&lt;p&gt;$p$的约束：$p_i \geq 0$是n个半空间，约束$\sum_{i=1}^n = 1$是超平面，也就是说$p$是一个多面体，本身为凸集。&lt;/p&gt;
&lt;p&gt;（a）
$\alpha \leq \sum_{i=1}^n p_i f(a_i) \leq \beta$
增加线性不等式约束，仍为凸集&lt;/p&gt;
&lt;p&gt;（b）
$\textbf{prob}(x\geq \alpha) = \sum_{i, a_i \geq \alpha}p_i \leq \beta$
增加线性不等式约束，仍为凸集&lt;/p&gt;
&lt;p&gt;（c）
$\mathbf{E}\left|x^{3}\right| \leq \alpha \mathbf{E}|x| \to \sum_{i=1}^{n} p_{i}\left(\left|a_{i}^{3}\right|-\alpha\left|a_{i}\right|\right) \leq 0$
增加线性不等式约束，仍为凸集&lt;/p&gt;
&lt;p&gt;（d）
$\sum_{i=1}^{n} p_{i} a_{i}^2 \leq \alpha$
增加线性不等式约束，仍为凸集&lt;/p&gt;
&lt;p&gt;（e）
$\sum_{i=1}^{n} p_{i} a_{i}^2 \geq \alpha$
增加线性不等式约束，仍为凸集&lt;/p&gt;
&lt;p&gt;（f）
$\textbf{var}(x)=\mathbf{E} x^2-(\mathbf{E} x)^2=\sum_{i=1}^{n} p_{i} a_{i}^2-\left(\sum_{i=1}^{n} p_{i} a_{i}\right)^2 \leq \alpha$
不是凸集。举反例，比如$a_1 = 0, a_2 = 1, \alpha = 0.2$，两个点$p_1 = (0, 1), p_2 = (1,0)$，有$\textbf{var}(x) \leq \alpha$，但是中间的点$(\frac{1}2, \frac{1}2)$明显不满足。&lt;/p&gt;
&lt;p&gt;（g）
$\textbf{var}(x)=\mathbf{E} x^2-(\mathbf{E} x)^2=\sum_{i=1}^{n} p_{i} a_{i}^2-\left(\sum_{i=1}^{n} p_{i} a_{i}\right)^2 = b^T p + p^T A p  \geq \alpha$
因为$A = a a^T$是半正定的，所以是凸集&lt;/p&gt;
&lt;p&gt;（h）
$\textbf{prob}\left(x \leq a_{k}\right)=\sum_{i=1}^{k} p_{i}&amp;lt;0.25$
是一个半空间，是凸集。&lt;/p&gt;
&lt;p&gt;（i）
$\sum_{i=k+1}^{n} p_{i} \geq 0.25$
是一个半空间，是凸集。&lt;/p&gt;
</content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://yichengme.site/categories/%E7%90%86%E8%AE%BA/" term="理论" label="理论" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://yichengme.site/tags/%E5%87%B8%E4%BC%98%E5%8C%96/" term="凸优化" label="凸优化" />
                            
                        
                            
                            
                            
                                <category scheme="https://yichengme.site/tags/%E6%95%B0%E5%AD%A6/" term="数学" label="数学" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">返璞归真，博客重新迁移到Hugo</title>
            <link rel="alternate" type="text/html" href="https://yichengme.site/posts/hello-world/" />
            <id>https://yichengme.site/posts/hello-world/</id>
            <updated>2022-01-12T12:31:42&#43;08:00</updated>
            <published>2021-12-21T23:08:40&#43;08:00</published>
            <author>
                    <name>王毅诚</name>
                    <uri>https://yichengme.site/</uri>
                    <email>engine74396@gmail.com</email>
                    </author>
            <rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">第一次开博客应该是在大二的时候，也就是2018年，用的是Hexo。之后觉得配置太少，想要有发挥的空间，就用当时学的Django写了一个博客网站，再后来又改成了G……</summary>
            
                <content type="html">&lt;p&gt;第一次开博客应该是在大二的时候，也就是2018年，用的是Hexo。之后觉得配置太少，想要有发挥的空间，就用当时学的Django写了一个博客网站，再后来又改成了Go+Vue，作为一个前后端分离的单体应用，包含博客的完整的功能，还能有其他拓展。&lt;/p&gt;
&lt;p&gt;这本来应该是博客的最终形态了，然而精力有限，不想折腾markdown渲染和其他各种功能，以及为一些前后端、运维、优化的问题所烦恼，再加上服务器成本也不少，还是希望能够纯粹的写作。&lt;/p&gt;
&lt;p&gt;因此现在又回到了最初的起点，转回了静态网页，这次改用Hugo搭建（和hexo类似），之前的博客内容会逐步迁移过来，由于发布文章很方便，之后会增加更多的内容，敬请期待。&lt;/p&gt;
</content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://yichengme.site/categories/%E7%94%9F%E6%B4%BB/" term="生活" label="生活" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://yichengme.site/tags/hugo/" term="hugo" label="hugo" />
                            
                        
                            
                            
                            
                                <category scheme="https://yichengme.site/tags/site/" term="site" label="site" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">分布式系统（二）：共识算法</title>
            <link rel="alternate" type="text/html" href="https://yichengme.site/posts/distribution-system-2/" />
            <id>https://yichengme.site/posts/distribution-system-2/</id>
            <updated>2022-02-08T17:27:00&#43;08:00</updated>
            <published>2021-12-19T23:18:18&#43;08:00</published>
            <author>
                    <name>王毅诚</name>
                    <uri>https://yichengme.site/</uri>
                    <email>engine74396@gmail.com</email>
                    </author>
            <rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">拜占庭将军问题 拜占庭将军问题是分布式领域最复杂的一个容错模型，较好地抽象了分布式系统面临的共识问题。 假如你是一位拜占庭的将军，需要与其他几个国家的军队做沟通，而……</summary>
            
                <content type="html">&lt;h2 id=&#34;拜占庭将军问题&#34;&gt;拜占庭将军问题&lt;/h2&gt;
&lt;p&gt;拜占庭将军问题是分布式领域最复杂的一个容错模型，较好地抽象了分布式系统面临的共识问题。&lt;/p&gt;
&lt;p&gt;假如你是一位拜占庭的将军，需要与其他几个国家的军队做沟通，而信使可能会被杀，可能会被替换，可能某国军队会传递错误信息等等，抽象出来的问题就是，如何在可能有错误发生的情况下，让多个节点达成共识，保持一致。&lt;/p&gt;
&lt;p&gt;拜占庭将军是最困难的一种情况，因为会存在恶意节点行为行为，在某些场景（比如数字货币区块链）只能使用拜占庭容错算法（Byzantine Fault Torerace，BFT），常见的拜占庭算法有口信消息型算法、签名消息型算法、PBFT算法、PoW算法等。&lt;/p&gt;
&lt;p&gt;在计算机分布式系统中，最常使用的还是非拜占庭容错算法，也就是故障容错算法（Crash Fault Tolerance，CFT），解决的是分布式系统中存在故障，但不存在恶意节点的场景。常见的算法有Paxos算法、Raft算法、ZAB协议等，这些协议之后都会讲解。&lt;/p&gt;
&lt;p&gt;不过对于恶性的情况，一般只在区块链中出现，算法有PBFT、PoW等。但是我并没有打算涉足区块链相关的研究，所以这些算法不在讨论范围之内。&lt;/p&gt;
&lt;h2 id=&#34;共识算法的概念&#34;&gt;共识算法的概念&lt;/h2&gt;
&lt;p&gt;共识算法就是用来达成一致性的方法。&lt;/p&gt;
&lt;p&gt;需要满足三个条件：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Termination：保证算法最后可以做出决定，不能是无限循环的&lt;/li&gt;
&lt;li&gt;Validity：最终决议一定来自于其中一个参与的节点&lt;/li&gt;
&lt;li&gt;Agreement：算法完成时，所有节点一定会做出相同的决定&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;FLP定理：完美的共识算法不存在。在非同步的网络环境中，就算只应付一个节点故障，也没有一个共识算法能保证完全正确。&lt;/p&gt;
&lt;p&gt;一般的共识算法分为两类：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Symmetric, no leader&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;所有的节点地位等同，client可以向每一个server发送请求&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;Asymmetric, leader based&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;任一时刻只会有一个leader，leader处理client的请求，其余server只接受leader的决策，client只可以向leader发送请求。&lt;/p&gt;
&lt;h2 id=&#34;paxos算法&#34;&gt;Paxos算法&lt;/h2&gt;
&lt;p&gt;Paxos算法是分布式共识算法的元老，目前最流行的分布式算法都是基于Paxos改进的，所以不得不提。&lt;/p&gt;
&lt;p&gt;兰伯特Lamport提出的Paxos包含两个部分：
一个是Basic Paxos，描述的是多个节点之间如何就一个value达成共识；
一个是Multi-Paxos，描述的是执行多个Basic Paxos实例，为一系列value达成共识。
这一节只说Basic Paxos，Multi-Paxos下一节&lt;/p&gt;
&lt;h3 id=&#34;系统角色&#34;&gt;系统角色&lt;/h3&gt;
&lt;p&gt;提议者（Proposers）：向系统里的其他节点提出v=C，希望大家达成共识。&lt;/p&gt;
&lt;p&gt;接受者（Acceptors）：不发起proposal的节点，接受Proposers的提议。&lt;/p&gt;
&lt;p&gt;学习者（Learner）：不参与投票的过程，被告知投票的结果，接受达成的共识存储保存数据。&lt;/p&gt;
&lt;h3 id=&#34;算法流程&#34;&gt;算法流程&lt;/h3&gt;
&lt;p&gt;分为两个流程：&lt;/p&gt;
&lt;p&gt;第一步：准备阶段&lt;/p&gt;
&lt;p&gt;在提出提案之前，先得到超过半数节点的回应，也就是有半数以上的节点愿意聆听这个Proposer。假设这次要发送的数据是v&lt;/p&gt;
&lt;p&gt;具体的过程：Proposers向所有节点发送&lt;code&gt;Prepare(n)&lt;/code&gt;，n包含了一些元信息，可以比较大小，Acceptors接收到后，与这一轮从其他Proposers里收到的最大的提议N比较。&lt;/p&gt;
&lt;p&gt;准备阶段只需要发送n即可，不需要发送v。&lt;/p&gt;
&lt;p&gt;如果$n&amp;lt;N$，也就是目前的这个提议的n比这一轮已有的最大的N还小，直接无视这个提议。
否则，就认为当前提议更好，如果此时已经发送过了一个返回给之前最大的那个Proposer，就返回一个&lt;code&gt;ack(n, (nx, vx))&lt;/code&gt;，n是这一次的n，nx是之前最大的那个Proposer的n，vx之前最大的那个Proposer的x。如果之前没接受过其他提议，就发送&lt;code&gt;ack(n, (null, null))&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;第二步：接受阶段&lt;/p&gt;
&lt;p&gt;Proposers等待过半的Acceptors返回后，对&lt;code&gt;ack&lt;/code&gt;作出判断，如果里面有节点的&lt;code&gt;ack&lt;/code&gt;返回的nx、vx不为空，就主动放弃，找出里面最大nx的vx，再发送&lt;code&gt;accept(n,vx)&lt;/code&gt;给所有的Acceptors。
如果都为空的话，就传送&lt;code&gt;accept(n,v)&lt;/code&gt;给所有的Acceptors。&lt;/p&gt;
&lt;p&gt;Acceptors收到&lt;code&gt;accept(n,v)&lt;/code&gt;后，不过可能还会收到&lt;code&gt;prepare(n)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Paxos论文描述：
&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1640193486/paxos-8.png&#34; alt=&#34;paxos-8&#34;&gt;&lt;/p&gt;
&lt;p&gt;一些容易想错的地方，进行声明：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;这里的n并不是具体的int，只是为了简单描述算法，实际上这里的n是一种数据结构，但是相互之间可以被比较，并且对于每个节点而言，它们的n必然不相同。
并不是说一个节点只能当Proposer、Acceptor、Learner中的一种，实际上，每个节点都同时具有这三种角色。
Basic Paxos只是对一个值形成决议，并不是多个值。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;具体例子&#34;&gt;具体例子&lt;/h3&gt;
&lt;p&gt;举一个具体的例子，两个客户端作为提议者，n分别为1和5，v分别为3和7，有三个接受者。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;准备阶段&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;提议者分别发送&lt;code&gt;Prepare(n)&lt;/code&gt;给三个节点，假设说AB先接收到了客户端1的信息，C先接受到了客户端2的信息&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1640193484/paxos-1.jpg&#34; alt=&#34;paxos-1&#34;&gt;&lt;/p&gt;
&lt;p&gt;由于接受者之前没有提案（也可以认为目前的n是无穷小），所以接受到第一个提案后都进行响应，返回&lt;code&gt;ack(n, (null, null))&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1640193485/paxos-2.jpg&#34; alt=&#34;paxos-2&#34;&gt;&lt;/p&gt;
&lt;p&gt;之后AB接受到客户端2传来的&lt;code&gt;Prepare(5)&lt;/code&gt;，5&amp;gt;1，所以会发送准备响应给2。C接受到客户端1传来的&lt;code&gt;Prepare(1)&lt;/code&gt;，1&amp;lt;5，直接无视该请求&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1640193485/paxos-3.jpg&#34; alt=&#34;paxos-3&#34;&gt;&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;接受阶段
由于1、2都收到了多于半数的准备返回响应，并且返回的响应包含的之前最大提案号为空，所以会发送分别接受请求&lt;code&gt;accpet(1, 3)&lt;/code&gt;和&lt;code&gt;accept(5, 7)&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1640193484/paxos-4.jpg&#34; alt=&#34;paxos-4&#34;&gt;&lt;/p&gt;
&lt;p&gt;最后ABC接受到1的确认，由于之前承诺不再接受n小于5的，所以不会变。接受到5的确认后就修改为了5&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1640193485/paxos-5.jpg&#34; alt=&#34;paxos-5&#34;&gt;&lt;/p&gt;
&lt;p&gt;假设另一个例子，在某个顺序AB是n=5,v=7，C是n=1,v=3。此时有一个请求[9, 6]，发送给ABC之后，准备阶段，由于9&amp;gt;5，ABC会接受，并返回
&lt;code&gt;ack(n, (nx, nv))&lt;/code&gt;，具体是AB返回&lt;code&gt;ack(9, (5, 7))&lt;/code&gt;,C返回&lt;code&gt;ack(9, (1, 3))&lt;/code&gt;，那么客户端3由于接受到的返回不为空，就会判断之前最大的n，这里是5，对应的v是7，所以在接受阶段会发送&lt;code&gt;accpet(9, 7)&lt;/code&gt;给所有节点。&lt;/p&gt;
&lt;p&gt;可以参考这个视频：https://www.youtube.com/watch?v=UUQ8xYWR4do&lt;/p&gt;
&lt;h2 id=&#34;multi-paxos&#34;&gt;Multi-Paxos&lt;/h2&gt;
&lt;p&gt;Multi-Paxos并不是一个具体的算法，而是一种思想。指的是基于Mulit-Paxos算法通过多个Basic Paxos实例实现一系列值的共识的算法。（比如Raft算法、ZAB协议等）&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1640193485/paxos-6.jpg&#34; alt=&#34;paxos-6&#34;&gt;&lt;/p&gt;
&lt;p&gt;由于第一阶段收到大多数准备响应的提议者才能发起第二阶段，那么如果多个提议者同时提交提案，可能因为永远无法收到超过半数的准备响应而阻塞。（比如系统中有5个节点，有3个同时发起提案）。
另一个问题是两轮的RPC太消耗性能，也增加了延迟。&lt;/p&gt;
&lt;p&gt;通过引入Leader（领导者）角色以及优化Basic Paxos来解决这两个问题。
Leader节点作为唯一的提议者，这样就不存在提议冲突的情况。
Leader的提案永远是最新的，所以省略掉准备阶段，直接开始接受阶段：
&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1640193485/paxos-7.jpg&#34; alt=&#34;paxos-7&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;chubby的multi-paxos实现&#34;&gt;Chubby的Multi-Paxos实现&lt;/h3&gt;
&lt;p&gt;Chubby实现了闭源的Multi-Paxos，通过引入Leader节点。Leader是通过执行Basic Paxos投票产生的。
运行过程中会通过续租的方式延长租期，如果Leader故障，其他节点会选举出新的Leader。
所有的读和写操作也只能在Leader上进行：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;写请求，Leader收到客户端的写请求，作为唯一的Proposer执行Basic Paxos将数据发给所有的节点来达成一致，半数以上的服务器接受了写请求之后，响应给客户端成功&lt;/li&gt;
&lt;li&gt;读请求，很简单，Leader直接查询本地数据返回给客户端即可。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Chubby的ulti-Paxos实现的一些点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Leader本地的数据一定是最新的。&lt;/li&gt;
&lt;li&gt;可以容忍$\frac{n-1}{2}$个节点的故障&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;raft&#34;&gt;Raft&lt;/h2&gt;
&lt;p&gt;Raft算法在Multi-Paxos的思想上进行了简化和限制，是最常用的一个共识算法，也是目前分布式系统的首选共识算法。包括Etcd、Consul等。&lt;/p&gt;
&lt;p&gt;本质上来说，Raft算法是通过一切以领导者为准的方式，实现一系列值的共识和各节点的日志一致。&lt;/p&gt;
&lt;p&gt;强烈推荐看一下这个可视化的Raft，可以加深理解：http://thesecretlivesofdata.com/raft/&lt;/p&gt;
&lt;h3 id=&#34;leader选举&#34;&gt;Leader选举&lt;/h3&gt;
&lt;p&gt;服务器节点的状态分为三种：Leader（领导者）、Follower（追随者）、Candidate（候选人），其中Leader有且只有一个。&lt;/p&gt;
&lt;p&gt;Leader：系统的核心角色，负责处理写请求、管理日志复制和不断与其他节点维持心跳，告知节点Leader存活，不要选举
Follower：普通群众，接受和处理来自Leader的消息，如果Leader心跳超时就主动站出来变成Candidate
Candidate：候选人，向其他节点发送RequestVote的RPC消息，通知其他节点投票，一旦获得了多数投票就晋升为Leader&lt;/p&gt;
&lt;p&gt;Raft算法实现了随机超时时间，每个节点等待Leader的心跳超时时间随机。&lt;/p&gt;
&lt;p&gt;初始时没有Leader，都是Follower，所有节点听不到Leader心跳，超时时间最小的节点首先称为候选者。
它会增加自己的任期编号，给自己先投一票，然后发送RPC请求其他节点投票。
其他节点收到RPC投票消息之后，如果还没有称为候选者，也还没投票的话，就会去投一票，同时增加自己的任期编号。
如果在选举超时时间内获得了大多数的选票，就晋升为Leader。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;关于RPC
Raft算法总共有两类RPC，一个是请求投票RequestVote，一个是日志复制AppendEntries&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;关于timeout
每个节点的等待时间有两种：
① 一个是election timeout，也就是从上一次Leader心跳开始算，如果过了这个timeout还没听到心跳，就自己称为Candidate，这个timeout一般是150-300ms
② heartbeat timeout&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;关于任期
任期由单调递增的数字（任期编号）标识
何时加1？Follow发现Leader心跳超时，将自己任期+1，并发RPC
何时更新？
① 跟随者接受到包含任期的RPC请求后，发现任期比自己的大，就更新自己的任期为更大的任期。
② Leader或者Candidate发现自己的任期编号比其他节点小，会立即降为Follower&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果一个节点收到一个包含任期编号比自己小的RPC请求，会直接无视。
任期编号相同时，日志完整性高的Follow会拒绝投票给日志完整性低的Candidate&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;做法就是RequestVote RPC也会包含Candidate自己最后一个log entry的index和term，如果收到RequestRPC的节点发现这个Candidate最后一个log的term小于自己的term，或者term相等的时候index小于自己的index，那么就不会投票给它。这一策略保证了Leader一定拥有最完整的log entries&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;可能会出现多个Candidate同时发起投票请求，这样的话瓜分选票会导致无法选出半数以上的票，不过Raft通过随机超时时间解决了这一问题，把超时时间都进行了分散。这里的超时时间有两种，一个是Follower和Leader维持的心跳超时，一个是等待选举超时的时间间隔。&lt;/p&gt;
&lt;p&gt;当然还有可能出现的极限情况，比如说刚好两个Candidate各拿到了一半的票，那么陷入阻塞，此时这两个Candidate还会有随机timeout，如果时间过了就重新发送RequestVote&lt;/p&gt;
&lt;p&gt;几个注意的点：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;只有日志最完整的节点才能当Leader，Raft中，日志必须是连续的&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;日志复制&#34;&gt;日志复制&lt;/h3&gt;
&lt;p&gt;日志项包含指令、索引值、任期编号等。&lt;/p&gt;
&lt;p&gt;第一阶段，Leader通过日志复制AppendEntries，将日志项复制到集群的其他节点上，如果收到了大多数的“复制成功”消息，就把提交这条日志，并返回成功给客户端，否则会返回错误给客户端。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;一开始只是保存日志到本地，比如客户端提交一条&lt;code&gt;SET x = 5&lt;/code&gt;，Leader会先把这条写在日志里，不会修改x的值，等到多数节点返回成功之后才会执行这条指令，把x设为5。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;AppendEntries RPC在每个heartbeat都会发送&lt;/p&gt;
&lt;p&gt;Leader不需要发送消息来告知其他节点提交日志项，Leader的日志复制RPC和心跳包含了当前最大的将被提交的日志项。从而将二阶段简化为一阶段。&lt;/p&gt;
&lt;p&gt;具体的过程为：
&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1640193609/raft-1.jpg&#34; alt=&#34;raft-1&#34;&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;客户端提交一条写请求&lt;/li&gt;
&lt;li&gt;Leader将其存在本地日志上，然后给各个Followers发送日志复制AppendEntries RPC，&lt;/li&gt;
&lt;li&gt;如果有多数的Follower返回成功，Leader就将日志进行提交&lt;/li&gt;
&lt;li&gt;Leader将执行的结果返回给客户端&lt;/li&gt;
&lt;li&gt;之后如果Follower收到新的日志复制RPC或心跳，发现自己有日志项没提交，就进行提交&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;日志一致性的保证：
Leader的日志必然是完整的，以Leader的日志为准来协调各个节点的日志。&lt;/p&gt;
&lt;p&gt;首先通过AppendEntries RPC的一致性检查来找到自己与Follower相同日志项的最大索引值，之前的日志Follower和Leader一致，之后的就不一致了，然后Leader强制Follower覆盖不一致日志。&lt;/p&gt;
&lt;p&gt;引入两个变量：
PrevLogEntry：当前要复制的日志项的前一项的索引值，下面例子中为7
PrevLogTerm：当前要复制的日志项的前一项的任期编号，下面例子中为4&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1640193609/raft-2.jpg&#34; alt=&#34;raft-2&#34;&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Leader发送AppendEntries RPC，包含当前任期编号4、PrevLogEntry=7、PrevLogTerm=4，&lt;/li&gt;
&lt;li&gt;Follower发现自己的索引中没有这一条，返回Failure&lt;/li&gt;
&lt;li&gt;Leader递减要复制的日志项的索引，发送PrevLogEntry=6、PrevLogTerm=3&lt;/li&gt;
&lt;li&gt;Follower能在本地日志找到这一项，返回Success&lt;/li&gt;
&lt;li&gt;Leader知道了自己与该Follower的相同日志的最大索引，复制并更新覆盖索引值之后的日志项。&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;为什么要上一条？因为这一条的话刚写，必然不一样，如果Follower一直和Leader一致，Follower是有Leader的上一条的，但是必然没有Leader新的一条，所以Leader如果从最新的一条发RPC，每一个节点都必然返回Failure，然后递减，非常浪费RPC。
由于大部分节点是能同步日志的，所以第一次都会返回Success，然后Leader把新的一条复制过去即可，对于第一次Failure的个别节点，才会递减找到相同的最大索引值。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;成员变更&#34;&gt;成员变更&lt;/h3&gt;
&lt;p&gt;在成员进行变更的时候，如何避免出现大于一个的Leader？
比如出现了分区，节点被分为了多个簇，簇与簇之间无法沟通，那么每个簇内都会有一个Leader。&lt;/p&gt;
&lt;p&gt;如果只是为了解决不出现多个Leader的情况，最暴力的方式就是节点全部关闭然后再重新启动，这样投票只会有一个Leader，但是这段时间系统会瘫痪，明显不合理。
最常用的方法是单节点变更，也就是每次只变更一个节点。&lt;/p&gt;
&lt;p&gt;比如当前集群配置为[A, B, C]，现在往里面加入[D, E]，一个一个加，先加D进去：
首先Leader向D同步所有数据，然后Leader更新自己的配置为[A,B,C,D]，将包含新配置的日志项提交到本地状态机，完成单节点变更，之后E加入也一样。
通过单节点变更，可以保证系统只有一个Leader。&lt;/p&gt;
&lt;p&gt;可以看一下Raft作者讲的：
&lt;a href=&#34;https://www.youtube.com/watch?v=vYp4LYbnnW8&#34;&gt;https://www.youtube.com/watch?v=vYp4LYbnnW8&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;p&gt;以这张图进行总结：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1640193631/%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95-1.png&#34; alt=&#34;共识算法-1&#34;&gt;&lt;/p&gt;
&lt;p&gt;对于上述共识算法进行比较：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Backup，简单备份&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;比如mac的time machine。
首先对于Consistency一致性，是无法保证的，一旦改变当前的文件，备份的旧版本和目前的会不一致。
Transaction事务也只能是weak。
Latency（时延）低、Throuput（吞吐量）高，因为读写的时候不需要运行协议，直接读取即可。
Data loss，如果没备份完，系统失效了，那最新的资料会遗失。
Failover 故障恢复，系统恢复的这段时间系统是不能工作的。&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;Master/Salve 主从模式&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;读写请求都在master上进行，master将更新 的数据写到slave上。类似Dropbox。&lt;/p&gt;
&lt;p&gt;Consistency：可以实现最终一致性
Transactions：Master支持完整事务
Latency、Throuput：读写的时候都直接在master上完成，所以低时延、高吞吐。
Data loss：可能造成数据丢失
Failover：恢复的时候slave还是可以提供read&lt;/p&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;Master/Master&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Leaderless模式，每一个节点都可以接受读写请求。比如DynamoDB。&lt;/p&gt;
&lt;p&gt;Consistency：可以实现最终一致性
Transactions：只能本地支持
Latency、Throuput：低时延、高吞吐。
Data loss：可能造成数据丢失
Failover：仍能正常运作&lt;/p&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;2PC&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;二阶段模式&lt;/p&gt;
&lt;p&gt;Consistency：强一致性
Transactions：支持完整事务
Latency、Throuput：因为每次都需要两阶段，比较差
Data loss：只要写入后资料达成一致就不会丢失
Failover：仍能正常运作&lt;/p&gt;
&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;Paxos &amp;amp; Raft&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;虽然表中没有raft，实际上raft和paxos也差不多。
Paxos可以认为是优化2PC之后的最优解。&lt;/p&gt;
&lt;p&gt;Consistency：强一致性
Transactions：支持完整事务
Latency、Throuput：需要半数达成一致，相对差一点
Dataloss：只要写入后资料达成一致就不会丢失
Failover：只要有半数的节点存活就可以正常运行。&lt;/p&gt;
&lt;p&gt;参考：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://ithelp.ithome.com.tw/users/20121042/ironman/2792&#34;&gt;https://ithelp.ithome.com.tw/users/20121042/ironman/2792&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://time.geekbang.org/column/intro/100046101&#34;&gt;https://time.geekbang.org/column/intro/100046101&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://yichengme.site/categories/%E7%90%86%E8%AE%BA/" term="理论" label="理论" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://yichengme.site/tags/%E5%88%86%E5%B8%83%E5%BC%8F/" term="分布式" label="分布式" />
                            
                        
                            
                            
                            
                                <category scheme="https://yichengme.site/tags/%E7%B2%BE%E9%80%89/" term="精选" label="精选" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">分布式系统（一）：CAP及基础理论</title>
            <link rel="alternate" type="text/html" href="https://yichengme.site/posts/distribution-system-1/" />
            <id>https://yichengme.site/posts/distribution-system-1/</id>
            <updated>2022-02-08T17:27:00&#43;08:00</updated>
            <published>2021-11-19T00:21:18&#43;08:00</published>
            <author>
                    <name>王毅诚</name>
                    <uri>https://yichengme.site/</uri>
                    <email>engine74396@gmail.com</email>
                    </author>
            <rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">ACID、BASE、2PC/3PC ACID 在讲ACID之前，先讲本地事务，事务最早在数据库等课程中就接触过，简单来说，事务提供一种“要么什么也不做，要么全做完”的机制……</summary>
            
                <content type="html">&lt;h2 id=&#34;acidbase2pc3pc&#34;&gt;ACID、BASE、2PC/3PC&lt;/h2&gt;
&lt;h3 id=&#34;acid&#34;&gt;ACID&lt;/h3&gt;
&lt;p&gt;在讲ACID之前，先讲本地事务，事务最早在数据库等课程中就接触过，简单来说，事务提供一种“要么什么也不做，要么全做完”的机制。&lt;/p&gt;
&lt;p&gt;ACID特性是数据库事务的基本特征，包括：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Atomicity 原子性&lt;/li&gt;
&lt;li&gt;Consistency 一致性&lt;/li&gt;
&lt;li&gt;Isolation 隔离性&lt;/li&gt;
&lt;li&gt;Durability 持久性&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;合称就是ACID（在英语中正好是酸的意思，之后的BASE碱也与之对应）&lt;/p&gt;
&lt;p&gt;然而分布式事务和本地事务不同，假设有一个操作需要多个机器上执行，要么都执行，要么都不执行。
要保持分布式事务的ACID，方法有二阶段提交协议和TCC。&lt;/p&gt;
&lt;h3 id=&#34;2pc二阶段提交协议&#34;&gt;2PC二阶段提交协议&lt;/h3&gt;
&lt;p&gt;一个事务跨越多个节点，成为分布式事务，为了保持ACID，需要引入一个协调者的角色来统一掌控所有节点的结果。&lt;/p&gt;
&lt;p&gt;整个过程被分为两个阶段：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;准备阶段（投票）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;协调者给每个参与者发送Prepare信息，每个参与者有两种选择：
①返回失败
②本地执行事务返回成功，但不提交。询问之后的所有事务操作都记log，以便之后的恢复。&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;提交阶段（执行）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;如果协调者收到了失败或者超时，就直接给每个参与者发送回滚消息，否则就发送提交（commit）消息。
参与者如果收到提交消息，就提交事务，并释放资源和锁。如果收到回滚消息，就回滚事务，并释放资源和锁。&lt;/p&gt;
&lt;p&gt;二阶段提交协议的缺点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;同步阻塞，从投票开始到提交完成的这段时间，所用的资源被锁死&lt;/li&gt;
&lt;li&gt;单点故障，如果协调者故障了，就会一直阻塞&lt;/li&gt;
&lt;li&gt;数据不一致，第二阶段发送commit时可能部分节点因为故障收不到，导致只有一部分执行了commit。
等&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;之后有提出三阶段协议3PC，对二阶段协议进行了改进，然而由于增加了通信成本，实际用的并不多，就不细讲。&lt;/p&gt;
&lt;h3 id=&#34;tcctry-confirm-cancel&#34;&gt;TCC（Try-Confirm-Cancel）&lt;/h3&gt;
&lt;p&gt;TCC是一个业务层面的协议，需要在业务代码中编写，包含了预留、确认或撤销三个阶段。
核心思想是针对每个操作都要注册一个对其对应的确认操作和补偿操作。
首先是try阶段，先通知各个节点的将要进行的操作。
如果try阶段的回复都是ok，就执行确认操作，通知各个节点要执行操作；如果try阶段有错误或者超时，就执行撤销操作，&lt;/p&gt;
&lt;p&gt;可以说ACID是CAP一致性的边界，也就是最强的一致性。&lt;/p&gt;
&lt;h3 id=&#34;base&#34;&gt;BASE&lt;/h3&gt;
&lt;p&gt;BASE则是追求可用性，是CAP中AP的拓展。&lt;/p&gt;
&lt;p&gt;BASE的核心是基本可用（Basically Available）和最终一致性（Eventually Consistent）&lt;/p&gt;
&lt;p&gt;比如遇到峰值，可以用四板斧解决：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;流量削峰，将访问请求错开，比如多个秒杀商品放在不同的时间开始&lt;/li&gt;
&lt;li&gt;延迟请求，比如买火车票抢票的时候等一段时间系统才处理&lt;/li&gt;
&lt;li&gt;体验降级，比如先用小图片代替原始图片&lt;/li&gt;
&lt;li&gt;过载保护，请求放入队列中排队处理，超时了就直接拒绝，队列满了之后就清除一定的请求。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;目的是在基本可用性上保持妥协，谁也不想牺牲这些服务，但是为了可用性必须这样。&lt;/p&gt;
&lt;p&gt;最终一致性是指所有数据副本在经过一段时间的同步之后，最终能保持一致性。
显示生活中，除了金融等对一致性要求极高的领域，它们会使用强一致性。绝大部分互联网系统都采用最终一致性。&lt;/p&gt;
&lt;p&gt;实现最终一致性的方式用的多的有以下几种：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;读时修复，查询数据的时候如果检测到不同的数据，系统自动修复&lt;/li&gt;
&lt;li&gt;写时修复，写失败的时候先将数据缓存下来，之后定时重传&lt;/li&gt;
&lt;li&gt;异步修复，最常用，通过定时对账来检测副本数据的一致性并修复&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;然而异步修复和读时修复的开销比较大，需要进行一致性对比，而写时修复的开销低。&lt;/p&gt;
&lt;p&gt;如果要设计分布式数据库的一致性的时候，可以采用自定义写一致级别（All、Quorum、One、All）来让用户自主选择业务所适合的一致性级别&lt;/p&gt;
&lt;p&gt;BASE通过牺牲强一致性来获得高可用性。&lt;/p&gt;
&lt;h2 id=&#34;cap&#34;&gt;CAP&lt;/h2&gt;
&lt;p&gt;分布式系统的最大难点之一就是维护各个节点之间的数据状态一致性。
需要通过数据库或者分布式缓存来维护数据的一致性。&lt;/p&gt;
&lt;p&gt;CAP是三个缩写的组合：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;C（Consistency）：数据一致性，分布式系统中，同一份数据可能存在于多个实例中，其中一份的修改必须同步到所有它的备份中。也就是说每一次必然能读到最新写入的数据，或者返回错误。&lt;/li&gt;
&lt;li&gt;A（Availability）：服务可用性，服务在接收到客户端请求时必须要给出响应。在高并发和部分结点宕机的情况下依然可以响应。也就是每一次必然会返回结果，但是不保证是最新的正确的。&lt;/li&gt;
&lt;li&gt;P（Partition tolerance）：分区容忍性，由于网络的不可靠性，位于不同网络分区的结点可能会通信失败，如果能容忍这种情况，那么就满足分区容忍性。也就是说出现问题能够容忍。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;一个分布式系统不可能同时满足这三个基本需求，最多只能满足两项。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;满足CA&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;也就是必然一致而且能够返回正确结果，这样是不存在的，其实就是单Server，不叫分布式系统。&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;满足CP&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;牺牲A，只要系统中有一个Server没更新完，就返回错误，否则就返回正确的最新的值。&lt;/p&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;满足AP&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;牺牲C，也就是只要Server接收到请求就返回目前的值，但是不能保证一定是最新的正确的值。&lt;/p&gt;
&lt;p&gt;分布式系统必须满足分区容忍性，也就是只能从A和P中进行取舍，数据一致性和服务可用性只能满足一个。当然实际情况不可能只顾一个而完全放弃另一个，而是在主要关心一个的前提下尽量满足另一个。&lt;/p&gt;
&lt;p&gt;比较成熟的服务注册与发现有以下几个：Consul、Etcd、Zookeeper、Eureka&lt;/p&gt;
&lt;p&gt;其中Consul、Etcd、Zookeeper满足了CP，而Eureka满足了AP。&lt;/p&gt;
&lt;h2 id=&#34;一致化模型consistency-model&#34;&gt;一致化模型Consistency Model&lt;/h2&gt;
&lt;p&gt;对Consistency的不同程度的要求也衍生出了多种不同的等级模型。根据不同的情况采取不同的模型。&lt;/p&gt;
&lt;p&gt;假设有一场球赛，记分员负责将分数写入主Server，然后会将操作复制到各个replica server，读取分数的话可能是任意一个server。&lt;/p&gt;
&lt;p&gt;k=0,1分别代表主队和客队，如果主队得了一分，记分员操作是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;v = get(k)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;set(k, v+1)&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1640193245/cap-2.png&#34; alt=&#34;cap-2&#34;&gt;&lt;/p&gt;
&lt;p&gt;假设目前比分是2:5&lt;/p&gt;
&lt;h3 id=&#34;strong-consistency&#34;&gt;Strong Consistency&lt;/h3&gt;
&lt;p&gt;对于任何一个人，读到的一定是最新的&lt;/p&gt;
&lt;h3 id=&#34;eventual-consistency&#34;&gt;Eventual Consistency&lt;/h3&gt;
&lt;p&gt;只把结果给其他Server，只能保证最后的时刻会更新到正确的最终值，但是之前读到任何小于结果的得分都有可能，甚至是完全没出现过的得分，比如2:0&lt;/p&gt;
&lt;h3 id=&#34;consistent-prefix&#34;&gt;Consistent Prefix&lt;/h3&gt;
&lt;p&gt;连同操作一起给其他Server，从而保证读到的一定是比赛中的某个比分，历史发生过。&lt;/p&gt;
&lt;h3 id=&#34;bounded-staleness&#34;&gt;Bounded Staleness&lt;/h3&gt;
&lt;p&gt;保证读到的一定是t以内的结果。Bounded=0则为Strong Consistency。Bounded=无穷则为Eventual Consistency。&lt;/p&gt;
&lt;h3 id=&#34;monotonic-reads&#34;&gt;Monotonic Reads&lt;/h3&gt;
&lt;p&gt;可能返回任何结果，但是接下来会持续从同一个replica server中读取，保证每一次都至少会比之前的值新。&lt;/p&gt;
&lt;h3 id=&#34;read-my-writes&#34;&gt;Read My Writes&lt;/h3&gt;
&lt;p&gt;如果某个client对Server进行了set操作，那么之后的get必然是set的值。&lt;/p&gt;
&lt;p&gt;不同的角色，要求的系统模型不一样。
记分员：只有他会写入系统，用Read My Writes
裁判：只能Strong Consistency
报分员：保证是历史正确比分，然后每一次至少比上次新，Consistent Prefix+Monotonic Reads
记者：Bounded Staleness就可以，多等点时间
观众：无所谓，Eventual Consistency都行&lt;/p&gt;
&lt;p&gt;银行的系统必然是Strong Consistency，只能最新。而DNS只要是Eventual Consistency就可以，因为需要快速返回结果，不是最新的也可以接受。&lt;/p&gt;
&lt;h2 id=&#34;quorum-system&#34;&gt;Quorum System&lt;/h2&gt;
&lt;p&gt;Quorum System随着Amazon与2007年发表的&lt;code&gt;Dynamo: Amazon’s Highly Available Key-value Store&lt;/code&gt;论文而提出，这篇论文是NoSQL的代表之作。DynamoDB是一个NoSQL数据库，支持键值和文档数据结构，具有Strongly Consistent和Eventually Consistent。&lt;/p&gt;
&lt;p&gt;之前都是往一个Leader Server里写入，然后复制到replica server里，而我们更需要的是写入的时候任何一个Server都可以，读取的时候也是任何一个Server都可以。
也就是Leaderless Replication&lt;/p&gt;
&lt;p&gt;但是这样做的问题在于，如果两个写入操作的时间比较靠近，很可能出现对于不同的服务器而言，指令到达的时刻顺序不一致，从而错误。&lt;/p&gt;
&lt;p&gt;一种方法是每次写入都加锁，也就是去抢每个replicas server的锁，直到都写完了才释放所有的锁，让下一个写入进入。但是这样的话过于严格，效率低下。&lt;/p&gt;
&lt;p&gt;把条件放松一些。
对于写入操作，当一个client取得w个replicas的Lock才被允许写入。
取得R个replicas的Lock才被允许读。
写入时搭配timestamp。&lt;/p&gt;
&lt;p&gt;只要W+W&amp;gt;N就可以防止同时写的发生，保证不会出现最新的值不明确的情况。这个不解释。&lt;/p&gt;
&lt;p&gt;只要W+R&amp;gt;N就可以防止同时读写的发生，保证不会出现读取的值不是最新值的情况。配合timestamp之后，根据抽屉理论，读的时候至少会读到一台最新的server，从而根据timestamp可以找出它。&lt;/p&gt;
&lt;p&gt;通过Quorum System，可以不必设置primary server、replica server的形式，直接对任一server进行读写，仍然能保证Strong Consistency。&lt;/p&gt;
&lt;p&gt;这样的话，通过使用DynamoDB，Amazon会在世界各个地方的数据中心存放你的数据，进行备份，也能通过local replica进行加速。&lt;/p&gt;
&lt;h3 id=&#34;read-repair和anti-entropy&#34;&gt;Read-Repair和Anti-Entropy&lt;/h3&gt;
&lt;p&gt;如果说有几个节点瘫痪了，导致每个都无法拿到超过一半的锁。&lt;/p&gt;
&lt;p&gt;Read-Repair就是在读取的时候不仅通过timestamp拿到最新的结果，还顺便将最新的结果写回其他的server里去。这种适用于频繁读取的情况。&lt;/p&gt;
&lt;p&gt;另一个方法是Anti-Entropy，也就是单独创建一个process，通过检查replica的版本并将所有server都同步成最新的。适用于读取不频繁的情况。&lt;/p&gt;
&lt;h3 id=&#34;hinted-handoff&#34;&gt;Hinted Handoff&lt;/h3&gt;
&lt;p&gt;故障的server恢复之后，系统会写回这个server，这种做法叫Hinted Handoff。
写失败的请求会缓存到本地硬盘上，并周期性的尝试重传。&lt;/p&gt;
&lt;h3 id=&#34;quorum-nwr&#34;&gt;Quorum NWR&lt;/h3&gt;
&lt;p&gt;对于AP系统，可以保证最终一致性但是无法保证强一致性。如果想满足强一致性，可以借助Quorum NWR。&lt;/p&gt;
&lt;p&gt;Quorum NWR可以根据业务的特点，调整一致性级别。&lt;/p&gt;
&lt;p&gt;三个要素：N、W、R&lt;/p&gt;
&lt;p&gt;N：复制因子，也就是一个集群中，数据有多少个副本，当然不同的数据可能有不同的副本数
W：写一致性级别，成功完成W个副本更新，才完成写操作
R：读一致性级别，读一个数据对象需要读R个副本&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;W + R &amp;gt; N：不会出现并行读写，一定能读到最新值&lt;/strong&gt;
W + W &amp;gt; N：不会出现并行写
W + W &amp;lt;= N：可能出现不一致
W + R &amp;lt;= N：可能会读不到最新的值
R + R &amp;gt; N：&lt;/p&gt;
&lt;h2 id=&#34;分布式系统的时间&#34;&gt;分布式系统的时间&lt;/h2&gt;
&lt;p&gt;通常会采用W+W&amp;lt;=N来尽量保证Availablity，这种情况下如何规避并行写导致的不一致呢。&lt;/p&gt;
&lt;p&gt;一个方式就是要了解两个指令在发出时的先后顺序，而不是到达时的顺序，从而保证一致性。看起来通过发出信号时就附加timestamp可以解决问题，看起来每台机器的时间是一样的，然而实际上并不一定。&lt;/p&gt;
&lt;p&gt;由于每台机器自身的时间并不一定准确，甚至可能会出现接受到信息的timestamp比机器当前时间还要晚的情况（收到来自“未来”的消息），这样就很离谱，明显不合理。&lt;/p&gt;
&lt;h3 id=&#34;lamport-logical-clock&#34;&gt;Lamport Logical Clock&lt;/h3&gt;
&lt;p&gt;在消息里夹带一个timestamp，但是在传递的时候，每个结点接受到timestamp后，会比较自身时间与timestamp的大小，然后选择最大的那个置为新的timestamp，从而保证一定递增。收到的消息的timestamp比本身时间还大的话，就将自己的时间改为timestamp的时间。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;每个参与者最开始都保存一个timestamp=0&lt;/li&gt;
&lt;li&gt;如果在本地发生，timestamp+1&lt;/li&gt;
&lt;li&gt;如果传递这个消息，timestamp+1，然后传递时附带该timestamp&lt;/li&gt;
&lt;li&gt;如果接受这个消息，timestamp = Max(本地Clock, 消息timestamp) + 1&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;（Lamport发明了Latex）&lt;/p&gt;
&lt;h3 id=&#34;vector-clock&#34;&gt;Vector Clock&lt;/h3&gt;
&lt;p&gt;Lamport timestamp会显示两个先后的事件有因果关系，但是实际逻辑上并不一定，可能只是同时平行发生。&lt;/p&gt;
&lt;p&gt;对于N个Node的系统，Vector Clock让每个Node都存储一个长度为N的timestamp vector&lt;/p&gt;
&lt;p&gt;对于$Node_i$而言，存储$Vector_i = {t_0, t_1, ..., t_n}$&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;初始化每个Node的vector中的每个元素都为0&lt;/li&gt;
&lt;li&gt;$Node_i$发生一个事件，$V_i[t_i]+1$&lt;/li&gt;
&lt;li&gt;$Node_i$发生一个发送事件，$V_i[t_i]+1$，并夹带这个vector&lt;/li&gt;
&lt;li&gt;$Node_j$发生一个接受事件，$V_j[t_i] = V_i[t_i]$、$V_j[t_j] = Max(V_j[t_j],V_i[t_i]) + 1$&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;参考：https://ithelp.ithome.com.tw/users/20121042/ironman/2792&lt;/p&gt;
</content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://yichengme.site/categories/%E7%90%86%E8%AE%BA/" term="理论" label="理论" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://yichengme.site/tags/%E5%88%86%E5%B8%83%E5%BC%8F/" term="分布式" label="分布式" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">Google三驾马车（三）—— Bigtable</title>
            <link rel="alternate" type="text/html" href="https://yichengme.site/posts/bigtable/" />
            <id>https://yichengme.site/posts/bigtable/</id>
            <updated>2022-02-08T17:27:00&#43;08:00</updated>
            <published>2021-10-27T00:21:18&#43;08:00</published>
            <author>
                    <name>王毅诚</name>
                    <uri>https://yichengme.site/</uri>
                    <email>engine74396@gmail.com</email>
                    </author>
            <rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">介绍 为什么需要Bigtable？ 需要一个集群支持海量的随机读写，需要支持到每秒百万级别的随机读写。在Bigtable没出之前，使用MySQL集群可以解决一些问题……</summary>
            
                <content type="html">&lt;h2 id=&#34;介绍&#34;&gt;介绍&lt;/h2&gt;
&lt;p&gt;为什么需要Bigtable？
需要一个集群支持海量的随机读写，需要支持到每秒百万级别的随机读写。在Bigtable没出之前，使用MySQL集群可以解决一些问题，然而一方面会放弃关系型数据库的很多特征，比如外键约束、跨行跨表的事务等。一方面在扩容的时候不得不翻倍扩容，非常浪费。缩减服务器也非常麻烦。另外，在每次故障恢复的时候也需要人工介入。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1640192906/bigtable-0.png&#34; alt=&#34;bigtable-0&#34;&gt;&lt;/p&gt;
&lt;p&gt;希望的伸缩性是可以随机增加或者去掉人任何数量的服务器，并且进行这些操作时不会使服务暂停。&lt;/p&gt;
&lt;p&gt;Bigtable建立在GFS的架构之上，是一个管理结构化数据的分布式存储系统，可以拓展到非常大的规模，比如跨越数千服务器的PB级别的数据。
Google已经将其用在了很多内部产品中，Bigtable为其提供了一套高性能的可灵活拓展的解决方案。&lt;/p&gt;
&lt;p&gt;在很多方面，Bigtable像是数据库，但相比于以往的系统，Bigtable提供了不一样的接口。它不支持完整的关系型数据模型。可以使用任意字符的行列名对数据进行索引，Bigtable将数据都视为未解释的字符串。&lt;/p&gt;
&lt;p&gt;当然Bigtable也有缺点，一个是放弃了关系模型，不支持SQL；一个是放弃了跨行的事务，只支持单行的事务模型。&lt;/p&gt;
&lt;p&gt;Bigtable的解决方法是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;将存储层搭建在GFS上，通过单Master调度多Tablets的形式，使得集群容易维护，伸缩性好&lt;/li&gt;
&lt;li&gt;通过MenTable+SSTable的底层文件格式，解决高速随机读写的问题&lt;/li&gt;
&lt;li&gt;通过Chubby分布式锁解决一致性的问题&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;数据模型&#34;&gt;数据模型&lt;/h2&gt;
&lt;p&gt;Bigtable是一个稀疏的、分布式的永久存储的多维排序map，这个map通过row key、column key和timestamp进行索引，每个值都是一个未解释的字符串。&lt;/p&gt;
&lt;p&gt;(row: string, column: string, time: int64) -&amp;gt; string&lt;/p&gt;
&lt;p&gt;下图是一个存储网页的table&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;row是url的倒转，比如www.google.com会存为com.google.www，这样的目的是前面的www大家都一样，而且子域名就会主域名靠一起。&lt;/li&gt;
&lt;li&gt;有多列，其中&lt;code&gt;contents:&lt;/code&gt;列存储网页html内容。&lt;code&gt;anchor:&lt;/code&gt;列存储指向这个页面的anchor文字，比如cnnsi.com和my.look.ca有指向www.cnn.com的anchor，就如下图所示存储。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1640192906/bigtable-1.png&#34; alt=&#34;bigtable-1&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;rows&#34;&gt;Rows&lt;/h3&gt;
&lt;p&gt;行key是表的主键，可以是任意字符串，最大为64kb，在单行的读写都是原子的。
由于读写总是通过行键，这样的数据库也叫做KV数据库。
Bigtable按行key对数据进行排序，行范围动态分区，每个行的范围被称为tablet，是分布式和负载均衡的单位。&lt;/p&gt;
&lt;h3 id=&#34;column-families-列族&#34;&gt;Column Families 列族&lt;/h3&gt;
&lt;p&gt;每一行的数据需要指定列族，每个列族下不需要指定列，每个数据都可以有自己的列，每一行的列可以不一样。这也就是为什么说Bigtable是稀疏的表：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1640192908/bigtable-2.png&#34; alt=&#34;bigtable-2&#34;&gt;&lt;/p&gt;
&lt;p&gt;列key被分组到了一个集合里，被称为column families，每个column families里的应当是相同类型。必须先创建column families，才能使用列key存储数据。
列key通过&lt;code&gt;family:qualifier&lt;/code&gt;命名。比如存储web的表可以用language当做family，另一种是可以用anchor来当做family，每个列key是一个anchor，qualifier是指向该url的网址，内容是链接文本。
访问控制和硬盘内存的记录都是在列family层级下进行的。
比如Bigtable的开源实现HBase，每一个列族的数据存在同一个HFile文件下。&lt;/p&gt;
&lt;h3 id=&#34;timestamp&#34;&gt;Timestamp&lt;/h3&gt;
&lt;p&gt;Bigtable的每个单元格可以包含相同数据的多个版本，不同的版本通过时间戳进行索引。Bigtable的时间戳是64位的整数。不同版本以递减的形式存储，以便可以首先读取最新版本。&lt;/p&gt;
&lt;p&gt;为了防止变得过于繁重，可以指定个数或过期时间，之前的版本被gc。&lt;/p&gt;
&lt;h2 id=&#34;api&#34;&gt;API&lt;/h2&gt;
&lt;p&gt;Bigtable的API包括创建、删除表和列族，以及修改簇、表、列族元数据等。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;9
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-C++&#34; data-lang=&#34;C++&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// Open the table
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Table&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;T&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;OpenOrDie&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;/bigtable/web/webtable&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;

&lt;span class=&#34;c1&#34;&gt;// Write a new anchor and delete an old anchor
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;RowMutation&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;r1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;T&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;com.cnn.www&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;r1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Set&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;anchor:www.c-span.org&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;CNN&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;r1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Delete&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;anchor:www.abc.com&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;Operation&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;op&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;Apply&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;op&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;r1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-C++&#34; data-lang=&#34;C++&#34;&gt;&lt;span class=&#34;n&#34;&gt;Scanner&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;scanner&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;T&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;ScanStream&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;stream&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;stream&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;scanner&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;FetchColumnFamily&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;anchor&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;stream&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;SetReturnAllVersions&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;scanner&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Lookup&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;com.cnn.www&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;stream&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Done&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;stream&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Next&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;())&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;n&#34;&gt;printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;%s %s %lld %s&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\n&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
  &lt;span class=&#34;n&#34;&gt;scanner&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;RowName&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(),&lt;/span&gt;
  &lt;span class=&#34;n&#34;&gt;stream&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ColumnName&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(),&lt;/span&gt;
  &lt;span class=&#34;n&#34;&gt;stream&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;MicroTimestamp&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(),&lt;/span&gt;
  &lt;span class=&#34;n&#34;&gt;stream&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Value&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;());&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h2 id=&#34;构建块&#34;&gt;构建块&lt;/h2&gt;
&lt;p&gt;Bigtable使用GFS存储日志和数据文件，&lt;code&gt;SSTable&lt;/code&gt;用于存储Bigtable数据，每个SSTable包含一个块序列（每个块64kb），并且SSTable可以被完全的映射到内存中，不需要接触磁盘就可以执行查找和扫描。&lt;/p&gt;
&lt;p&gt;Bigtable依赖于分布式锁Chubby，Chubby包含了5个副本，其中一个被选为master并提供request服务。我后面会专门再讲一下Chubby。&lt;/p&gt;
&lt;p&gt;Bigtable通过Chubby完成以下任务：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;确保每个时刻只有一个master&lt;/li&gt;
&lt;li&gt;存储Bigtable数据的引导位置&lt;/li&gt;
&lt;li&gt;存储Bigtable每个表的列族信息&lt;/li&gt;
&lt;li&gt;存储访问控制列表ACL&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;如果Chubby不可用，那么Bigtable也将不可用&lt;/p&gt;
&lt;h2 id=&#34;实现&#34;&gt;实现&lt;/h2&gt;
&lt;p&gt;Bigtable包含三个主要组件：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;链接到每个客户端的库&lt;/li&gt;
&lt;li&gt;一个master服务器&lt;/li&gt;
&lt;li&gt;多个tablet服务器&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;tablet可以动态的增加删除。&lt;/p&gt;
&lt;p&gt;master的职责：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;负责将tablet分配给tablet服务器&lt;/li&gt;
&lt;li&gt;检测tablet的添加和过期&lt;/li&gt;
&lt;li&gt;平衡Tablet server之间的负载&lt;/li&gt;
&lt;li&gt;对GFS的文件进行gc&lt;/li&gt;
&lt;li&gt;管理Table和列族的Schema变更&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;每个tablet服务器存储一组tablet（通常是10-1000个），&lt;/p&gt;
&lt;p&gt;Bigtable和Tablet Server都不进行数据的存储只负责在线业务，存储工作通过SSTable的数据格式写到GFS上。&lt;/p&gt;
&lt;h3 id=&#34;tablet位置&#34;&gt;Tablet位置&lt;/h3&gt;
&lt;p&gt;通过B+树存储tablet的位置&lt;/p&gt;
&lt;p&gt;定义了一张特殊的表Root tablet专门存放元数据，这个分区不会分裂，存的是元数据里其他Tablets的位置。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1640192904/bigtable-5.jpg&#34; alt=&#34;bigtable-5&#34;&gt;&lt;/p&gt;
&lt;p&gt;第一级存储在Chubby的文件，包含root tablet的位置，root包含metadata tablets，包含了其他所有tablet的位置。tablet不做分割，确保不超过三层。&lt;/p&gt;
&lt;p&gt;举个例子，客户端查询ECOMMERCE_ORDERS业务表行键是A20210101RST的某个记录，客户端查询的具体操作：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1640192906/bigtable-6.png&#34; alt=&#34;bigtable-6&#34;&gt;&lt;/p&gt;
&lt;p&gt;也就是说在具体查找数据之前需要三次网络请求来获得数据的具体位置。一般前几次的查询也会缓存起来，以减少请求次数。&lt;/p&gt;
&lt;p&gt;三层结构可以让Bigtable拓展到足够大，tablet大小限制为128MB，每条记录大约1KB，可以存$2^{34}$个Tablet，也就是160亿个Tablet。&lt;/p&gt;
&lt;p&gt;客户端不需要经过master，让设计更加高可用&lt;/p&gt;
&lt;h3 id=&#34;动态分区&#34;&gt;动态分区&lt;/h3&gt;
&lt;p&gt;Bigtable采用动态区间分区，通过自动去split的方式动态分区。
好比是往箱子里放书，按照书名的字母顺序，一旦箱子装满，就中间一分为二，将下面一半放到一个新的空箱子里去。
如果两个相邻的箱子都很空，就可以将其合并。
&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1640192909/bigtable-4.png&#34; alt=&#34;bigtable-4&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;sstable底层结构&#34;&gt;SSTable底层结构&lt;/h2&gt;
&lt;p&gt;Bigtable的写入数据的过程：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;tablet server先做数据验证，以及权限验证&lt;/li&gt;
&lt;li&gt;如果合法，就以追加写的形式顺序写到GFS&lt;/li&gt;
&lt;li&gt;写入成功后还会写到一张内存表MenTable中&lt;/li&gt;
&lt;li&gt;写入的数据快要超过阈值时，会将内存的MemTable冻结，创建一个新的MemTable，被冻结的MemTable会被转换为SSTable写入到GFS，然后从内存中释放掉。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Major Compaction机制，对SSTable进行合并，把数据压实在一起，比如只留下时间戳最近的三个版本的数据。
读取数据的时候，读取的是MemTable和SSTable的合并在一起的视图。
也就是说并没有直接的修改和删除操作，一旦写入就是不可变的，写入的是数据的一个新版本，后台会定时gc，通过合并SSTable来清楚过期和被删除的数据。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1640192906/bigtable-7.png&#34; alt=&#34;bigtable-7&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;p&gt;Bigtable包括四个组件：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;负责存储数据的GFS&lt;/li&gt;
&lt;li&gt;负责作为分布式锁和目录服务的Chubby&lt;/li&gt;
&lt;li&gt;复杂提供在线服务的Tablet Server&lt;/li&gt;
&lt;li&gt;复杂调度Tablet和调整负载的Master&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1640192908/bigtable-8.png&#34; alt=&#34;bigtable-8&#34;&gt;&lt;/p&gt;
</content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://yichengme.site/categories/%E7%AE%97%E6%B3%95/" term="算法" label="算法" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://yichengme.site/tags/bigtable/" term="Bigtable" label="Bigtable" />
                            
                        
                            
                            
                            
                                <category scheme="https://yichengme.site/tags/%E5%88%86%E5%B8%83%E5%BC%8F/" term="分布式" label="分布式" />
                            
                        
                            
                            
                            
                                <category scheme="https://yichengme.site/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/" term="大数据" label="大数据" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">Google三驾马车（二）—— MapReduce</title>
            <link rel="alternate" type="text/html" href="https://yichengme.site/posts/mapreduce/" />
            <id>https://yichengme.site/posts/mapreduce/</id>
            <updated>2022-02-08T17:27:00&#43;08:00</updated>
            <published>2021-10-18T20:21:18&#43;08:00</published>
            <author>
                    <name>王毅诚</name>
                    <uri>https://yichengme.site/</uri>
                    <email>engine74396@gmail.com</email>
                    </author>
            <rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">介绍 MapReduce是一个用于处理和生成大型数据集的编程模型和相关实现，它是一个分布式模型，通过一个Map函数将k/v对生存一组中间态的k/v对，然后通过一个……</summary>
            
                <content type="html">&lt;h2 id=&#34;介绍&#34;&gt;介绍&lt;/h2&gt;
&lt;p&gt;MapReduce是一个用于处理和生成大型数据集的编程模型和相关实现，它是一个分布式模型，通过一个Map函数将k/v对生存一组中间态的k/v对，然后通过一个reduce函数将所有的中间态k/v对进行聚合。
MapReduce运行在一个大型的商用机器集群上，比如可以在数千台机器上处理大量TB级别的数据。
实际上Google早已将其用于实际的任务，每天有超过1000个MapReduce任务在谷歌的集群上运行。&lt;/p&gt;
&lt;p&gt;面对百亿级别的爬虫数据、日志文件等，常规方法不可能做到时效性，只能采用分布式系统进行并行计算。&lt;/p&gt;
&lt;h2 id=&#34;编程模型&#34;&gt;编程模型&lt;/h2&gt;
&lt;p&gt;输入是一系列k/v对的set，输出也是一系列k/v对的set&lt;/p&gt;
&lt;p&gt;用户需要编写Map和Reduce这两个函数，其中Map函数通过输入pair来产生中间过程的k/v对
接下来会将Key为I的中间值传递给对应处理Key I的Reduce函数
Reduce函数接受一系列的Key为I的值，然后merge在一起，每次只有0或1
具体的见下面的例子。&lt;/p&gt;
&lt;h3 id=&#34;例子&#34;&gt;例子&lt;/h3&gt;
&lt;p&gt;输入文件首先分块，
需要一个Map函数，每个输入文件输入Map进行处理，每个都是并行的，产生对应的输出，输出是一个list形式的Key/Value的键值对。&lt;/p&gt;
&lt;p&gt;假设我们的功能是读取字符出现的次数。
假设输入为&amp;quot;abbac&amp;quot;，被拆成了三个文件，总共也就这三个Key。分别是&amp;quot;ab&amp;quot;,&amp;quot;b&amp;quot;,&amp;quot;ac&amp;quot;，并行输入进Map，三个输出分别为：
(a,1), (b,1)
(b,1)
(a,1), (c,1)&lt;/p&gt;
&lt;p&gt;然后进行reduce操作，对于每个Key，会传入reduce函数进行汇总，去统计每个Key的出现个数。这也是并行的。&lt;/p&gt;
&lt;p&gt;那么经过reduce操作之后，输出为：
(a, 2)
(b, 2)
(c, 1)&lt;/p&gt;
&lt;p&gt;完整的Job由一系列的MapTask和一系列的reduceTask组成。&lt;/p&gt;
&lt;p&gt;下面来说说对于统计字母的功能下，Map和Reduce这两个函数的结构：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-C++&#34; data-lang=&#34;C++&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// Map函数，k指明文件，v是文件内容
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Map&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;k&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;v&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;){&lt;/span&gt;
  &lt;span class=&#34;n&#34;&gt;split&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;v&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;to&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;words&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
  &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;each&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;word&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;w&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;emit&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;w&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;1&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
  &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-C++&#34; data-lang=&#34;C++&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// reduce函数，k是这个字母，v是包含这个字母的map数量
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;reduce&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;k&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;v&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;n&#34;&gt;emit&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;len&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;v&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;MapReduc和GFS都运行在一起，在并行进Map的时候，实际上避免了网络传输，中控通过某些方式能够知道该文件存在哪台主机里，然后在该主机调用Map本地操作，从而减少带宽传输限制。后面reduce只能通过网络。&lt;/p&gt;
&lt;p&gt;最开始是按行存储，然后按列存储，这个过程叫Shuffle，从Map服务器到Reduce服务器，这一过程很消耗网络。&lt;/p&gt;
&lt;h3 id=&#34;类型&#34;&gt;类型&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;map&lt;/code&gt;函数 输入是&lt;code&gt;(k1, v1)&lt;/code&gt;，输出是&lt;code&gt;list(k2, v2)&lt;/code&gt;
&lt;code&gt;reduce&lt;/code&gt;函数 输入是&lt;code&gt;(k2, list(v2))&lt;/code&gt;，输出是&lt;code&gt;list(v2)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;以统计词频为例，这里map的输入是(filename, fileContent)，输出是对于每一个单词为key的k/v列表，比如[&amp;quot;Apple&amp;quot;: 1, &amp;quot;Banana&amp;quot;: 1,...]。
这里reduce的输入就是一个单独单词的一系列值，比如&lt;code&gt;&amp;quot;Apple&amp;quot;, [1, 1, 1,...]&lt;/code&gt;，然后输出是该单词的词频。&lt;/p&gt;
&lt;h3 id=&#34;更多的例子&#34;&gt;更多的例子&lt;/h3&gt;
&lt;p&gt;除此之外还有很多适用于MapReduce的很好的例子。&lt;/p&gt;
&lt;h2 id=&#34;实现&#34;&gt;实现&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1640192780/mapreduce-1.png&#34; alt=&#34;mapreduce-1&#34;&gt;&lt;/p&gt;
&lt;p&gt;分割输入数据，分成M个子集，被调用分布到多台机器上并行处理。之后分割中间key形成R个片（比如通过&lt;code&gt;hash(key) mod R&lt;/code&gt;），reduce调用分布到各个机器上。&lt;/p&gt;
&lt;p&gt;具体步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;分割输入文件为M个片，每个片的大小约16-64M&lt;/li&gt;
&lt;li&gt;一个master，和多个worker，有M个map任务和R个reduce任务将被分配，管理者的一个任务是分配map或者reduce任务给一个空闲的worker&lt;/li&gt;
&lt;li&gt;被分配了map任务的worker需要做的是读取输入片的内容，分析出k/v对，传递给用户自定义的map函数，产生的中间k/v对缓存在内存中。&lt;/li&gt;
&lt;li&gt;缓存在内存中的k/v对通过分割函数写入R个区域，本地的缓存对的位置传送给master，然后master把这些位置传送给reduce worker。&lt;/li&gt;
&lt;li&gt;reduce worker通过远程调用来从map worker的磁盘上读取缓存的内容，reduce worker通过排序使得具有相同key的内容聚集在一起。如果中间数据比内存还大，就需要外排序。&lt;/li&gt;
&lt;li&gt;reduce worker迭代排过序的中间数据，对于每一个唯一的key，把key和相关的value传递给reduce函数，reduce函数的输出被添加到最终的输出文件中&lt;/li&gt;
&lt;li&gt;所有的map和reduce都完成之后，管理者唤醒用户程序，用户程序的MapReduce调用返回到用户代码&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;master的数据结构&#34;&gt;Master的数据结构&lt;/h3&gt;
&lt;p&gt;master首先会存储每个map任务和reduce任务的状态（空闲、进行中、完成）以及工作机器的标识。
master还会存储由map产生的中间文件的区域和大小，然后传给reduce的worker&lt;/p&gt;
&lt;h3 id=&#34;容错&#34;&gt;容错&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;worker故障&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;master会定期ping每个worker，如果一段时间内没有收到响应，master就会将该结点标记为failed。正在进行的map或者reduce更是会重设状态，被调给其他worker。
然而，这些worker已经完成的map任务也会重新设置为idle状态，将会调度给其他的worker，这是因为它们的输出会存在故障机器的本地磁盘上，不过已经完成的reduce任务不需要重新运行，因为它们会存在全局文件系统上。&lt;/p&gt;
&lt;p&gt;如果一个map任务在A worker上执行，然后A挂了，被调度给了B worker。所有的在做reduce的worker都会被通知到这个，然后读取对应的中间数据会从B读取。&lt;/p&gt;
&lt;p&gt;MapReduce对大规模的worker故障有弹性。&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;Master故障&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;master会定期将内部的数据结构写到checkpoints里，如果master挂了，可以很容易的从最后一个checkpoints开启一个新的副本。&lt;/p&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;失败时的Semantics&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;即使有故障，也能得到和没故障发生的情况下一样的输出。&lt;/p&gt;
&lt;p&gt;依赖于map和reduce任务提交的原子性&lt;/p&gt;
&lt;h3 id=&#34;本地&#34;&gt;本地&lt;/h3&gt;
&lt;p&gt;带宽是一种相对稀缺的资源，通过GFS存储在cluster的本地磁盘上。大部分输入数据会在本地读取，不消耗网络带宽。&lt;/p&gt;
&lt;h3 id=&#34;任务粒度&#34;&gt;任务粒度&lt;/h3&gt;
&lt;p&gt;map任务被分为了M个片，reduce任务被分为了R个片，M和R实际上会远高于实际的worker机器，&lt;/p&gt;
&lt;p&gt;master将做$O(M+R)$的任务调度，以及保存$O(M*N)$个状态。&lt;/p&gt;
&lt;h3 id=&#34;备份任务&#34;&gt;备份任务&lt;/h3&gt;
&lt;p&gt;有时候可能会出现某个任务运行过久导致严重影响整体性能，比如某个worker机器的磁盘坏了导致非常慢的运行，它依然响应服务器的心跳不能认为是failed，但是运行就是非常慢。
MapReduce有一个备份任务的机制，就是当MapReduce即将完成的时候，也就是大多数任务都做完了，那么就会去备份还没完成的任务，只要原始任务或者备份任务的其中一个做完了就可以。&lt;/p&gt;
&lt;h2 id=&#34;改良拓展性能表现与实验&#34;&gt;改良拓展、性能表现与实验&lt;/h2&gt;
&lt;p&gt;上述已经是一个基本的MapReduce的任务了，一些改进拓展、性能表现与实验就不详细说明了，日后可以研究。&lt;/p&gt;
</content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://yichengme.site/categories/%E7%AE%97%E6%B3%95/" term="算法" label="算法" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://yichengme.site/tags/mapreduce/" term="MapReduce" label="MapReduce" />
                            
                        
                            
                            
                            
                                <category scheme="https://yichengme.site/tags/%E5%88%86%E5%B8%83%E5%BC%8F/" term="分布式" label="分布式" />
                            
                        
                            
                            
                            
                                <category scheme="https://yichengme.site/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/" term="大数据" label="大数据" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">Google三驾马车（一）—— Google File System</title>
            <link rel="alternate" type="text/html" href="https://yichengme.site/posts/gfs/" />
            <id>https://yichengme.site/posts/gfs/</id>
            <updated>2022-02-08T17:27:00&#43;08:00</updated>
            <published>2021-10-11T18:00:18&#43;08:00</published>
            <author>
                    <name>王毅诚</name>
                    <uri>https://yichengme.site/</uri>
                    <email>engine74396@gmail.com</email>
                    </author>
            <rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">介绍 GFS，即Google File System，谷歌文件系统。 它是一种能够用于大型密集型数据的可拓展的分布式文件系统。（大型存储系统），它对于廉价硬件提供了容错机制；……</summary>
            
                <content type="html">&lt;h2 id=&#34;介绍&#34;&gt;介绍&lt;/h2&gt;
&lt;p&gt;GFS，即Google File System，谷歌文件系统。
它是一种能够用于大型密集型数据的可拓展的分布式文件系统。（大型存储系统），它对于廉价硬件提供了容错机制；对于大量客户的情况能有高表现。&lt;/p&gt;
&lt;p&gt;GFS的设计是由实际的应用程序负载和技术环境驱动的，与传统的文件系统的一些假设不一样。&lt;/p&gt;
&lt;h2 id=&#34;设计&#34;&gt;设计&lt;/h2&gt;
&lt;h3 id=&#34;一些假设&#34;&gt;一些假设&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;软硬件故障是常态而不是例外&lt;/li&gt;
&lt;li&gt;文件是巨大的（多GB级也是普遍的）&lt;/li&gt;
&lt;li&gt;负载包括大的流式读取和小的随机读取&lt;/li&gt;
&lt;li&gt;负载还包括大的顺序的append写入&lt;/li&gt;
&lt;li&gt;大多数文件是通过append而不是overwrite来改变的，一旦写入，就只能读取，而且是顺序读&lt;/li&gt;
&lt;li&gt;放宽了一致性，从而极大简化了文件系统&lt;/li&gt;
&lt;li&gt;引入了原子的追加写，可以并发的追加&lt;/li&gt;
&lt;li&gt;高的持续带宽比低延迟更重要&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;一般用append，GFS对其一致性有保证，最好不用write&lt;/p&gt;
&lt;h3 id=&#34;接口&#34;&gt;接口&lt;/h3&gt;
&lt;p&gt;接口方面支持通用的create、delte、open、close、read、write。并且还有snapshot和append操作。
snapshot以低成本创建文件或者目录的副本，append允许多个客户端并发的追加同一个文件，保证原子性。
对于实现多路合并以及生产者-消费者模型很有用。&lt;/p&gt;
&lt;h3 id=&#34;架构&#34;&gt;架构&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1640192564/gfs-1.png&#34; alt=&#34;gfs-1&#34;&gt;&lt;/p&gt;
&lt;p&gt;一个GFS集群由一个master结点和多个chunk sever构成，并被多个客户端访问。它们通常都是普通的Linux机器。&lt;/p&gt;
&lt;p&gt;GFS把文件切割为若干固定长度的Chunk块并存储，每个块的大小是64MB，在创建块时，对于每一个Chunk，master还会为其分配一个64位的全局唯一的Handle句柄。为了保证Chunk的可用性，每个块都会被复制到多个chunk server上，默认存储三个副本。&lt;/p&gt;
&lt;p&gt;master维护所有文件系统的元数据，包括namespace、访问控制信息、从文件到chunk的映射、以及块的当前位置。它还控制系统范围内的活动，比如chunk的租约管理、孤立chunk的gc、chunk server之间的chunk迁移。master定期与chunkserver维持心跳通信，给chunkserver指令以及接受它们的状态。客户端和chunkserver都不需要缓存文件数据，从而简化系统，唯一可能要缓存的可能就是客户机会缓存一下元数据。&lt;/p&gt;
&lt;h3 id=&#34;single-master&#34;&gt;Single Master&lt;/h3&gt;
&lt;p&gt;设立一个master可以极大的简化系统的设计，可以很方便地进行全局信息的管理。然而单一的master很容易成为系统的瓶颈，所以只能让其尽可能少的参与读写。客户端从来不从master中读写文件数据，而是向master询问它需要的文件在哪，然后访问这些chunkserver去进行文件交互。&lt;/p&gt;
&lt;p&gt;下面解释一下交互过程，首先客户端借助固定的块大小，将文件名和偏移量转换为块索引，然后向master发送包含文件名和块索引的请求，master返回一个chunk句柄和副本的位置。接下来客户端会向其中一个（往往是最近的）存储着该文件副本的chunkserver发送请求，之后对同一个chunkserver的交互不需要master的参与。事实上客户端通常一次会请求多个块。&lt;/p&gt;
&lt;h3 id=&#34;chunk-size&#34;&gt;Chunk Size&lt;/h3&gt;
&lt;p&gt;选择的是64MB，比典型文件系统的块大得多，相对于小的chunk size，更大的chunk size的优势在于：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;减少客户端请求的chunk数量，减少客户端与master的交互需求。&lt;/li&gt;
&lt;li&gt;大的chunk可以让客户端执行很多操作，通过较长时间与chunkserver的持续的tcp连接来减少网络开销&lt;/li&gt;
&lt;li&gt;减少了chunk的个数，从而减少了存储在master的元数据的大小&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;当然，大的chunk size也有缺点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;可能会出现更多客户端访问一个chunk从而导致这个chunk成为hot spots。一般来说还好，不过如果某个可执行文件被写入了某个chunk，然后在数百台机器上同时启动，那个chunkserver就很容易超载。一个解决方法是将可执行文件复制更多份，并使批队列系统错开启动时间。还有一个解决方法是允许客户机从其他客户机读取数据。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;metadata&#34;&gt;Metadata&lt;/h3&gt;
&lt;p&gt;元数据包含文件和chunk的namespace、从文件到块的映射、以及每个chunk副本的位置，所有的元数据都存储在master的内存中。前面两个也通过日志的方式存储在本地磁盘中，实现持久性存储，顺带也复制在远程机器上备份。这个主要是保证即使master崩溃了也不会出现不一致。
至于chunk副本的位置，master并不会持久地存储，而是在master启动的时候对每个chunkserver进行轮询，或者在新的chunkserver加入集群时询问。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;内存中的数据结构
元数据存储在内存中，所以访问起来很快。
master还会在后台周期性的扫描整个状态，用于实现gc、chunkserver故障时的重新复制、块迁移来平衡负载等。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;可能会认为说元数据存在master内存中，整个系统的容量会受到master内存的限制，实际上chunk由于比较大，个数不会那么多，master也只需要存每个chunk的不到64字节的元数据，所以还好。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;chunk位置
前面说了master通过启动时的轮询获得信息，并且还会保持一个心跳来监听各个chunkserver的状态。
由于集群很大，如果在master上持久化在本地存储chunk副本位置，之后变动会很多（改名、宕机、重启等），并且实际上chunkserver才是对chunk有着最终决定权，在master上维护一个一致性的视图是没有意义的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;操作日志
操作日志包含了元数据发生重大变化的历史记录，是GFS的核心。它是元数据的唯一持久性记录，也作为定义并发操作顺序的逻辑时间线。操作日志需要被可靠地存储。
如果系统崩了，master就会重新执行log来恢复GFS，所以log也不宜过大，以免启动时间过长。会先找到重载的checkpoint然后执行之后的日志记录。检查点是一种类似B树的紧凑形式，加快恢复速度。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;一致性模型&#34;&gt;一致性模型&lt;/h3&gt;
&lt;p&gt;GFS并不保持一个严格的一致性，而是保持一个相对宽松的一致性&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;GFS保证的
命名空间是原子的，保证操作日志是全局的顺序正确的。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;数据更改之后的文件区域的状态：&lt;/p&gt;
&lt;p&gt;文件数据更改之后，会定义一个region，其状态取决于变化的种类（write/append）、是否并行、成功还是失败。&lt;/p&gt;
&lt;p&gt;如果它是一致的，客户端会看到变化写入的内容。
如何区分已定义区域和未定义区域。&lt;/p&gt;
&lt;p&gt;在一次成功的顺序变化后，GFS会：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在chunk的所有副本上以相同的顺序应用这些变化&lt;/li&gt;
&lt;li&gt;使用chunk版本号来检测副本&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;应用程序应当append而不是write。&lt;/p&gt;
&lt;h2 id=&#34;系统交互&#34;&gt;系统交互&lt;/h2&gt;
&lt;p&gt;描述客户端、master、chunkserver如何进行交互，完成数据更改、原子追加和快照。&lt;/p&gt;
&lt;h3 id=&#34;租约和数据更改顺序&#34;&gt;租约和数据更改顺序&lt;/h3&gt;
&lt;p&gt;数据更改（mutations）就是改变chunk的内容或者元数据的操作，比如write或append。数据更改在chunk副本上执行。
使用租约（leases）来维持副本之间的一致的变化顺序。master会将租约授权给其中一个副本，称之为该chunk的主服务器（primary）。主服务器会为这个chunk的所有更改进行顺序排序，其余的所有副本都遵守这个顺序进行更改。
租约机制的目的也是减少master的管理开销，租约的初始时间是60s，不过主要chunk发生了改变，primary就可以向master请求拓展，这些请求被承载在心跳信息上。&lt;/p&gt;
&lt;p&gt;下图是写操作的控制流与详细的步骤
&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1640192564/gfs-2.png&#34; alt=&#34;gfs-2&#34;&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;客户端询问master哪个chunkserver持有当前chunk的租约，以及其他副本的位置。如果没有服务器有租约，master就选择一个副本服务器分给它租约&lt;/li&gt;
&lt;li&gt;服务器返回primary和副本chunkserver的位置，客户端把它们存在缓存中，如果未来短期内再次访问就不需要请求master。除非primary不可达或者primary告知客户端它没有租约了。&lt;/li&gt;
&lt;li&gt;客户端知道副本位置后，将数据push进所有的副本中，可以按照任何顺序。每个chunkserver将数据存储在一个内部的LRU缓存中&lt;/li&gt;
&lt;li&gt;一旦所有的副本都确认接受到了数据，客户端就向primary发送写请求，标识了之前push的数据，primary会分配序列号给这些mutations，提供必要的序列化&lt;/li&gt;
&lt;li&gt;primary将写请求转发给各个备用副本，每个备份副本按照序列号执行更改&lt;/li&gt;
&lt;li&gt;备份副本回复primary表示已经完成了操作&lt;/li&gt;
&lt;li&gt;primary响应客户端，任何遇到的错误也会报告&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;数据流&#34;&gt;数据流&lt;/h3&gt;
&lt;p&gt;数据流和控制流解耦，为了充分利用每台机器的带宽，数据被线性的沿着chunkserver链进行推送，而不是分布在拓扑网络中，这样每台机器的带宽就可以被充分利用，每台机器将数据转发到网络拓扑中“最近的”没有接收到它的机器。（感觉像Prim算法）&lt;/p&gt;
&lt;h3 id=&#34;原子追加&#34;&gt;原子追加&lt;/h3&gt;
&lt;p&gt;GFS提供了原子追加（atomic record appends）操作。
传统的写操作需要提供数据和偏移量，如果出现并行的情况就很可能会出现来自多个客户端的碎片。
在GFS中，客户端只提供数据，GFS会选择偏移量并将其返回给客户端，类似于Unix的&lt;code&gt;O_APPEND&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;大量使用record append，如果是传统的写操作，为了保持一致性就只能使用分布式锁，代价很昂贵。&lt;/p&gt;
&lt;h3 id=&#34;snapshot快照&#34;&gt;Snapshot快照&lt;/h3&gt;
&lt;p&gt;类似AFS，使用标准的copy-on-write技术实现快照。&lt;/p&gt;
&lt;h2 id=&#34;master操作&#34;&gt;Master操作&lt;/h2&gt;
&lt;p&gt;master的任务：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;执行所有namespace相关的操作&lt;/li&gt;
&lt;li&gt;管理系统的chunk副本以及与之相关的一些操作&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;namespace的管理和锁定&#34;&gt;namespace的管理和锁定&lt;/h3&gt;
&lt;p&gt;GFS没有传统文件系统的per-directory数据结构。也不支持alias。&lt;/p&gt;
&lt;h3 id=&#34;gc&#34;&gt;gc&lt;/h3&gt;
&lt;p&gt;文件被删除之后，不会立即回收资源，而是先重命名为包含删除时间戳的隐藏文件，如果隐藏文件存在超过三天，就删除它们。在此期间，这些文件可以被恢复。
内存元数据也会被删除，切断和所有chunk的联系，在和master的心跳中，chunkserver报告自己的chunks，master会返回不出现在namespace里的，chunkserver接受到后可以删掉这些chunk。&lt;/p&gt;
&lt;h2 id=&#34;容错性与诊断&#34;&gt;容错性与诊断&lt;/h2&gt;
&lt;h3 id=&#34;高可用性&#34;&gt;高可用性&lt;/h3&gt;
&lt;p&gt;通过两种简单而有效的策略来保持整个系统的高可用性:快速恢复和复制&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;快速恢复
master和chunkserver都可以在几秒内启动&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;chunk复制
默认是复制3份&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;master复制&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;操作日志和检查点被复制到多台机器上&lt;/p&gt;
</content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://yichengme.site/categories/%E7%AE%97%E6%B3%95/" term="算法" label="算法" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://yichengme.site/tags/gfs/" term="GFS" label="GFS" />
                            
                        
                            
                            
                            
                                <category scheme="https://yichengme.site/tags/%E5%88%86%E5%B8%83%E5%BC%8F/" term="分布式" label="分布式" />
                            
                        
                            
                            
                            
                                <category scheme="https://yichengme.site/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/" term="大数据" label="大数据" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">生存分析基础</title>
            <link rel="alternate" type="text/html" href="https://yichengme.site/posts/survival-analysis-basic/" />
            <id>https://yichengme.site/posts/survival-analysis-basic/</id>
            <updated>2022-02-08T17:27:00&#43;08:00</updated>
            <published>2020-12-23T15:23:00&#43;08:00</published>
            <author>
                    <name>王毅诚</name>
                    <uri>https://yichengme.site/</uri>
                    <email>engine74396@gmail.com</email>
                    </author>
            <rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">背景与简介 在生物医学、金融保险等领域，生存分析是一种很常见而且重要的方法。 生存分析主要用在癌症等疾病的研究中，比如对某种抗癌药物做临床试验，筛选一部分癌症患者，……</summary>
            
                <content type="html">&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1640248844/survival-analysis-0.png&#34; alt=&#34;survival-analysis-1&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;背景与简介&#34;&gt;背景与简介&lt;/h2&gt;
&lt;p&gt;在生物医学、金融保险等领域，生存分析是一种很常见而且重要的方法。&lt;/p&gt;
&lt;p&gt;生存分析主要用在癌症等疾病的研究中，比如对某种抗癌药物做临床试验，筛选一部分癌症患者，分为两组，一组服用该试验药物，一组服用对照药物，服药后开始统计每个患者从服药一直到死亡的生存时间。&lt;/p&gt;
&lt;p&gt;生存分析可以抽象概述为，研究在不同条件下，特定事件发生与时间的关系是否存在差异。这些具体事件可以是死亡，也可以是痊愈、肿瘤转移、复发、出院、重新入院等任何可以明确识别的事件，而不同条件即为不同的分组依据，可以是年龄、性别、地域、某个基因表达量的高低、某个突变的携带与否等等。&lt;/p&gt;
&lt;p&gt;（后面均用&amp;quot;死亡&amp;quot;来代指这个特定事件&lt;/p&gt;
&lt;h2 id=&#34;概念与推导&#34;&gt;概念与推导&lt;/h2&gt;
&lt;h3 id=&#34;生存时间t&#34;&gt;生存时间T&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1640248843/surv-time-1.png&#34; alt=&#34;survival-time&#34;&gt;&lt;/p&gt;
&lt;p&gt;把生存时间作为一个随机变量，用PDF（概率密度函数）和CDF（分布函数）来表达&lt;/p&gt;
&lt;p&gt;其中CDF为$F(t) = Pr(T &amp;lt; t)$，也就是t之前死亡的概率&lt;/p&gt;
&lt;h3 id=&#34;生存概率&#34;&gt;生存概率&lt;/h3&gt;
&lt;p&gt;S(t)，Survival probability，研究对象从试验开始到某个特定时间点仍然存活的概率,$S(t) = pr(T &amp;gt; t)$&lt;/p&gt;
&lt;p&gt;$S(t) = 1 - F(t)$&lt;/p&gt;
&lt;p&gt;之后的Kaplan-Meier模型主要关注S(t)&lt;/p&gt;
&lt;h3 id=&#34;风险概率&#34;&gt;风险概率&lt;/h3&gt;
&lt;p&gt;$h(t): \text{Hazard function}$&lt;/p&gt;
&lt;p&gt;$$h(t) = \lim_{\epsilon \to 0}\frac{P(T \in (t, t+\epsilon] | T \geqslant t)}{\epsilon} = \frac{f(t)}{S(t)}$$&lt;/p&gt;
&lt;p&gt;前一个等号的意义 很明显，表示的意义就是研究对象从试验开始到某个特定时间点t之前存活，但是在t时间点发生&amp;quot;死亡&amp;quot;的概率&lt;/p&gt;
&lt;p&gt;后面一个等号的推导过程&lt;/p&gt;
&lt;p&gt;$$
\begin{array}{llr}
h(t)&amp;amp; = \lim_{\Delta t \to 0} \frac{P(t &amp;lt; T \leqslant t + \Delta t | T &amp;gt; t)}{\Delta t}\newline
&amp;amp; = \lim_{\Delta t \to 0} \frac{P(t &amp;lt; T \leqslant t + \Delta t )}{\Delta t S(t)} &amp;amp; \scriptsize{S(t)的定义}\newline
&amp;amp; = \lim_{\Delta t \to 0} \frac{F(t + \Delta t) - F(t)}{\Delta t S(t)} &amp;amp; \scriptsize{F(t)的定义}\newline
&amp;amp; = \frac{f(t)}{S(t)}&amp;amp;  \scriptsize{f(t)是F(t)的微分}
\end{array}
$$&lt;/p&gt;
&lt;p&gt;然后还可以进一步推导：&lt;/p&gt;
&lt;p&gt;$$
h(t) = \frac{f(t)}{S(t)} = \frac{f(t)}{1 - F(t)} = - \frac{\partial log[1 - F(t)]}{\partial t} = - \frac{\partial log[S(t)]}{\partial t}
$$&lt;/p&gt;
&lt;p&gt;表示了$h(t)$和$S(t)$的关系&lt;/p&gt;
&lt;p&gt;$H(t): \text{Comulative\ Hazard\ function}$
 
$$H(t) = \int_0^t h(u) du$$&lt;/p&gt;
&lt;p&gt;进一步推导：
$$H(t) = \int_0^t h(u) du = - \int_0^t \frac{ \partial log[S(u)]}{\partial u} du = -log[S(t)]$$&lt;/p&gt;
&lt;p&gt;$$\to S(t) = exp[-H(t)]$$&lt;/p&gt;
&lt;p&gt;之后的Cox比例风险模型主要关注H(t)&lt;/p&gt;
&lt;h2 id=&#34;hazard-function理解&#34;&gt;Hazard function理解&lt;/h2&gt;
&lt;p&gt;hazard function 本身不是概率，它描述的是一种在给定时间点的风险，$\Delta t \times h(t)$表示在$(t, t + \Delta t]$的概率&lt;/p&gt;
&lt;p&gt;hazard function优势：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;描述给定时间点的风险，这是我们需要的信息&lt;/li&gt;
&lt;li&gt;可以很好的处理数据缺失的情况&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;举个例子&#34;&gt;举个例子&lt;/h2&gt;
&lt;p&gt;假设survival time服从指数分布$Exp(\lambda)$，即$f(x) = \lambda e ^{-\lambda x}, x &amp;gt; 0$&lt;/p&gt;
&lt;p&gt;也就是$f(t) = \lambda e ^{-\lambda x}$&lt;/p&gt;
&lt;p&gt;可以推出：&lt;/p&gt;
&lt;p&gt;$F(t) = 1 - e ^{-\lambda x}$&lt;/p&gt;
&lt;p&gt;$S(t) = 1 - F(t) = e ^{-\lambda x}$&lt;/p&gt;
&lt;p&gt;$h(t) = \frac{f(t)}{S(t)} = \lambda$&lt;/p&gt;
&lt;p&gt;$H(t) = \lambda t$&lt;/p&gt;
&lt;p&gt;$E(T) = \frac{1}{\lambda} （指数分布的性质）= \frac{1}{h(t)}$&lt;/p&gt;
&lt;p&gt;其他的分布同理
Gamma distribution
Weibull distribution
Log-normal distribution
generized gamma distribution...&lt;/p&gt;
&lt;h2 id=&#34;删失数据-censoring&#34;&gt;删失数据 Censoring&lt;/h2&gt;
&lt;p&gt;生存分析中，很常见的一种特征就是删失数据&lt;/p&gt;
&lt;p&gt;指的是在临床试验中，出现一些数据丢失的情况，比如病人中途主动退出、无法联系到、结束时还未发生特定事件。保留了从一开始到丢失前进度的数据成为右删失，另一种称为左删失。（后面只讨论右删失）&lt;/p&gt;
&lt;h3 id=&#34;type-i-censoring观测时间确定&#34;&gt;Type I Censoring：观测时间确定&lt;/h3&gt;
&lt;p&gt;每一项数据增加一个表示：&lt;/p&gt;
&lt;p&gt;$$(U_i, \delta_i) = {min (T_i, c), I(T_i \leqslant c)}, i = 1, ... , n$$&lt;/p&gt;
&lt;p&gt;$$I(T_i \leqslant C) = \begin{cases}
1, &amp;amp; T_i \leqslant C,\
0, &amp;amp; T_i &amp;gt; C
\end{cases}$$&lt;/p&gt;
&lt;p&gt;c是实验时间，是一个常量
也就是说如果是$(c, 0)$，则代表被删失，如果是$(T_i, 1)$，则没有被删失&lt;/p&gt;
&lt;h3 id=&#34;type-ii-censoring观测人数确定&#34;&gt;Type II Censoring：观测人数确定&lt;/h3&gt;
&lt;p&gt;比如观测n人，当死亡r人时停止试验
$T_{(1, n)}, T_{(2, n)}, ..., T_{(r, n)}$&lt;/p&gt;
&lt;h3 id=&#34;type-iii-censoring随机censoring&#34;&gt;Type III Censoring：随机Censoring&lt;/h3&gt;
&lt;p&gt;不用常量c而是用随机变量$C_i$&lt;/p&gt;
&lt;p&gt;$(U_i, \delta_i) = {min (T_i, C_i), I(T_i \leqslant C_i)}, i = 1, ... , n$&lt;/p&gt;
&lt;p&gt;只考虑右删失，我们只观察$(U_i, \delta_i)$
如果$(U_i, \delta_i) = (u_i, 1)$，则说明$T_i = u_i, C_i &amp;gt; u_i$
如果$(U_i, \delta_i) = (u_i, 0)$，则说明$T_i \geqslant u_i, C_i = u_i$&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1640245124/survival-analysis-2.png&#34; alt=&#34;survival-analysis-2&#34;&gt;&lt;/p&gt;
&lt;p&gt;(推导见https://www.bilibili.com/video/BV1WE411P78Z?p=2)&lt;/p&gt;
&lt;h2 id=&#34;kaplan-meier模型&#34;&gt;Kaplan-Meier模型&lt;/h2&gt;
&lt;p&gt;与生存表、Cox并列的一种生存分析的方法，也叫乘积极限(product-limit estimator)&lt;/p&gt;
&lt;p&gt;$\hat{S}(t)=\prod_{i: t_{i} \leq t}\left(1-\frac{d_{i}}{n_{i}}\right), \quad t \geq 0$&lt;/p&gt;
&lt;p&gt;$d_i$是在$t_i$时刻死亡的人数，$n_i$是还在风险中的人数&lt;/p&gt;
&lt;p&gt;例子：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1640245203/survival-analysis-example-1.png&#34; alt=&#34;survival-analysis-example-1&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;life-table-生存表&#34;&gt;Life table 生存表&lt;/h3&gt;
&lt;p&gt;举例：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1640245336/life-table-1.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;设时间点为$t_0, t_1, ... ,t_n$，那么在$t_i$时间点下的生存概率：
$$S(t_i) = \Pi_{j=0}^{i}(1-P(t_j死亡))$$&lt;/p&gt;
&lt;p&gt;也就是：
$$S\left(t_{i}\right)=S\left(t_{i-1}\right)\left(1-\frac{d_{i}}{n_{i}}\right)$$&lt;/p&gt;
&lt;p&gt;$n_i$表示$t_i$时的有效人数，$d_i$表示$t_i$时的死亡人数&lt;/p&gt;
&lt;p&gt;$t_i$处的生存率等于$t_{i-1}$时的生存率乘以（1-$t_i$时间点的死亡率）&lt;/p&gt;
&lt;h3 id=&#34;kaplan-meier-生存曲线&#34;&gt;Kaplan-Meier 生存曲线：&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1640245508/km-curve-1.png&#34; alt=&#34;&#34;&gt;
加号表示删失数据&lt;/p&gt;
&lt;p&gt;往往是多条线（因为是不同的组）&lt;/p&gt;
&lt;h2 id=&#34;cox比例风险回归模型&#34;&gt;Cox比例风险回归模型&lt;/h2&gt;
&lt;p&gt;Cox Proportional-Hazards Model是由英国统计学家D.R.Cox于1972年提出的一种半参数回归模型（半参数值既包含参数模型，又包含非参数模型）&lt;/p&gt;
&lt;p&gt;参数模型：有限维度，有限个参数就可以表示模型分布，比如正态分布的均值和标准差
非参数模型：属于某个无限维的空间，无法用有限个参数来表示，比如决策树、随机森林&lt;/p&gt;
&lt;p&gt;Cox建立回归的是前面提到的$h(x)$
Cox模型：
$$h(t) = h_0(t) \times exp({b_1x_1 + b_2x_2 + ... b_px_p})$$&lt;/p&gt;
&lt;p&gt;其中$h(t)$指的是不同时间的风险值（hazard），$x_i$指的是具有预测效应的变量，$b_i$指的是每个变量对应的效应值，$h_0(t)$是基准风险函数，根据不同的数据来使用不同的分布模型，是非参数模型&lt;/p&gt;
&lt;p&gt;建模时，首先确定需要研究的可能影响生存率的因素，也就是$x_i$，我们主要要做的就是找到合适的$h_0(t)$以及所有协变量的系数$b_p$，需要用到极大似然估计等方法求解参数。&lt;/p&gt;
&lt;h3 id=&#34;两个基本假设&#34;&gt;两个基本假设&lt;/h3&gt;
&lt;p&gt;对公式两边取对数进行变形：&lt;/p&gt;
&lt;p&gt;$$log(h(t)) = log(h_0(t)) + \beta X$$&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;模型中各危险因素对危险率的影响不随时间改变，且与时间无关&lt;/li&gt;
&lt;li&gt;对数危险率与各个危险因素呈线性相关&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;参数的极大似然估计&#34;&gt;参数的极大似然估计&lt;/h3&gt;
&lt;p&gt;通过极大似然估计来求解参数，极大似然估计的思想是，让已经发生的事件出现的可能性最大。&lt;/p&gt;
&lt;p&gt;举个例子，有三个人$X_1, X_2, X_3$分别在三个时间点$t_1, t_2, t_3$死亡&lt;/p&gt;
&lt;p&gt;以$t=t_1$为例，此时我们的目标是$max\ h(t_1, X_1)$和$min\ h(t_1, X_2) + h(t_1, X_3)$，统一这两个的目标：&lt;/p&gt;
&lt;p&gt;$$max\ \frac{h(t_1, X_1)}{h(t_1, X_1) + h(t_1, X_2) + h(t_1, X_3)}$$&lt;/p&gt;
&lt;p&gt;（分母加一个分子不影响结果，但是可以让最后一项不至于分母为0）&lt;/p&gt;
&lt;p&gt;类推得到$t_2$的目标：
$$max\ \frac{h(t_2, X_2)}{h(t_2, X_2) + h(t_2, X_3)}$$&lt;/p&gt;
&lt;p&gt;$t_3$的目标：
$$max\ \frac{h(t_3, X_3)}{h(t_3, X_3)}$$&lt;/p&gt;
&lt;p&gt;所以似然函数是：
$$L(\beta) = \frac{h(t_1, X_1)}{h(t_1, X_1) + h(t_1, X_2) + h(t_1, X_3)} \frac{h(t_2, X_2)}{h(t_2, X_2) + h(t_2, X_3)} \frac{h(t_3, X_3)}{h(t_3, X_3)}$$&lt;/p&gt;
&lt;p&gt;代入$h(x)$的公式之后消掉$h_0(t)$，得到：
$$L(\beta) = \frac{exp(\beta · X_1)}{exp(\beta · X_1) + exp(\beta · X_2) + exp(\beta · X_3)} \frac{exp(\beta · X_2)}{exp(\beta · X_2) + exp(\beta · X_3)} \frac{exp(\beta · X_3)}{exp(\beta · X_3)}$$&lt;/p&gt;
&lt;p&gt;这里我们假设的是3个事件，再泛化到N个的情况：
$$L(\beta)=\prod_{i=1}^{N} \frac{\exp \left(\beta \cdot X_{i}\right)}{\sum_{j: t_{j} \geq t_{i}} \exp \left(\beta \cdot X_{j}\right)}$$&lt;/p&gt;
&lt;p&gt;对数似然函数：
$$l(\beta)=\log L(\beta)=\sum_{i=1}^{N}\left[\beta \cdot X_{i}-\log \left(\sum_{j: t_{j} \geq t_{i}} \exp \left(\beta \cdot X_{j}\right)\right)\right]$$&lt;/p&gt;
&lt;p&gt;梯度为：
$$\frac{\partial l(\beta)}{\partial \beta}=\sum_{i=1}^{N}\left[\beta-\frac{\sum_{j: t_{j} \geq t_{i}} X_{j} \cdot \exp \left(\beta \cdot X_{j}\right)}{\sum_{j: t_{j} \geq t_{i}} \exp \left(\beta \cdot X_{j}\right)}\right]$$&lt;/p&gt;
&lt;p&gt;就可以采用梯度下降法来对参数进行估计&lt;/p&gt;
&lt;h3 id=&#34;解读结果&#34;&gt;解读结果&lt;/h3&gt;
&lt;p&gt;解得了合适的$h_0(t)$以及协变量系数之后，我们可以比较某个协变量$x_i$在不同值的时候对应的不同风险比$\frac{x_i + 1}{x_i}$。&lt;/p&gt;
&lt;p&gt;$$hazard\ ratio = \frac{h_0(t) \times e^{b_1x_1 + b_2x_2 + ...b_i(x_i+1) + ... b_px_p}}{h_0(t) \times e^{b_1x_1 + b_2x_2  + ...b_ix_i + ... b_px_p}} = e^{b_i}$$&lt;/p&gt;
&lt;p&gt;举个例子，假如某个指标$x_i$表示年龄，那么对于年龄x和年龄x+1的人来说，死亡风险比是$e^{b_i}$，如果$b_i&amp;gt;0$，则年龄增大，死亡风险增大。反之减小。等于0则是不起作用&lt;/p&gt;
</content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://yichengme.site/categories/%E7%AE%97%E6%B3%95/" term="算法" label="算法" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://yichengme.site/tags/%E7%94%9F%E5%AD%98%E5%88%86%E6%9E%90/" term="生存分析" label="生存分析" />
                            
                        
                            
                            
                            
                                <category scheme="https://yichengme.site/tags/%E7%BB%9F%E8%AE%A1%E5%AD%A6/" term="统计学" label="统计学" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">Golang并发教程</title>
            <link rel="alternate" type="text/html" href="https://yichengme.site/posts/go-concurrency-tutorial/" />
            <id>https://yichengme.site/posts/go-concurrency-tutorial/</id>
            <updated>2022-02-08T17:27:00&#43;08:00</updated>
            <published>2020-09-15T23:35:12&#43;08:00</published>
            <author>
                    <name>王毅诚</name>
                    <uri>https://yichengme.site/</uri>
                    <email>engine74396@gmail.com</email>
                    </author>
            <rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">Go的并发调度非常优雅，将极其复杂的运行机制隐藏在了一个简单的关键字go下面，这篇文章不涉及底层并发调度的细节，之后有空再写，这里只是讲解一下如何使用go来编写……</summary>
            
                <content type="html">&lt;p&gt;Go的并发调度非常优雅，将极其复杂的运行机制隐藏在了一个简单的关键字&lt;code&gt;go&lt;/code&gt;下面，这篇文章不涉及底层并发调度的细节，之后有空再写，这里只是讲解一下如何使用go来编写一些简单的并发语句。&lt;/p&gt;
&lt;h2 id=&#34;goroutine&#34;&gt;goroutine&lt;/h2&gt;
&lt;p&gt;只需要在函数前面加上go关键词就可以开启goroutine，Go就会新创建一个goroutine来执行这个函数&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;kn&#34;&gt;package&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;main&lt;/span&gt;

&lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;
	&lt;span class=&#34;s&#34;&gt;&amp;#34;fmt&amp;#34;&lt;/span&gt;
	&lt;span class=&#34;s&#34;&gt;&amp;#34;time&amp;#34;&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;say&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;s&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;time&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Sleep&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;100&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;time&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Millisecond&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;fmt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Println&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;


&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;go&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;say&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;routine1&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;go&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;say&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;routine2&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
	&lt;span class=&#34;nf&#34;&gt;say&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;main&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;output:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;8
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;routine1
routine2
main
main
routine1
routine2
main
routine2
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1641817507/goroutine1.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;最多可以同時执行CPU线程数相等的Goroutine&lt;/p&gt;
&lt;p&gt;GoRoutine的优点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;任何函数，前面加一个go关键字就可以送给调度器运行&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;不需要定义函数时声明是否为异步函数&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;调度器会在合适的时间点进行切换&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用-race可以检测数据访问冲突&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;channel&#34;&gt;channel&lt;/h2&gt;
&lt;p&gt;通道是一个用来传递数据的数据结构&lt;/p&gt;
&lt;p&gt;可以用于两个goroutine之间传递数据&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// v发送到通道ch
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;ch&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;v&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;// 从ch接受数据把值赋给v
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;v&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;ch&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;声明通道&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-Python&#34; data-lang=&#34;Python&#34;&gt;&lt;span class=&#34;n&#34;&gt;ch&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;make&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;chan&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;通道默认没有缓冲区，发送数据后需要设置接收端来接受响应的数据&lt;/p&gt;
&lt;p&gt;比如下面这个例子，并行计算前面一半数据和后面一半数据的和，然后等它们都计算好了，把它们加起来&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;kn&#34;&gt;package&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;main&lt;/span&gt;

&lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;fmt&amp;#34;&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;sum&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;s&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[]&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;chan&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;nx&#34;&gt;sum&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;_&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;v&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;range&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;s&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
                &lt;span class=&#34;nx&#34;&gt;sum&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;v&lt;/span&gt;
        &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
        &lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;sum&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 把 sum 发送到通道 c
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;nx&#34;&gt;s&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[]&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;7&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;8&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;9&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;4&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

        &lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;make&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;chan&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;go&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;sum&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[:&lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;len&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;],&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;go&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;sum&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;len&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:],&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
        &lt;span class=&#34;nx&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;y&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;-&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;-&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 从通道 c 中接收
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;
        &lt;span class=&#34;nx&#34;&gt;fmt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Println&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;y&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;y&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;output:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;-5 &lt;span class=&#34;m&#34;&gt;17&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;12&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;创建了两个goroutine，分别运算前一半和后一半的和，结果会存进通道中，然后通过&lt;code&gt;x, y := &amp;lt;-c, &amp;lt;-c&lt;/code&gt;从c中取出这两个结果。这里x和y并不能确定哪个是前一半的结果。&lt;/p&gt;
&lt;p&gt;因为这里我们没有声明channel的缓冲区，默认是1，如果我们不取出来，只有&lt;/p&gt;
&lt;h3 id=&#34;通道缓冲区&#34;&gt;通道缓冲区&lt;/h3&gt;
&lt;p&gt;在创建通道的时候可以在第二个参数声明一个缓冲区，比如我们要声明一个大小为100的缓冲区&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ch := make(chan int, 100)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;假如没有缓冲区，发送方会一直阻塞到接收方接受了通道中的值；&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;假如带了缓冲区，缓冲区还没满，发送方阻塞到数据被拷贝到缓冲区内；&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;假如带了缓冲区，缓冲区已经满了，则发送方会阻塞到接收方获取到一个值；&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如果运行到了接收的代码，但是通道内没有元素，则接收方会一直阻塞，直到发送方完成后代码才会继续进行。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们就可以同时发送多个数据，而不需要立即读取&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;// 这里我们定义了一个可以存储整数类型的带缓冲通道
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;c1&#34;&gt;// 缓冲区大小为2
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;nx&#34;&gt;ch&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;make&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;chan&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;

        &lt;span class=&#34;c1&#34;&gt;// 因为 ch 是带缓冲的通道，我们可以同时发送两个数据
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;c1&#34;&gt;// 而不用立刻需要去同步读取数据
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;nx&#34;&gt;ch&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;
        &lt;span class=&#34;nx&#34;&gt;ch&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;

        &lt;span class=&#34;c1&#34;&gt;// 获取这两个数据
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;nx&#34;&gt;fmt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Println&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;-&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;ch&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
        &lt;span class=&#34;nx&#34;&gt;fmt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Println&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;-&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;ch&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;取出的时候第二个参数指示了是否结束，比如&lt;code&gt;v, ok := &amp;lt;-ch&lt;/code&gt;，当取通道内的最后一个元素，ok就会置为0
还可以通过&lt;code&gt;for i := range c&lt;/code&gt;直接取尽通道中的元素&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;举例：多线程爬虫
给定一个url列表，进行多线程爬取。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;思路：先构造一个&lt;code&gt;crawler&lt;/code&gt;函数，该函数将并行运行，爬取这个url并将结果存入通道。在&lt;code&gt;main&lt;/code&gt;函数中for循环遍历然后go关键词调用&lt;code&gt;crawler&lt;/code&gt;函数并行。最后取出channel的元素。&lt;/p&gt;
&lt;h2 id=&#34;等待&#34;&gt;等待&lt;/h2&gt;
&lt;p&gt;等待是非常重要的一个内容&lt;/p&gt;
&lt;p&gt;在我们最开始写第一个goroutine代码的时候，会遇到这样一种情况&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;go&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;say&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;1&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;go&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;say&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;2&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;以为会打印出1 2，然而实际情况是直接&lt;code&gt;Process finished with exit code 0&lt;/code&gt;，但是并没有报错&lt;/p&gt;
&lt;p&gt;造成这个的原因在于，这个状态下有三个goroutine：
&lt;code&gt;main&lt;/code&gt;
&lt;code&gt;say(&amp;quot;1&amp;quot;)&lt;/code&gt;
&lt;code&gt;say(&amp;quot;2&amp;quot;)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1641817507/goroutine2.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;main结束之后，另外两个goroutine被强制关闭，导致没有打印出来，之所以下面的&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;go&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;say&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;1&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;go&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;say&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;2&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
	&lt;span class=&#34;nf&#34;&gt;say&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;3&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;没有问题，是因为main在执行到&lt;code&gt;say(&amp;quot;3&amp;quot;)&lt;/code&gt;的时候，前面的goroutine已经开始了，因为是同一个函数形式，执行时间差不多，所以当&lt;code&gt;say(&amp;quot;3&amp;quot;)&lt;/code&gt;执行完后，前面的goroutine有可能也执行完了，这也就是为什么这个代码有时候可以打印出&lt;code&gt;1&lt;/code&gt; &lt;code&gt;2&lt;/code&gt;的原因，其实每次打印的元素个数都可能不会相等，这取决于前面两个goroutine是否能在main线程结束前执行完。&lt;/p&gt;
&lt;p&gt;所以实际上我们要做的，就是让main等待上面的goroutine执行完之后再结束&lt;/p&gt;
&lt;h3 id=&#34;方法1timesleep&#34;&gt;方法1：&lt;code&gt;time.Sleep&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;设定一个固定的时间，让main等待一段时间&lt;/p&gt;
&lt;p&gt;比如把原来的改成&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;go&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;say&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;1&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;go&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;say&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;2&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;time&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Sleep&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;5&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;time&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Second&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;这样就能正常执行上面的goroutine了&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1641817507/goroutine3.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;优点：很简单
缺点：不好控制具体的时间，长了浪费，短了没执行完&lt;/p&gt;
&lt;h3 id=&#34;方法2syncwaitgroup&#34;&gt;方法2：&lt;code&gt;sync.WaitGroup&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1641817507/goroutine4.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;在开始的时候创建一个和goroutine个数一样的waitGroup队列计数器，main线程在waitGroup不为空的情况下持续阻塞。
在每个goroutine结束之后调用waitGroup.Done()，从等待队列中减一，在所有的goroutine执行完之后，main线程停止等待，结束整个程序&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;say&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;s&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;wg&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;sync&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;WaitGroup&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;defer&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;wg&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Done&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;5&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;time&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Sleep&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;200&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;time&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Millisecond&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;fmt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Println&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;wg&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;new&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;sync&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;WaitGroup&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;wg&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Add&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;go&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;say&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;1&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;wg&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;go&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;say&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;2&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;wg&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;wg&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Wait&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;优点：执行完全部的goroutine后，main才会结束。时间把握的很好。
缺点：需要手动配置waitGroup&lt;/p&gt;
&lt;h3 id=&#34;方法3channel等待&#34;&gt;方法3：Channel等待&lt;/h3&gt;
&lt;p&gt;就是我们之前提到的Channel通道，它除了可以进行goroutine间通信，同样也可以作为等待的方法&lt;/p&gt;
&lt;p&gt;接受方会一直阻塞，直到接受到发送方传来的数据&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;say&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;s&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;chan&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;5&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;time&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Sleep&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;200&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;time&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Millisecond&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;fmt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Println&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;FINISH&amp;#34;&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;ch&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;make&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;chan&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;go&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;say&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;1&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;ch&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;go&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;say&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;2&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;ch&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
	&lt;span class=&#34;o&#34;&gt;&amp;lt;-&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;ch&lt;/span&gt;
	&lt;span class=&#34;o&#34;&gt;&amp;lt;-&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;ch&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;output:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;m&#34;&gt;1&lt;/span&gt;
&lt;span class=&#34;m&#34;&gt;1&lt;/span&gt;
&lt;span class=&#34;m&#34;&gt;2&lt;/span&gt;
&lt;span class=&#34;m&#34;&gt;1&lt;/span&gt;
&lt;span class=&#34;m&#34;&gt;2&lt;/span&gt;
&lt;span class=&#34;m&#34;&gt;1&lt;/span&gt;
&lt;span class=&#34;m&#34;&gt;2&lt;/span&gt;
&lt;span class=&#34;m&#34;&gt;1&lt;/span&gt;
&lt;span class=&#34;m&#34;&gt;2&lt;/span&gt;
&lt;span class=&#34;m&#34;&gt;2&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1641817507/goroutine5.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;假如我们把上面的&lt;code&gt;&amp;lt;-ch&lt;/code&gt;放在两个goroutine之间：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;ch&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;make&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;chan&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;go&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;say&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;1&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;ch&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
	&lt;span class=&#34;o&#34;&gt;&amp;lt;-&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;ch&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;go&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;say&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;2&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;ch&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
	&lt;span class=&#34;o&#34;&gt;&amp;lt;-&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;ch&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;当main执行到第一个&lt;code&gt;&amp;lt;-ch&lt;/code&gt;时，接收方阻塞，等待发送方（第一个say goroutine）的传入，当第一个goroutine执行完之后，执行&lt;code&gt;&amp;lt;-ch&lt;/code&gt;，然后再开启下一个goroutine，所以最后的输出是：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;m&#34;&gt;1&lt;/span&gt;
&lt;span class=&#34;m&#34;&gt;1&lt;/span&gt;
&lt;span class=&#34;m&#34;&gt;1&lt;/span&gt;
&lt;span class=&#34;m&#34;&gt;1&lt;/span&gt;
&lt;span class=&#34;m&#34;&gt;1&lt;/span&gt;
&lt;span class=&#34;m&#34;&gt;2&lt;/span&gt;
&lt;span class=&#34;m&#34;&gt;2&lt;/span&gt;
&lt;span class=&#34;m&#34;&gt;2&lt;/span&gt;
&lt;span class=&#34;m&#34;&gt;2&lt;/span&gt;
&lt;span class=&#34;m&#34;&gt;2&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;用时间轴来表示就是&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1641817507/goroutine6.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;优点：时序控制把握很好，语法很简洁
不过相对前面的方法，理解会稍微抽象一点&lt;/p&gt;
&lt;p&gt;我们最常用的还是Channel的方式&lt;/p&gt;
&lt;h2 id=&#34;数据同步互斥&#34;&gt;数据同步、互斥&lt;/h2&gt;
&lt;p&gt;在不同的线程之间涉及到处理相同数据的时候，两个routine执行的顺序会影响到结果的变化，为了保证正确性，需要引入互斥锁&lt;/p&gt;
&lt;p&gt;Go提供了sync.Mutex的互斥锁类型，以及两个方法：Lock和Unlock&lt;/p&gt;
&lt;h2 id=&#34;实战&#34;&gt;实战&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;生产者消费者模型：&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;注意，如果没有wg，那么消费者在消费完生产者生产的数据后还会一直等待，go就会判定为死锁。一个解决方法就是对于生产者增加一个WaitGroup，需要在调用并行的生产者方法之前就Add(1)，如果放在goroutine内部可能会直接触发掉&lt;code&gt;wg.Wait()&lt;/code&gt;然后被关掉，wg在生产者方法最后Done掉。再增加一个goroutine来等待wg，如果&lt;code&gt;wg.Wait()&lt;/code&gt;触发了则说明生产者生产完了，这个时候可以关掉通道，从而让消费者不会阻塞&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;producer&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;out&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;chan&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;num&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;wg&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;sync&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;WaitGroup&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;num&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;out&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;i&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;wg&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Done&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;consumer&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;in&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;chan&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;done&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;chan&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;range&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;in&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;fmt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Println&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;done&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;finish&amp;#34;&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;ProducerConsumerRun&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;kd&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;ch&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;make&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;chan&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;5&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
	&lt;span class=&#34;kd&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;done&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;make&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;chan&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
	&lt;span class=&#34;kd&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;wg&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;sync&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;WaitGroup&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;10&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;wg&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Add&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
		&lt;span class=&#34;k&#34;&gt;go&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;producer&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;ch&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;wg&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;go&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;consumer&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;ch&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;done&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;go&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;wg&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Wait&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
		&lt;span class=&#34;nb&#34;&gt;close&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;ch&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}()&lt;/span&gt;
	&lt;span class=&#34;o&#34;&gt;&amp;lt;-&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;done&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;（未完待续）&lt;/p&gt;
&lt;p&gt;参考：&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://tour.go-zh.org/concurrency&#34;&gt;https://tour.go-zh.org/concurrency&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.runoob.com/go/go-concurrent.html&#34;&gt;https://www.runoob.com/go/go-concurrent.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://peterhpchen.github.io/2020/03/08/goroutine-and-channel.html&#34;&gt;https://peterhpchen.github.io/2020/03/08/goroutine-and-channel.html&lt;/a&gt;&lt;/p&gt;
</content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://yichengme.site/categories/%E5%B7%A5%E7%A8%8B/" term="工程" label="工程" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://yichengme.site/tags/%E5%B9%B6%E5%8F%91/" term="并发" label="并发" />
                            
                        
                            
                            
                            
                                <category scheme="https://yichengme.site/tags/golang/" term="Golang" label="Golang" />
                            
                        
                            
                            
                            
                                <category scheme="https://yichengme.site/tags/%E7%B2%BE%E9%80%89/" term="精选" label="精选" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">计算机系统结构</title>
            <link rel="alternate" type="text/html" href="https://yichengme.site/posts/computer-system-structure-1/" />
            <id>https://yichengme.site/posts/computer-system-structure-1/</id>
            <updated>2022-02-08T17:27:00&#43;08:00</updated>
            <published>2020-06-04T15:05:09&#43;08:00</published>
            <author>
                    <name>王毅诚</name>
                    <uri>https://yichengme.site/</uri>
                    <email>engine74396@gmail.com</email>
                    </author>
            <rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">第一章：导论 概念部分 第一台通用电子计算机诞生于1946年 计算机技术的飞速发展得益于：计算机制造技术的发展、计算机系统结构的创新 纷纷放弃高性能转向多核，标志着系统……</summary>
            
                <content type="html">&lt;h3 id=&#34;第一章导论&#34;&gt;第一章：导论&lt;/h3&gt;
&lt;h2 id=&#34;概念部分&#34;&gt;概念部分&lt;/h2&gt;
&lt;p&gt;第一台通用电子计算机诞生于1946年&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;计算机技术的飞速发展得益于&lt;/strong&gt;：计算机制造技术的发展、计算机系统结构的创新&lt;/p&gt;
&lt;p&gt;纷纷放弃高性能转向多核，标志着系统结构的重大转折：&lt;strong&gt;从单纯依靠指令集并行转向开发线程级并行和数据集并行&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;计算机系统的层次结构&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;L6: 应用语言虚拟机&lt;/p&gt;
&lt;p&gt;L5: 高级语言虚拟机&lt;/p&gt;
&lt;p&gt;L4: 汇编语言虚拟机&lt;/p&gt;
&lt;p&gt;L3: 操作系统虚拟机&lt;/p&gt;
&lt;p&gt;L2: 传统机器级&lt;/p&gt;
&lt;p&gt;L1: 微程序机器级&lt;/p&gt;
&lt;p&gt;L1-L3通常使用解释实现（一条一条来）&lt;/p&gt;
&lt;p&gt;L4-L6通常使用翻译实现（全部翻译成下面一个低级再执行）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;计算机系统结构定义&lt;/strong&gt;：计算机系统结构是程序员所看到的计算机属性，即概念性结构与功能特性，是计算机系统的软硬件的界面&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;广义的系统结构&lt;/strong&gt;：指令结构、组成和硬件&lt;/p&gt;
&lt;p&gt;包括：指令系统、寻址方式、数据表示、寄存器定义、中断系统、工作状态的切换、存储系统、信息保护、I/O结构等&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;计算机组成&lt;/strong&gt;：计算机系统结构的逻辑实现&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;计算机实现&lt;/strong&gt;：计算机系统结构的物理实现&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一种体系结构可以有多种组成，一种组成可以有多种物理实现&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;系统结构的分类&lt;/strong&gt;
冯氏分类法：按照最大并行度（字宽×一次能处理的字数）分
Flynn分类：按指令流和数据流的多倍性分，分为以下四类：&lt;/p&gt;
&lt;p&gt;①单指令流单数据流（SISD）&lt;/p&gt;
&lt;p&gt;②单指令流多数据流（SIMD）&lt;/p&gt;
&lt;p&gt;③多指令流单数据流（MISD）&lt;/p&gt;
&lt;p&gt;④多指令流多数据流（MIMD）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;冯诺依曼结构&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;最大特点：以运算器为中心&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;虚拟机&lt;/strong&gt;：用软件实现的机器&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;系列机&lt;/strong&gt;：同一个厂家生产的具有相同系统结构但具有不同组成和实现的一系列不同型号的计算机&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;兼容机&lt;/strong&gt;：由不同厂家生产的具有相同系统结构的计算机&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;软件兼容&lt;/strong&gt;：向上兼容、向下兼容、向前兼容和向后兼容，其中向后兼容是系列机的根本特征&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;模拟&lt;/strong&gt;：用软件的方法在一台计算机上实现另一台计算机的指令集（本机要解释执行另一台机子的程序）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;仿真&lt;/strong&gt;：用一台现有计算机上的微程序去解释实现另一台计算机的指令集（本机要实现另一台机子的指令集）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;并行性&lt;/strong&gt;：包括同时性（同一时刻）和并发性（同一间隔）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;提高并行性的措施&lt;/strong&gt;：时间重叠、资源重复、资源共享&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;耦合度&lt;/strong&gt;：反应计算机之间物理连接的紧密程度和交互强弱，分为紧密耦合系统和松散耦合系统&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;计算机系统设计经常使用的4个定量原理&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;以经常性事件为重点&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Amdahl定律&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;CPU性能公式&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;程序的局部性原理&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;计算部分&#34;&gt;计算部分&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Amdahl定律&lt;/strong&gt;（P7）&lt;/p&gt;
&lt;p&gt;$加速比 = \frac{执行时间_{改进前}}{执行时间_{改进后}} = \frac{1}{（ 1 - 可改进比例 ）+ \frac{可改进比例}{部件加速比} }$
依赖于可改进比例和部件加速比&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;CPU时间&lt;/strong&gt;（P9）&lt;/p&gt;
&lt;p&gt;$CPU时间 = IC \times CPI \times 时钟周期时间$&lt;/p&gt;
&lt;p&gt;$时钟周期 = \frac{1}{f}$&lt;/p&gt;
&lt;p&gt;$MIPS速率 = \frac{f}{CPI} $&lt;/p&gt;
&lt;p&gt;执行时间和吞吐率（P11）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;性能比较&lt;/strong&gt;（P14）&lt;/p&gt;
&lt;h3 id=&#34;第二章指令集结构&#34;&gt;第二章：指令集结构&lt;/h3&gt;
&lt;h2 id=&#34;概念部分-1&#34;&gt;概念部分&lt;/h2&gt;
&lt;p&gt;区别不同指令集结构的主要因素是&lt;strong&gt;CPU中用来储存操作数的储存单元的类型&lt;/strong&gt;，因此可以把指令集结构分为&lt;strong&gt;堆栈结构&lt;/strong&gt;、&lt;strong&gt;累加器结构&lt;/strong&gt;和&lt;strong&gt;通用寄存器结构&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;寻址方式&lt;/strong&gt;：
指一种指令集结构如何确定所要访问的数据的地址&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;对指令集的基本要求&lt;/strong&gt;：
完整性、规整性、高效率和兼容性&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;指令集结构设计涉及的内容&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;① 指令集功能设计，主要由CISC和RISC两种方向&lt;/p&gt;
&lt;p&gt;② 寻址方式设计&lt;/p&gt;
&lt;p&gt;③ 操作数表示和操作数类型&lt;/p&gt;
&lt;p&gt;④ 寻址方式的表示&lt;/p&gt;
&lt;p&gt;⑤ 指令集格式的设计，变长、固定长度、混合&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;指令集三种编码格式&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;可变长度编码&lt;/p&gt;
&lt;p&gt;固定长度编码&lt;/p&gt;
&lt;p&gt;混合型编码&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;RISC遵循的原则&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;① 指令条数少而简单&lt;/p&gt;
&lt;p&gt;② 采用简单而又统一的指令格式&lt;/p&gt;
&lt;p&gt;③ 指令的执行在单个机器周期内完成&lt;/p&gt;
&lt;p&gt;④ 只有load和store能访问存储器&lt;/p&gt;
&lt;p&gt;⑤ 大多数指令采用硬连逻辑&lt;/p&gt;
&lt;p&gt;⑥ 强调优化编译器的作用&lt;/p&gt;
&lt;p&gt;⑦ 充分利用流水线&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;I类指令&lt;/strong&gt;：
load、store等&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;0-5&lt;/th&gt;
&lt;th&gt;6-10&lt;/th&gt;
&lt;th&gt;11-15&lt;/th&gt;
&lt;th&gt;16-31&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;操作码&lt;/td&gt;
&lt;td&gt;rs&lt;/td&gt;
&lt;td&gt;rt&lt;/td&gt;
&lt;td&gt;立即数&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;R类指令&lt;/strong&gt;：
ALU等&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;0-5&lt;/th&gt;
&lt;th&gt;6-10&lt;/th&gt;
&lt;th&gt;11-15&lt;/th&gt;
&lt;th&gt;16-20&lt;/th&gt;
&lt;th&gt;21-25&lt;/th&gt;
&lt;th&gt;26-31&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;操作码&lt;/td&gt;
&lt;td&gt;rs&lt;/td&gt;
&lt;td&gt;rt&lt;/td&gt;
&lt;td&gt;rd&lt;/td&gt;
&lt;td&gt;shamt&lt;/td&gt;
&lt;td&gt;funct&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;br&gt;
&lt;h3 id=&#34;第三章流水线技术&#34;&gt;第三章：流水线技术&lt;/h3&gt;
&lt;h2 id=&#34;概念部分-2&#34;&gt;概念部分&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;流水线技术的概念&lt;/strong&gt;：
把一个重复的过程分解为若干个子过程，每一个子过程用一个专门的部件来实现。多个处理过程在时间上错开依次通过各段，让每个子过程和其他过程并行，这就是流水线技术&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;流水线技术的特点&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;① 流水线把一个处理过程分解为若干个子过程，每个子过程由一个专门的功能部件来实现，依靠它们的并行工作来缩短程序的执行时间&lt;/p&gt;
&lt;p&gt;② 流水线各段时间应该尽可能相等&lt;/p&gt;
&lt;p&gt;③ 流水线的每一个功能部件的后面都要有一个缓冲存储器&lt;/p&gt;
&lt;p&gt;④ 流水线适合于大量重复的时序过程&lt;/p&gt;
&lt;p&gt;⑤ 流水线需要有通过时间和排空时间&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;流水线分类&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;单功能流水线：只能完成一种固定功能&lt;/p&gt;
&lt;p&gt;多功能流水线：可以实现不同的功能&lt;/p&gt;
&lt;p&gt;静态流水线：同一时间各段只能按照同一种功能的连接方式工作&lt;/p&gt;
&lt;p&gt;动态流水线：同一时间各段可以有不同的连接，执行多种功能&lt;/p&gt;
&lt;p&gt;部件级流水线：把运算部件分段&lt;/p&gt;
&lt;p&gt;处理机级流水线：把指令的解释执行过程分段&lt;/p&gt;
&lt;p&gt;处理机间流水线：在处理机间流水&lt;/p&gt;
&lt;p&gt;线性流水线：没有反馈回路&lt;/p&gt;
&lt;p&gt;非线性流水线：有反馈回路&lt;/p&gt;
&lt;p&gt;顺序流水线：任务流出流入的顺序一致&lt;/p&gt;
&lt;p&gt;乱序流水线：任务流出的顺序和流入的顺序可以不一样&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解决流水线瓶颈问题的方法&lt;/strong&gt;
细分瓶颈段、重复设置瓶颈段&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;经典的五段流水线划分&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一条指令的执行过程可以划分为以下五个部分：&lt;/p&gt;
&lt;p&gt;取指令周期（IF）&lt;/p&gt;
&lt;p&gt;指令译码/读寄存器（ID）&lt;/p&gt;
&lt;p&gt;执行/有效地址计算（EX）&lt;/p&gt;
&lt;p&gt;存储器访问/分支完成（MEM）&lt;/p&gt;
&lt;p&gt;写回周期（WB）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;相关的概念&lt;/strong&gt;：相关是指两条指令之间存在某种依赖关系&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;相关的分类&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;数据相关：指令之间有数据关联（有传递性）&lt;/p&gt;
&lt;p&gt;名相关：名指的是寄存器名或存储器名，数据不关联但是用了相同的名，名相关又分为反相关（一写一读）和输出相关（都写）&lt;/p&gt;
&lt;p&gt;控制相关：由分支指令引起的相关&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;流水线冲突的概念&lt;/strong&gt;：
对于具体的流水线而言，由于相关的存在，导致指令流的下一条指令不能在指定的时钟周期执行&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;流水线冲突的分类&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;结构冲突：硬件资源无法满足重叠执行的要求&lt;br&gt;
     — 消除结构冲突：气泡停顿、设置独立指令数据存储器、Cache分为指令Cache和数据Cache
数据冲突：重叠执行时需要用到前面的数据&lt;br&gt;
     — 数据冲突分为：写后读（RAW）、写后写（WAW）&lt;/p&gt;
&lt;p&gt;     — 解决数据冲突：定向技术（直接从产生的地方送到需要的地方）、通过编译器指令调度解决
控制冲突：分支指令等引起的冲突&lt;br&gt;
     — 解决控制冲突：冻结或排空流水线（最简单但是分支延迟大）、尽早判断分支是否成功（提前到ID段末尾）、软件方法&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;减少分支延迟的静态方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;预测分支失败&lt;/p&gt;
&lt;p&gt;预测分支成功&lt;/p&gt;
&lt;p&gt;延迟分支（在延迟槽中放入有用的指令，三种调度方法：从前调度、从目标处调入、从失败处调入）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;不采用单周期的原因&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;① 单周期效率低，不同指令需要的时钟周期不一样&lt;/p&gt;
&lt;p&gt;② 单周期需要重复设置部件，而多周期可以共享&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;流水寄存器的作用&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;① 将各段隔开来，使之不会相互干扰&lt;/p&gt;
&lt;p&gt;② 保存相应段的处理结果&lt;/p&gt;
&lt;p&gt;③ 向后传递后面要用到的数据或控制信息&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;流水线的实现（P82 - P90）&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;$IF/IR$&lt;/th&gt;
&lt;th&gt;$IR/EX$&lt;/th&gt;
&lt;th&gt;$EX/MEM$&lt;/th&gt;
&lt;th&gt;$MEM/WD$&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;$NPC$&lt;/td&gt;
&lt;td&gt;$NPC$&lt;/td&gt;
&lt;td&gt;$cond$&lt;/td&gt;
&lt;td&gt;$LMD$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;$IR$&lt;/td&gt;
&lt;td&gt;$A$&lt;/td&gt;
&lt;td&gt;$ALU0$&lt;/td&gt;
&lt;td&gt;$ALU0$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;$B$&lt;/td&gt;
&lt;td&gt;$B$&lt;/td&gt;
&lt;td&gt;$IR$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;$Imm$&lt;/td&gt;
&lt;td&gt;$IR$&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;$IR$&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;计算部分-1&#34;&gt;计算部分&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;吞吐率&lt;/strong&gt;：单位时间内流水线完成的任务数量&lt;/p&gt;
&lt;p&gt;$TP = \frac{n}{T_k}$&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;加速比&lt;/strong&gt;：不用流水线所用的时间和用流水线所用时间之比&lt;/p&gt;
&lt;p&gt;$S = \frac{T_s}{T_k}$&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;效率&lt;/strong&gt;：设备实际使用时间与整个运行时间之比（画图之后即为阴影面积/完整面积）&lt;/p&gt;
&lt;p&gt;易出大题（P61 例题3.1、P104 章后习题3.11）
&lt;strong&gt;务必注意题目里说的是静态流水线还是动态流水线&lt;/strong&gt;，静态流水线必须一个操作做完之后 才能开另一个功能，参见P60例3.1个P60例3.2&lt;/p&gt;
&lt;br&gt;
&lt;h3 id=&#34;第四章指令级并行&#34;&gt;第四章：指令级并行&lt;/h3&gt;
&lt;h2 id=&#34;概念部分-3&#34;&gt;概念部分&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;指令级并行概念&lt;/strong&gt;：利用流水线使指令重叠并行执行，这种指令之间潜在并行性称为指令级并行（ILP，Instruction-Level Parallelism）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;CPI&lt;/strong&gt;：（Cycles Per Instruction）每条指令所消耗的时钟周期数
&lt;strong&gt;IPC&lt;/strong&gt;：（Instructions Per Cycle）每个时钟周期完成的指令条数&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;基本程序块&lt;/strong&gt;：一段除了入口和出口之外不包含其他分支的线性代码段（就是指中间没分支）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;循环级并行&lt;/strong&gt;：让一个循环中的不同循环体并行执行&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;开发循环级并行的技术&lt;/strong&gt;：循环展开技术、采用向量指令和向量数据表示&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;指令顺序&lt;/strong&gt;：由源程序确定的在完全串行方式下指令的执行顺序&lt;/p&gt;
&lt;p&gt;正确执行程序&lt;strong&gt;必须保持的最关键的两个因素&lt;/strong&gt;：数据流（数据从其产生者指令到消费者指令的实际流动）和异常行为（无论怎么改变顺序，都不影响程序中异常的发生情况）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;指令调度&lt;/strong&gt;：通过在编译时让编译器重新组织指令顺序或者通过硬件在执行时调整指令顺序来消除冲突&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;静态调度与动态调度&lt;/strong&gt;：第三章为静态调度，第四章为动态调度，以下为二者区别：
① 静态调度发生在编译过程中，动态调度发生在运行过程中
② 动态调度相比静态有更多优点：能够处理一些编译时不明确的相关、能够套用在其他流水线上&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;精确异常和不精确异常&lt;/strong&gt;：
精确异常：发生异常时，处理机的现场和严格按程序顺序执行时的现场相同
不精确异常：发生异常时，处理机的现场和严格按程序顺序执行时的现场不同&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Tomasulo算法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;保留栈&lt;/strong&gt;：在采用Tomasulo算法的MIPS处理器浮点部件中，在运算部件的入口设置的用来保存已经流出并等待到本功能部件执行的指令
&lt;strong&gt;CDB&lt;/strong&gt;：公共数据总线&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ROB&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;动态分支预测技术&lt;/strong&gt;：根据分支指令过去的表现来预测其将来的行为
&lt;strong&gt;BHT&lt;/strong&gt;：分支历史表，用于记录相关分支指令最近几次的执行情况并根据此进行预测
&lt;strong&gt;分支目标缓冲&lt;/strong&gt;：是一种动态分支预测技术，将执行过的成功的分支指令的地址和预测的分支目标地址记录在一个硬件表中，每次取指令时比较，达到减少分支开销的作用
&lt;strong&gt;前瞻执行&lt;/strong&gt;：解决控制相关的方法，对分支指令的结果进行预测，按照这个预测结果继续后续的过程，不过指令执行的结果不是放在寄存器或存储器中，而是放在ROB缓冲器中，相应指令确认后才将结果写到寄存器或存储器
&lt;strong&gt;ROB&lt;/strong&gt;：前瞻执行缓冲器&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;多流出处理机的两种基本风格&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;超标量：一种多指令流出技术，每个时钟周期流出的指令条数不确定，但有个上限
超长指令字：一种多指令流出技术，每个时钟周期流出的指令条数是固定的，这些指令构成一条长指令或者指令包，通过编译器静态调度&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;超流水&lt;/strong&gt;
一个时钟周期内分时流出多条指令&lt;/p&gt;
&lt;h2 id=&#34;计算部分-2&#34;&gt;计算部分&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;实际CPI&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;$CPI_{流水线} = CPI_{理想} + 停顿_{结构冲突} + 停顿_{数据冲突} + 停顿_{控制冲突}$&lt;/p&gt;
&lt;br&gt;
&lt;h3 id=&#34;第五章存储系统&#34;&gt;第五章：存储系统&lt;/h3&gt;
&lt;h2 id=&#34;概念部分-4&#34;&gt;概念部分&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;人们追求的储存器特性&lt;/strong&gt;：容量大、速度快、价格低&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;走出困境的唯一方法&lt;/strong&gt;：采用多级存储层次结构&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;多级存储层次&lt;/strong&gt;：采用不同的技术实现的存储器，处在离CPU不同位置的层次上，各存储器之间一般满足包容关系，任何一层存储器中的内容都是其下一层的储存器内容的子集。目标是达到离CPU最近的存储器的速度，最远的存储器的容量。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;“Cache-主存”与“主存-辅存”的区别&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;Cache-主存层次&lt;/th&gt;
&lt;th&gt;主存-辅存层次&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;目的&lt;/td&gt;
&lt;td&gt;为了弥补主存速度的不足&lt;/td&gt;
&lt;td&gt;为了弥补主存容量的不足&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;存储管理的实现&lt;/td&gt;
&lt;td&gt;由专用硬件实现&lt;/td&gt;
&lt;td&gt;由软件实现&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;访问速度的比值&lt;/td&gt;
&lt;td&gt;几比一&lt;/td&gt;
&lt;td&gt;几万比一&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;块/页大小&lt;/td&gt;
&lt;td&gt;几十个字节&lt;/td&gt;
&lt;td&gt;几百到几千字节&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;CPU对第二级的访问方式&lt;/td&gt;
&lt;td&gt;可以直接访问&lt;/td&gt;
&lt;td&gt;均通过第一级&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;不命中时是否切换&lt;/td&gt;
&lt;td&gt;不切换&lt;/td&gt;
&lt;td&gt;切换到其他进程&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;映像规则&lt;/strong&gt;
全相联映像：主存中的任意一块可以被放置到Cache中的任意一个位置，空间利用率最高、冲突概率最低、实现最复杂
直接映像：    主存中的每一块只能被放到Cache中唯一的位置，空间利用率最低、冲突概率最高、实现最简单
组相联映像：主存中的每一块可以被放置到Cache中唯一一组中的任何一个位置，是上面二者的折中&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;查找算法&lt;/strong&gt;
查找Cache在哪，通过查找目录表实现，目录表项与储存器块对应&lt;/p&gt;
&lt;p&gt;目录表&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;有效位&lt;/th&gt;
&lt;th&gt;标识&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;/table&gt;
&lt;p&gt;有效位为1表示有效，标识tag标识了存放的信息存在于哪个主存块中&lt;/p&gt;
&lt;p&gt;主存地址&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;标识&lt;/th&gt;
&lt;th&gt;索引&lt;/th&gt;
&lt;th&gt;块内位移&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;替换算法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;随机法&lt;/p&gt;
&lt;p&gt;FIFO&lt;/p&gt;
&lt;p&gt;LRU&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;LRU算法的硬件实现&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;堆栈法&lt;/p&gt;
&lt;p&gt;比较对法&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;写策略&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;写直达法：执行写操作时，不仅写入Cache，而且也直接写入下一级存储器（易于实现）
（不按写分配，不命中直接写入下一级而不调块）&lt;/p&gt;
&lt;p&gt;写回法：执行写操作时，只写入Cache。仅当Cache中相应的块被替换时，才写回主存（速度快）
（按写分配，不命中时调块）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Cache对低CPI、高时钟频率的CPU来说更为重要&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;改进Cache性能&lt;/strong&gt;
包括三个方面：&lt;/p&gt;
&lt;p&gt;① 降低不命中率（8种）&lt;/p&gt;
&lt;p&gt;② 减少不命中开销（5种）&lt;/p&gt;
&lt;p&gt;③ 减少Cache命中时间（4种）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;三种类型的不命中&lt;/strong&gt;
强制性不命中：首次访问就没命中
容量不命中：某些块被替换了，之后又访问了这些块（原因主要是容量小了）
冲突不命中：组相联或直接映像很多块映到了同一组（块）中，原块被替换，之后又访问了这些块&lt;/p&gt;
&lt;p&gt;相联度越高，冲突不命中就越少（因为每块可选的位置变多了，冲突几率下降），对强制不命中和容量不命中没什么影响&lt;/p&gt;
&lt;p&gt;Cache容量增加，容量不命中下降，对强制性不命中没影响&lt;/p&gt;
&lt;p&gt;减少三种不命中的方法：
强制性不命中：增加块大小，预取（本身比例很少）
容量不命中：增加容量
冲突不命中：提高相联度（理想情况：全相联）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;降低不命中率的八种方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;① 增加Cache块大小&lt;br&gt;
            最简单，减少强制不命中，但增加了冲突不命中（因为块的个数少了），同时也会增大不命中开销&lt;/p&gt;
&lt;p&gt;② 增加Cache容量&lt;br&gt;
            最直接，但会增加成本和命中时间&lt;/p&gt;
&lt;p&gt;③ 提高相联度&lt;br&gt;
            会增加命中时间
         （2:1Cache经验规则：容量为N的直接映像Cache的不命中率和容量为N/2的两路组相联Cache的不命中率差不多）&lt;/p&gt;
&lt;p&gt;④ 伪相联Cache&lt;br&gt;
            访问如果命中就和直接映像一样，如果不命中就检查另一个位置是否匹配，简单的方法是将索引的最高位取反。保持命中速度和低不命中率，会让CPU流水线的设计复杂化&lt;/p&gt;
&lt;p&gt;⑤ 硬件预取&lt;br&gt;
            指令和数据在处理器提出访问之前进行预取，由Cache之外的硬件完成，放入一个缓冲器中。预取应当利用存储器的空闲带宽，不能影响对正常不命中的处理，否则可能会降低性能&lt;/p&gt;
&lt;p&gt;⑥ 编译器控制的预取&lt;br&gt;
            由编译器在程序中加入预取指令实现预取。每次预取需要花费一条指令的开销&lt;/p&gt;
&lt;p&gt;⑦ 编译器优化&lt;br&gt;
            三种方法：代码和数据重组、内外循环交换、分块&lt;/p&gt;
&lt;p&gt;⑧ 牺牲Cache&lt;br&gt;
            在Cache和下一级之间设置一个全相联小Cache来存储被替换掉的块，减少冲突不命中很有效，尤其是小容量Cache&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;减少Cache不命中开销的五种方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;① 采用两级Cache（有计算）&lt;/p&gt;
&lt;p&gt;② 让读不命中优先于写
            会增加命中时间&lt;/p&gt;
&lt;p&gt;③ 写缓冲合并&lt;br&gt;
            写入的数据与缓冲器已有地址比较，如果有地址匹配的就合并&lt;/p&gt;
&lt;p&gt;④ 请求字处理技术&lt;br&gt;
            从下一级调入Cache的块只有一个字是立即需要的，称为请求字，两种方法：尽早重启动、请求字优先&lt;br&gt;
            在Cache块较小或者下一条指令正好访问Cache块的另一部分时，效果不明显&lt;/p&gt;
&lt;p&gt;⑤ 非阻塞Cache技术&lt;br&gt;
            在Cache不命中时仍允许CPU进行其他的命中访问&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;减少Cache命中时间的四种方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;① 容量小、结构简单的Cache&lt;br&gt;
            增大不命中率&lt;/p&gt;
&lt;p&gt;② 虚拟Cache&lt;br&gt;
            可以直接用虚拟地址进行访问的Cache&lt;/p&gt;
&lt;p&gt;③ Cache访问流水化&lt;br&gt;
            把对第一级Cache的访问按流水方式组织&lt;/p&gt;
&lt;p&gt;④ 踪迹Cache&lt;br&gt;
            存放CPU所执行过的动态序列，包含分支预测展开的指令&lt;br&gt;
            地址映像机制复杂，相同的指令序列可能被重复存放，提高了Cache的空间利用率&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;主存主要的性能指标&lt;/strong&gt;：延迟和带宽&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;并行主存系统&lt;/strong&gt;：在一个访存周期内能并行访问多个储存字的存储器&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;并行存储器结构包括&lt;/strong&gt;：
单体多字存储器
多体交叉存储器&lt;/p&gt;
&lt;h2 id=&#34;计算部分-3&#34;&gt;计算部分&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;平均每位价格C、命中率H、平均访存时间&lt;/strong&gt;（P155）&lt;/p&gt;
&lt;p&gt;$M_1{T_1, S_1, C_1}、M_2{T_2, S_2, C_2}$&lt;/p&gt;
&lt;p&gt;T: 平均访存时间，S: 存储容量，C: 平均每位价格&lt;/p&gt;
&lt;p&gt;平均每位价格 = $\frac{M_1C_1 + M_2C_2}{M_1 + M_2}$&lt;/p&gt;
&lt;p&gt;命中率 = $\frac{N_1}{N_1+N_2}$&lt;/p&gt;
&lt;p&gt;平均访存时间 = $HT_1 + (1-H)(T_1+T_M) = T_1 + (1-H)T_M = T_1 + FT_M$
不命中开销 $T_M = T_2 + T_B$&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Cache的容量&lt;/strong&gt;（P163）&lt;/p&gt;
&lt;p&gt;Cache容量 = $2^{index} \times$ 相联度 $\times$ 块大小&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;程序执行时间&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;$CPU$时间 = $IC \times (CPI + $每条指令的平均访存次数$\times $不命中率$ \times $不命中开销$) \times $时钟周期时间&lt;/p&gt;
&lt;p&gt;（P172例题）&lt;/p&gt;
&lt;h3 id=&#34;第六章输入输出系统&#34;&gt;第六章：输入输出系统&lt;/h3&gt;
&lt;h2 id=&#34;概念部分-5&#34;&gt;概念部分&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;I/O系统包括&lt;/strong&gt;：I/O设备、I/O设备与处理机的连接&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;系统的响应时间&lt;/strong&gt;：从用户输入命令开始，到得到结果所花费的时间（等于I/O系统的响应时间+CPU的处理时间）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;I/O系统的三个性能指标&lt;/strong&gt;
可靠性：一直连续提供服务的能力，用平均无故障时间MTTF衡量，其倒数为失效率（计算时失效率可累加，倒数相加再倒）
可用性：正常工作的时间在连续两次正常服务间隔中的比例    可用性=$\frac{MTTF}{MTTF+MTTR}$
可信性：服务的质量（无法度量）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;磁盘阵列&lt;/strong&gt;：使用多个磁盘的组合来代替一个大容量的磁盘
阵列的并行性包括：多个请求可以由多个盘来并行处理、一个请求访问多个块也可以多个块合作地并行处理&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;各种RAID&lt;/strong&gt;
（检测盘个数是数据盘个数为8个时所需要的检测盘个数）&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名称&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;th&gt;可容忍故障&lt;/th&gt;
&lt;th&gt;检测盘个数&lt;/th&gt;
&lt;th&gt;优点&lt;/th&gt;
&lt;th&gt;缺点&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;RAID0&lt;/td&gt;
&lt;td&gt;非冗余阵列，没有冗余信息&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;无空间开销&lt;/td&gt;
&lt;td&gt;无纠错能力&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;RAID1&lt;/td&gt;
&lt;td&gt;镜像盘，每个磁盘都有备份&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;计算少，快&lt;/td&gt;
&lt;td&gt;空间开销大&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;RAID2&lt;/td&gt;
&lt;td&gt;汉明纠错码位交叉&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;不依靠故障盘诊断&lt;/td&gt;
&lt;td&gt;空间开销log&lt;sub&gt;2&lt;/sub&gt;n&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;RAID3&lt;/td&gt;
&lt;td&gt;位交叉奇偶校验磁盘阵列&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;空间开销小，大规模I/O带宽高&lt;/td&gt;
&lt;td&gt;小规模I/O支持不好&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;RAID4&lt;/td&gt;
&lt;td&gt;块交叉奇偶校验磁盘阵列&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;空间开销小，小规模I/O带宽高&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;RAID5&lt;/td&gt;
&lt;td&gt;块交叉分布奇偶校验磁盘阵列&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;空间开销小，小规模I/O带宽高&lt;/td&gt;
&lt;td&gt;小规模读写需要访问4次&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;RAID6&lt;/td&gt;
&lt;td&gt;P+Q双校验磁盘阵列&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;容忍两个磁盘出错&lt;/td&gt;
&lt;td&gt;小规模读写需要访问6次&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;实现盘阵列的方式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;软件方式&lt;/p&gt;
&lt;p&gt;阵列卡方式&lt;/p&gt;
&lt;p&gt;子系统方式&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;通道处理机&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;专门负责整个计算机的输入输出工作，通道处理机只能执行有限的一组输入输出指令&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入输出系统的层次&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;CPU-&amp;gt;通道-&amp;gt;设备控制器-&amp;gt;外设&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;通道的主要硬件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;寄存器&lt;/p&gt;
&lt;p&gt;控制逻辑&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;通道的工作过程&lt;/strong&gt;（3步）&lt;/p&gt;
&lt;p&gt;① 在用户程序中启动一个访管指令，由管理程序来编制一个通道程序，并启动通道&lt;/p&gt;
&lt;p&gt;② 通道处理机执行通道程序，完成指定的数据的输入输出工作&lt;/p&gt;
&lt;p&gt;③ 通道程序结束后向CPU发出中断请求&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;通道的种类&lt;/strong&gt;（3种）&lt;/p&gt;
&lt;p&gt;① 字节多路通道，为多台低中速外设服务，以字节交叉的方式分时轮流服务，可以包含多个子通道，每个子通道连接一台设备控制器&lt;/p&gt;
&lt;p&gt;② 选择通道，为多台高速外围设备服务，一段时间内只为一条高速外设独占&lt;/p&gt;
&lt;p&gt;③ 数组多路通道，适用于高速设备，每次选择一个高速设备后传送一个数据块，轮流为多台外围设备服务&lt;/p&gt;
&lt;h2 id=&#34;计算部分-4&#34;&gt;计算部分&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;通道流量分析（P238）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;字节多路通道：（连一个外设，传一个字节，再连一个外设，传一个字节...）&lt;/p&gt;
&lt;p&gt;p台设备传输n个数据所需时间：$T_{BYTE}=(T_S+T_D)\times p\times n$&lt;/p&gt;
&lt;p&gt;最大流量：$f_{MAX-BYTE} = \frac{1}{T_S+T_D}$&lt;/p&gt;
&lt;p&gt;选择通道：（一台设备的数据传输工作全部结束后通道才为另一台设备服务）&lt;/p&gt;
&lt;p&gt;p台设备传输n个数据所需时间：$T_{SELECT}=(\frac{T_S}{n}+T_D)\times p\times n$&lt;/p&gt;
&lt;p&gt;最大流量：$f_{MAX-SELECT} = \frac{1}{\frac{T_S}{n}+T_D}$&lt;/p&gt;
&lt;p&gt;数组多路通道：（连一个外设，传一个k个字节的数据块，再连一个外设，传一个k个字节的数据块...）&lt;/p&gt;
&lt;p&gt;p台设备传输n个数据所需时间：$T_{BLOCK}=(\frac{T_S}{k}+T_D)\times p\times n$&lt;/p&gt;
&lt;p&gt;最大流量：$f_{MAX-BLOCK} = \frac{1}{\frac{T_S}{k}+T_D}$&lt;/p&gt;
&lt;br&gt;
&lt;h3 id=&#34;第八章多处理机&#34;&gt;第八章：多处理机&lt;/h3&gt;
&lt;h2 id=&#34;概念部分-6&#34;&gt;概念部分&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;MIMD的成为通用多处理机系统结构的选择的原因&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;MIMD具有灵活性&lt;/p&gt;
&lt;p&gt;MIMD可以充分利用现有微处理机的性价比优势&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;MIMD的分类&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;集中式共享存储器结构&lt;/strong&gt;（CSMA、UMA、对称式共享存储器多处理机SMP）&lt;/p&gt;
&lt;p&gt;多个处理器共享一个集中式的物理存储器，单一主存而且主存对于各处理器而言是对等的&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;分布式存储器多处理机&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;存储器分布到各个处理器上，优点：&lt;/p&gt;
&lt;p&gt;①降低对存储器和互联网络的带宽要求&lt;/p&gt;
&lt;p&gt;②对本地存储器的访问延迟时间小；&lt;/p&gt;
&lt;p&gt;缺点：处理器之间的通信较为复杂，访问延迟大&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;两种储存器系统结构&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;共享地址空间：物理上分离的所有储存器作为一个统一的共享逻辑空间进行编址，不同处理器的同一个物理地址指向同一个存储单元&lt;/p&gt;
&lt;p&gt;独立编址：每个节点的存储器编址为一个独立的地址空间，不同处理器的地址是独立的。每一个处理器-存储器模块实际上是一台单独的计算机&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;两种通信机制&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;共享存储器通信机制：处理器之间通过store-load对相同存储器地址进行读写来实现的
优点：&lt;/p&gt;
&lt;p&gt;① 与常用的SMP通信机制兼容&lt;/p&gt;
&lt;p&gt;② 易于编程&lt;/p&gt;
&lt;p&gt;③ 数据量小时开销较低&lt;/p&gt;
&lt;p&gt;④ 可以采用cache来减少远程通信的频度&lt;/p&gt;
&lt;p&gt;消息传递通信机制：处理器之间通过发送消息来进行通信&lt;/p&gt;
&lt;p&gt;优点&lt;/p&gt;
&lt;p&gt;① 硬件简单&lt;/p&gt;
&lt;p&gt;② 通信是显式的&lt;/p&gt;
&lt;p&gt;③ 减少不当的同步带来的可能的错误&lt;/p&gt;
&lt;p&gt;④ 显式通信让编程者重点关注主要通信开销&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Cache一致性协议&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;监听式协议&lt;/p&gt;
&lt;p&gt;目录式协议&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Cache一致性问题解决方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;写作废协议&lt;/p&gt;
&lt;p&gt;写更新协议&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;同时多线程技术&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;一种在多流出、动态调度的处理器上同时开发线程级并行和指令级并行的技术&lt;/p&gt;
</content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://yichengme.site/categories/%E7%90%86%E8%AE%BA/" term="理论" label="理论" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://yichengme.site/tags/%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/" term="系统结构" label="系统结构" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">同济学生服务站小程序如何每日自动打卡</title>
            <link rel="alternate" type="text/html" href="https://yichengme.site/posts/miniprogram-auto-checkin/" />
            <id>https://yichengme.site/posts/miniprogram-auto-checkin/</id>
            <updated>2022-02-08T17:27:00&#43;08:00</updated>
            <published>2020-05-10T18:44:36&#43;08:00</published>
            <author>
                    <name>王毅诚</name>
                    <uri>https://yichengme.site/</uri>
                    <email>engine74396@gmail.com</email>
                    </author>
            <rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">（仅针对同济大学学生服务站小程序，本文只提供思路，需要具体代码的话可以私信。如果你一直呆在学校，可以考虑使用该方法自动签到，但是一旦离开上海，请务必向辅导员申报……</summary>
            
                <content type="html">&lt;p&gt;（仅针对同济大学学生服务站小程序，本文只提供思路，需要具体代码的话可以私信。如果你一直呆在学校，可以考虑使用该方法自动签到，但是一旦离开上海，请务必向辅导员申报！）&lt;/p&gt;
&lt;p&gt;之前寒假期间的打卡用的是问卷星，直接通过Selenium自动化来模拟操作前端填写问卷和提交打卡，都是流于表面的一些js操作，实现起来很简便。但是开学之后我们更换为了小程序打卡，微信小程序虽然是类前端，但它不同于常规网页，无法直接在浏览器中打开，只能借助微信来启动，可以理解为微信给它套了一个壳，提供了一些内置组件UI、请求统一处理、微信api调用、单独的IDE等等。小程序只能借助微信才能打开，只能通过腾讯发布的Wechat DevTool才能调试。&lt;/p&gt;
&lt;p&gt;那么问题来了，我们应该在小程序中怎么去模拟打卡的操作呢，我先试了试反编译，看看小程序的具体逻辑。&lt;/p&gt;
&lt;h2 id=&#34;反编译&#34;&gt;反编译&lt;/h2&gt;
&lt;p&gt;这里需要一台root过的安卓手机（推荐留个root过的安卓备用机，做很多事会比较方便，注意最好用备用机不要用主力机），没有的话也可以使用安卓模拟器先root再操作。&lt;/p&gt;
&lt;p&gt;安装微信和支持root超级权限的文件管理器，在模拟器里用微信登陆自己的账号，打开小程序，等小程序加载完成后，通过root文件管理器前往&lt;code&gt;data/data/com.tencent.mm/MicroMsg/&amp;lt;很长的一串数字字母字符串&amp;gt;/appbrand/pkg/&lt;/code&gt;文件夹下，在里面通过时间信息找到对应的wxpkg文件（不root的话是无法操作这些文件的），可以就地压缩然后通过微信或者其他软件发送到电脑上。&lt;/p&gt;
&lt;p&gt;最早的小程序反编译脚本是这个项目：https://github.com/qwerty472123/wxappUnpacker&lt;/p&gt;
&lt;p&gt;作者弃坑之后可以利用另一位大佬改进的项目：
&lt;a href=&#34;https://github.com/xuedingmiaojun/wxappUnpacker&#34;&gt;https://github.com/xuedingmiaojun/wxappUnpacker&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;按照README的说明来操作，就不具体解释&lt;/p&gt;
&lt;p&gt;中途如果遇到报错可以利用搜索引擎解决一下&lt;/p&gt;
&lt;p&gt;最后成功的输出&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span class=&#34;p&#34;&gt;...&lt;/span&gt;
&lt;span class=&#34;nx&#34;&gt;Generate&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;wxss&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;second&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;turn&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)...&lt;/span&gt;
&lt;span class=&#34;nx&#34;&gt;Generate&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;wxss&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;second&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;turn&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;done&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;
&lt;span class=&#34;nx&#34;&gt;Save&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;wxss&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;...&lt;/span&gt;
&lt;span class=&#34;nx&#34;&gt;saveDir&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;C&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;\&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Users&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;\&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;wyc&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;\&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Desktop&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;\&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;_97557709_27&lt;/span&gt;
&lt;span class=&#34;nx&#34;&gt;Split&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;and&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;make&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;up&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;done&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;
&lt;span class=&#34;nx&#34;&gt;Delete&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;files&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;...&lt;/span&gt;
&lt;span class=&#34;nx&#34;&gt;Deleted&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;

&lt;span class=&#34;nx&#34;&gt;File&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;done&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;
&lt;span class=&#34;nx&#34;&gt;Total&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;use&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;mf&#34;&gt;3.545&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;s&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;就会生成一个小程序源项目文件夹，可以直接用Wechat Dev Tool打开：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1641816256/checkin-1.png&#34; alt=&#34;checkin-1&#34;&gt;&lt;/p&gt;
&lt;p&gt;看了前端代码之后，可以看到所有的前端逻辑，签到的流程很简单，如下：&lt;/p&gt;
&lt;p&gt;初次使用小程序：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;完成学籍认证&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果学籍信息正确且该学籍没有绑定微信，则绑定学生信息到该微信id&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;（注意，该小程序每个学籍只能绑定一个微信，也就是说你不可以通过其他人的微信来绑定你的学籍）&lt;/p&gt;
&lt;p&gt;之后每次启动小程序：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;通过微信id，后端可以查到这名学生的签到信息&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;2-1. 如果已经签过到了，只提示“你已经签过到了”&lt;/p&gt;
&lt;p&gt;2-2. 如果当天没有签到，显示签到表单让用户填写&lt;/p&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;提交表单到后端，更新用户签到记录&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;值的一提的是，这里提交的位置信息并不是显示在前端的xx市xx区xx路，而是经纬度和xx市xx区，其他位置信息没用到，并且实际上校验的时候只要市正确即可，所以签到的话只要是标在上海市都没问题。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;所以只需要向后端服务器发送一条包含位置信息的POST请求，不论使用的设备在哪里，只要在data里写明上海，那么就会在上海打卡。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;然而只有前端并没有实质的收获，实际上也不需要前端代码，只是想通过反编译的方式了解一下逻辑。关键的是后端接口，可以抓包来获取，然后伪造打卡请求即可。&lt;/p&gt;
&lt;h2 id=&#34;抓包&#34;&gt;抓包&lt;/h2&gt;
&lt;p&gt;使用常见的抓包工具，抓包工具用顺手的就行，Fidder、Charles、Proxyman...我这次使用的是Proxyman，当然这几个都是完全同理的。&lt;/p&gt;
&lt;p&gt;微信小程序的抓包有一些不同，配置好手机和电脑连上之后，直接抓会获取不到：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1641816256/checkin-2.png&#34; alt=&#34;checkin-2&#34;&gt;&lt;/p&gt;
&lt;p&gt;（当然这里我们知道了base url，结合之前的前端源码，可以知道所有的api的url，但是不知道header、token等信息，发送post请求会比较麻烦。）&lt;/p&gt;
&lt;p&gt;为什么抓不到呢？这是因为微信7.0对https的证书做了限制，只有系统信任的证书才可以被允许，而我们安装的是软件的第三方证书&lt;/p&gt;
&lt;p&gt;你需要通过下面两种方式中的一种，才可以捕获成功：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;安装微信7.0之前的版本（简单）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;安卓root之后，把证书移动到系统证书目录下（会比较麻烦）&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;我两种方法都用过，第一种非常无脑，去豌豆荚下一个老版的微信即可，当然第二种方法会更好一些，毕竟老版本之后可能会有问题。&lt;/p&gt;
&lt;p&gt;按照软件的教程给电脑安装证书，手机配置网络代理，然后打开打卡小程序开始抓包，这个小程序抓包很轻松，api直接明文暴露了出来&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1641816256/checkin-3.png&#34; alt=&#34;checkin-3&#34;&gt;&lt;/p&gt;
&lt;p&gt;弄清楚这几个接口的含义、Header的信息、Auth的方式、POST数据的格式以及返回的信息含义，如果后端没有做一些处理的话，理论上就能直接伪装一个POST请求来进行签到。&lt;/p&gt;
&lt;p&gt;这些api的含义很明显，其他的就不细说了，主要说一下要用到的两个：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;用户是否签到&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;method: GET&lt;/p&gt;
&lt;p&gt;url: &amp;quot;https://tjxsfw.chisai.tech/api/school_tjxsfw_student/yqfkLogDailyreport/hasDoneToday?studentPid=&amp;quot; + studentPid&lt;/p&gt;
&lt;p&gt;header: 需要jwt验证&lt;/p&gt;
&lt;p&gt;Header中需要加入&amp;quot;Bearer: &amp;lt;jwt_token&amp;gt;&amp;quot;来验证&lt;/p&gt;
&lt;p&gt;返回一个json，如果code==200并且data=true，则表示已经签过到了，data=false表示今天还没签到&lt;/p&gt;
&lt;p&gt;这个api用于检测你是否需要签到，以及签到是否成功&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;签到&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;method: POST&lt;/p&gt;
&lt;p&gt;url: &amp;quot;https://tjxsfw.chisai.tech/api/school_tjxsfw_student/yqfkLogDailyreport/v2&amp;quot;&lt;/p&gt;
&lt;p&gt;data: 签到的json，包含用户信息、签到地点、打卡时间等&lt;/p&gt;
&lt;p&gt;header: 需要jwt验证&lt;/p&gt;
&lt;p&gt;第二天用postman试了一下，直接从proxyman里复制请求信息，然后修改时间，发了个POST过去，打开小程序，提示已经打过卡了，说明该方法有效&lt;/p&gt;
&lt;h2 id=&#34;构造请求反馈方式与定时任务&#34;&gt;构造请求、反馈方式与定时任务&lt;/h2&gt;
&lt;h3 id=&#34;构建请求&#34;&gt;构建请求&lt;/h3&gt;
&lt;p&gt;既然我们知道了具体的api，那么构造请求就非常简单了，C++、Java、C#、Python、JavaScript、Golang...基本上正常的编程语言都可以，选择自己顺手的即可。照着抓包到的请求抄一下header和token什么的，然后记得把请求的data里的日期改成现在的时间点。&lt;/p&gt;
&lt;p&gt;如果硬是要给明天后天也签个到，我没试过，理论上后端肯定会判断时间的，大概率会失败。主要是没这个必要，只要每天定时打卡即可&lt;/p&gt;
&lt;p&gt;（注意，同济大学学生服务站小程序会在每天的00：00-00：30分进行维护，需要绕开这个时间打卡）&lt;/p&gt;
&lt;h3 id=&#34;反馈方式&#34;&gt;反馈方式&lt;/h3&gt;
&lt;p&gt;我们设置了自动打卡，那么打完卡之后，小程序是不会通知你的，这时候就需要一个被通知的方式，来告诉你自动打卡成功或者失败的消息。&lt;/p&gt;
&lt;p&gt;途径有很多，我说说几个能想到的：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;QQ Bot&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;优点：部署完之后会很方便，还可以做其他事，有很全面的交互
缺点：构建比较复杂，尤其是tx几个月前封杀了一些第三方机器人，酷q倒了之后，目前我了解到的仅mirai可用。这件事主要表明了tx想要封杀第三方机器人的态度，导致QQ Bot的未来很迷茫。
适合人群：已经有自己的正常运行的QQ Bot，再写一个插件即可&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;Telegram Bot/ Discord Bot&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;优点：和QQ Bot优点一样，不过很稳定，软件官方支持的Bot
缺点：需要全程科学上网
适合人群：能全程科学上网的telegram/discord重度用户&lt;/p&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;IFTTT&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;优点：很容易，不用写代码，不用自己买服务器或域名
缺点：功能比较简陋（但是只是通知的话够用了）&lt;/p&gt;
&lt;p&gt;另外还搜到了一些其他的第三方软件，用法和IFTTT类似，需要的可以自己去搜索&lt;/p&gt;
&lt;p&gt;推荐采用IFTTT通知的方式，最容易实现。可以参考：https://zhuanlan.zhihu.com/p/103419701&lt;/p&gt;
&lt;h3 id=&#34;定时任务&#34;&gt;定时任务&lt;/h3&gt;
&lt;p&gt;需要设置一个定时任务来在每天的一个时间点打卡，所以不能关机。推荐使用云服务器或者是闲置的不关机电脑。&lt;/p&gt;
&lt;p&gt;这里分windows、mac&amp;amp;linux三个平台来说&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Windows&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;先构造一个bat脚本来启动程序，或者也可以打包程序为exe&lt;/p&gt;
&lt;p&gt;通过计算机管理 - 创建基本任务 - 定位bat或者exe文件 - 设置每日执行一次和执行的时间，然后就ok了&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;MacOS/Linux&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;因为mac也是类Unix系统，所以和Linux都可以使用crontab来设置定时任务，具体的教程网上很多&lt;/p&gt;
&lt;h3 id=&#34;后续&#34;&gt;后续&lt;/h3&gt;
&lt;p&gt;设定好定时任务后，就免去了每日打卡的操作，它会自动定时打卡，成功后通过手机发送通知。每天点三下屏幕都不想做，可能就是懒癌晚期吧。&lt;/p&gt;
</content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://yichengme.site/categories/%E7%94%9F%E6%B4%BB/" term="生活" label="生活" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://yichengme.site/tags/%E8%84%9A%E6%9C%AC/" term="脚本" label="脚本" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">Mongodb初级教程</title>
            <link rel="alternate" type="text/html" href="https://yichengme.site/posts/mongodb-basics/" />
            <id>https://yichengme.site/posts/mongodb-basics/</id>
            <updated>2022-02-08T17:27:00&#43;08:00</updated>
            <published>2020-04-20T14:29:14&#43;08:00</published>
            <author>
                    <name>王毅诚</name>
                    <uri>https://yichengme.site/</uri>
                    <email>engine74396@gmail.com</email>
                    </author>
            <rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">背景 mongodb是一个基于分布式文件存储的数据库。由C++语言编写。旨在为WEB应用提供可扩展的高性能数据存储解决方案。它是一个介于关系数据库和非关系数据库之……</summary>
            
                <content type="html">&lt;h2 id=&#34;背景&#34;&gt;背景&lt;/h2&gt;
&lt;p&gt;mongodb是一个基于分布式文件存储的数据库。由C++语言编写。旨在为WEB应用提供可扩展的高性能数据存储解决方案。它是一个介于关系数据库和非关系数据库之间的产品，是非关系数据库当中功能最丰富，最像关系数据库的。&lt;/p&gt;
&lt;p&gt;这里简单的讲一下使用方法，不涉及底层理论&lt;/p&gt;
&lt;h2 id=&#34;起步&#34;&gt;起步&lt;/h2&gt;
&lt;h3 id=&#34;mac下安装mongodb&#34;&gt;Mac下安装MongoDB&lt;/h3&gt;
&lt;p&gt;之前是
&lt;code&gt;brew install mongodb&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;但是现在会报错：No available formula with the name “mongodb”。&lt;/p&gt;
&lt;p&gt;先tap一个仓库 &lt;code&gt;brew tap mongodb/brew&lt;/code&gt;
安装mongodb社区版 &lt;code&gt;brew install mongodb-community&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&#34;运行mongod&#34;&gt;运行mongod&lt;/h3&gt;
&lt;p&gt;新建一个&lt;code&gt;/data/db&lt;/code&gt;文件夹&lt;/p&gt;
&lt;p&gt;运行MongoDB服务
&lt;code&gt;sudo mongod&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;（注：macOS 10.15 Catalina无法在根目录下进行修改，可以在其他目录新建，启动服务时通过&lt;code&gt;sudo mongod --dbpath=new_path/data/db&lt;/code&gt;指定）&lt;/p&gt;
&lt;p&gt;定位和启动MongoDB命令行
&lt;code&gt;cd /usr/local/Cellar/mongodb/4.0.3_1/bin&lt;/code&gt;
&lt;code&gt;./mongo&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;MongoDB和关系型数据库（Oracle、MySQL等）的区别：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;SQL&lt;/th&gt;
&lt;th&gt;MongoDB&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;table&lt;/td&gt;
&lt;td&gt;collection(集合)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;row&lt;/td&gt;
&lt;td&gt;document(文档)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;colume&lt;/td&gt;
&lt;td&gt;field(数据字段)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;每个文档是一组键值对（BSON）相同的字段不需要相同的数据类型&lt;/p&gt;
&lt;h2 id=&#34;基本命令&#34;&gt;基本命令&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;show dbs&lt;/code&gt; 展示所有数据库&lt;/p&gt;
&lt;p&gt;&lt;code&gt;use xx&lt;/code&gt; 使用某个数据库&lt;/p&gt;
&lt;p&gt;使用了某个数据库后：&lt;code&gt;show collections&lt;/code&gt;查看所有的集合&lt;/p&gt;
&lt;p&gt;&lt;code&gt;db.dropDatabase()&lt;/code&gt; 删除当前数据库&lt;/p&gt;
&lt;p&gt;&lt;code&gt;db.&amp;lt;col&amp;gt;.drop()&lt;/code&gt; 删除某个集合&lt;/p&gt;
&lt;p&gt;&lt;code&gt;mongodump -o &amp;lt;output_path&amp;gt;&lt;/code&gt; 导出数据库
（如果设置了密码，需要通过下面的命令导出）
&lt;code&gt;sudo mongodump -o &amp;lt;output_path&amp;gt; --authenticationDatabase admin --username &amp;lt;db_username&amp;gt; --password &amp;lt;db_password&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;mongorestore -d &amp;lt;dbname&amp;gt; &amp;lt;db_path&amp;gt;&lt;/code&gt; 导入数据库&lt;/p&gt;
&lt;h3 id=&#34;验证&#34;&gt;验证&lt;/h3&gt;
&lt;p&gt;本地的还好，如果部署到服务器上，默认是无法外网访问数据库的，倘若你想访问，就得开放端口然后在mongo的配置文件里设置0.0.0.0。然后mongo默认也没有密码&lt;/p&gt;
&lt;p&gt;这就会产生一个很蛋疼的事，当其他人访问你服务器的ip的27017端口时，可以直接完全操作你的数据库，对于非个人弄着玩的项目，这显然是不可能接受的。&lt;/p&gt;
&lt;p&gt;所以我们需要增加数据库验证，这里最常见的就是增加账号密码登录，方法如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span class=&#34;o&#34;&gt;//&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;err&#34;&gt;先使用&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;admin&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;use&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;admin&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;//&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;err&#34;&gt;创建&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;root密码&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;db&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;createUser&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;user&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;root&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;pwd&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;password&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;roles&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;root&amp;#34;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;其他的role：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;read
readWrite
dbAdmin
userAdmin
clusterAdmin
readAnyDatabase
readWriteAnyDatabase
userAdminAnyDatabase
dbAdminAnyDatabase
&lt;/code&gt;&lt;/pre&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span class=&#34;o&#34;&gt;//&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;err&#34;&gt;创建用户&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;db&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;createUser&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;user&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;username&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;pwd&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;password&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;roles&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;userAdminAnyDatabase&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;dbAdminAnyDatabase&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;readWriteAnyDatabase&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;在&lt;code&gt;/etc/mongo.conf&lt;/code&gt;配置文件里，把auth=true前面的&lt;code&gt;#&lt;/code&gt;去掉，让验证生效。&lt;/p&gt;
&lt;p&gt;重启mongodb服务&lt;code&gt;sudo service mongodb restart&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;之后的连接方式：mongo命令行连接：
&lt;code&gt;mongo admin -u username -p password&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;本地GUI（如navicat）连接，设置账号密码即可&lt;/p&gt;
&lt;h3 id=&#34;字段操作&#34;&gt;字段操作&lt;/h3&gt;
&lt;p&gt;字段重命名：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;db.col.update({},{$rename:{&amp;quot;old_field&amp;quot;:&amp;quot;new_field&amp;quot;}},false,true)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;比如：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;db.questionnaire.update({},{$rename:{&amp;quot;questionList&amp;quot;:&amp;quot;question&amp;quot;}},false,true)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;字段增加：
还可以指定默认值xxx&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;db.col.update({},{$set:{new_field:&#39;xxx&#39;}},{multi:true})
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;字段删除：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;db.col.update({},{$unset:{&#39;old_field&#39;:&#39;&#39;}},false, true)
&lt;/code&gt;&lt;/pre&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;db.user_questionnaire.update({},{$unset:{&#39;inputCostEstimation&#39;:&#39;&#39;}},false, true)
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;查找&#34;&gt;查找&lt;/h3&gt;
&lt;p&gt;列出集合信息：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;db.&amp;lt;collection-name&amp;gt;.find()
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;列出第一条集合的信息（按Json排版一下）：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;db.&amp;lt;collection-name&amp;gt;.findOne()
db.&amp;lt;col-name&amp;gt;.find({query}, {show})
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;query是一个查询字段。比如{&amp;quot;name&amp;quot;:&amp;quot;yicheng&amp;quot;}这种形式
后面的参数决定field是否显示，比find({&amp;quot;name&amp;quot;:&amp;quot;yicheng&amp;quot;}, {&amp;quot;_id&amp;quot;: 0, &amp;quot;age&amp;quot;: 1}) 表示_id不会显示，age会显示&lt;/p&gt;
&lt;p&gt;条件比较：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;操作&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;th&gt;用法&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;$gt&lt;/td&gt;
&lt;td&gt;&amp;gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;$gte&lt;/td&gt;
&lt;td&gt;&amp;gt;=&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;$lt&lt;/td&gt;
&lt;td&gt;&amp;lt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;$lte&lt;/td&gt;
&lt;td&gt;&amp;lt;=&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;$eq&lt;/td&gt;
&lt;td&gt;=&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;$ne&lt;/td&gt;
&lt;td&gt;!=&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;$in&lt;/td&gt;
&lt;td&gt;in&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;$nin&lt;/td&gt;
&lt;td&gt;not in&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;增删改&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;增加：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;db.col.insert(json)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;e.g.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;db.col.insert({&amp;quot;name&amp;quot;:&amp;quot;engine&amp;quot;, &amp;quot;age&amp;quot;:18})

db.articles.insert({&amp;quot;title&amp;quot;:&amp;quot;Test&amp;quot;,&amp;quot;author&amp;quot;:&amp;quot;engine&amp;quot;,&amp;quot;time&amp;quot;:&amp;quot;2020.02.27&amp;quot;,&amp;quot;kind&amp;quot;:&amp;quot;tech&amp;quot;,&amp;quot;tags&amp;quot;:&amp;quot;golang,website&amp;quot;,&amp;quot;content&amp;quot;:&amp;quot;This is a blog for test&amp;quot;,&amp;quot;comment&amp;quot;:&amp;quot;comment1&amp;quot;,&amp;quot;view&amp;quot;:10,&amp;quot;like&amp;quot;:5})

db.user.insert({&amp;quot;name&amp;quot;:&amp;quot;user1&amp;quot;,avatar:&amp;quot;https://i.loli.net/2020/03/15/XsJjRomr1dy8u4D.png&amp;quot;,&amp;quot;type&amp;quot;:0,&amp;quot;score&amp;quot;:20,&amp;quot;password&amp;quot;:&amp;quot;123456&amp;quot;,&amp;quot;todo&amp;quot;:&amp;quot;&amp;quot;})
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;删除：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;db.col.remove(query)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;修改&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;db.mycoll.update(query, object[, upsert_bool, multi_bool])
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;第一个参数是查询条件，第二个参数是修改信息，第三个是如果没找到是否相当于插入（默认为false），第四个参数是修改一个还是所有（默认为false）&lt;/p&gt;
&lt;p&gt;e.g.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;db.col.update({&amp;quot;name&amp;quot;:&amp;quot;engine&amp;quot;}, {$set:{&amp;quot;age&amp;quot;:20}})

db.col.update({&amp;quot;age&amp;quot;: {$gt: 20}}, {$set:{&amp;quot;age&amp;quot;: 30}}, false, true)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;更复杂的逻辑：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;db.getCollection(&#39;participant&#39;).find().forEach(
   function(item){
       db.getCollection(&#39;participant&#39;).update({&amp;quot;_id&amp;quot;:item._id},{$set:{&amp;quot;modifyTimes&amp;quot;: 3}})
   }
)
&lt;/code&gt;&lt;/pre&gt;&lt;table class=&#34;reference&#34;&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;th&gt;数据类型&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;字符串。存储数据常用的数据类型。在 MongoDB 中，UTF-8 编码的字符串才是合法的。   &lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;Integer&lt;/td&gt;&lt;td&gt;整型数值。用于存储数值。根据你所采用的服务器，可分为 32 位或 64 位。  &lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;Boolean&lt;/td&gt;&lt;td&gt;布尔值。用于存储布尔值（真/假）。  &lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;Double&lt;/td&gt;&lt;td&gt;双精度浮点值。用于存储浮点值。  &lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;Min/Max keys&lt;/td&gt;&lt;td&gt;将一个值与 BSON（二进制的 JSON）元素的最低值和最高值相对比。  &lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;Array&lt;/td&gt;&lt;td&gt;用于将数组或列表或多个值存储为一个键。  &lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;Timestamp&lt;/td&gt;&lt;td&gt;时间戳。记录文档修改或添加的具体时间。  &lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;Object&lt;/td&gt;&lt;td&gt;用于内嵌文档。  &lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;Null&lt;/td&gt;&lt;td&gt;用于创建空值。  &lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;Symbol&lt;/td&gt;&lt;td&gt;符号。该数据类型基本上等同于字符串类型，但不同的是，它一般用于采用特殊符号类型的语言。&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;Date&lt;/td&gt;&lt;td&gt;日期时间。用 UNIX 时间格式来存储当前日期或时间。你可以指定自己的日期时间：创建 Date 对象，传入年月日信息。  &lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;Object ID&lt;/td&gt;&lt;td&gt;对象 ID。用于创建文档的 ID。  &lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;Binary Data&lt;/td&gt;&lt;td&gt;二进制数据。用于存储二进制数据。&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;Code&lt;/td&gt;&lt;td&gt;代码类型。用于在文档中存储 JavaScript 代码。&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;Regular expression&lt;/td&gt;&lt;td&gt;正则表达式类型。用于存储正则表达式。&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;更新某个字段的值&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;db.getCollection&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;participant&amp;#39;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;.find&lt;span class=&#34;o&#34;&gt;()&lt;/span&gt;.forEach&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;
   &lt;span class=&#34;k&#34;&gt;function&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;item&lt;span class=&#34;o&#34;&gt;){&lt;/span&gt;
       db.getCollection&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;participant&amp;#39;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;.update&lt;span class=&#34;o&#34;&gt;({&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;_id&amp;#34;&lt;/span&gt;:item._id&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;,&lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;$set&lt;/span&gt;:&lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;modifiTimes&amp;#34;&lt;/span&gt;: 2&lt;span class=&#34;o&#34;&gt;}})&lt;/span&gt;
   &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h2 id=&#34;golang的mongodb接口mgo&#34;&gt;Golang的MongoDB接口：mgo&lt;/h2&gt;
&lt;p&gt;简单的使用&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;kd&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;Person&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;Name&lt;/span&gt;  &lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;Phone&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;c1&#34;&gt;// mgo.Dial核心函数，由url新建一个session
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;nx&#34;&gt;session&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;mgo&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Dial&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;mongodb://127.0.0.1:27017/&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;nb&#34;&gt;panic&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;defer&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;session&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Close&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
	&lt;span class=&#34;c1&#34;&gt;// Optional. Switch the session to a monotonic behavior.
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;nx&#34;&gt;session&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;SetMode&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;mgo&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Monotonic&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;true&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
        &lt;span class=&#34;c1&#34;&gt;// c就连到了对应的collection
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;session&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;DB&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;test&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;).&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;C&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;people&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
        &lt;span class=&#34;c1&#34;&gt;// 插入数据
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Insert&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Person&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;Ale&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;+55 53 8116 9639&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;},&lt;/span&gt;
		&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Person&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;Cla&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;+55 53 8402 8510&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;})&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;log&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Fatal&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;result&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;Person&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{}&lt;/span&gt;
        &lt;span class=&#34;c1&#34;&gt;// result是一个查询结果
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Find&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;bson&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;M&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;name&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;Ale&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}).&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;One&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;result&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;log&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Fatal&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;fmt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Println&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;Phone:&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;result&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Phone&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;</content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://yichengme.site/categories/%E5%B7%A5%E7%A8%8B/" term="工程" label="工程" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://yichengme.site/tags/mongodb/" term="MongoDB" label="MongoDB" />
                            
                        
                            
                            
                            
                                <category scheme="https://yichengme.site/tags/database/" term="Database" label="Database" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">Django2&#43;nginx&#43;uwsgi&#43;Ubuntu部署记录</title>
            <link rel="alternate" type="text/html" href="https://yichengme.site/posts/django2&#43;nginx&#43;uwsgi&#43;ubuntu%E9%83%A8%E7%BD%B2%E8%AE%B0%E5%BD%95/" />
            <id>https://yichengme.site/posts/django2&#43;nginx&#43;uwsgi&#43;ubuntu%E9%83%A8%E7%BD%B2%E8%AE%B0%E5%BD%95/</id>
            <updated>2022-02-08T17:27:00&#43;08:00</updated>
            <published>2019-12-22T00:57:19&#43;08:00</published>
            <author>
                    <name>王毅诚</name>
                    <uri>https://yichengme.site/</uri>
                    <email>engine74396@gmail.com</email>
                    </author>
            <rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">Django项目写好了，最后一步就是部署(deployment)，部署十分关键，只有部署在服务器上，别人才能从互联网上通过ip地址或域名直接访问到你的网页。 第一……</summary>
            
                <content type="html">&lt;p&gt;Django项目写好了，最后一步就是部署(deployment)，部署十分关键，只有部署在服务器上，别人才能从互联网上通过ip地址或域名直接访问到你的网页。&lt;/p&gt;
&lt;p&gt;第一步是购买vps（Virtual Private Server 虚拟服务器），这个很简单而且网上教程一大把，这里就不详述，我在vultr购买的海外服务器，这样不用浪费时间去备案了，vultr的一大特色就是按时长收费，如果你的vps出了什么问题，可以随时关停，并且它还支持微信支付宝，价格也很便宜。
&lt;a href=&#34;https://www.vultr.com/?ref=7617179&#34;&gt; （vultr官网） &lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Django的本地预览十分方便，一行&lt;code&gt;python manage.py runserver&lt;/code&gt;就能搞定，但部署上线可没有这么简单。因为网上关于Django部署的教程都很杂乱，当时部署的时候就踩了很多很多坑，为了给之后一个参考，我又重新部署了一次，来记录详细的过程。&lt;/p&gt;
&lt;h2 id=&#34;相关软件版本&#34;&gt;相关软件版本：&lt;/h2&gt;
&lt;p&gt;Django 2.1.3
Python 3.6.6
nginx 1.14.0
uwsgi 2.0.17.1&lt;/p&gt;
&lt;p&gt;服务器：
Ubuntu-server 18.04&lt;/p&gt;
&lt;h2 id=&#34;准备工作&#34;&gt;准备工作&lt;/h2&gt;
&lt;p&gt;首先打开ssh软件，Xshell、Putty什么的都行，通过vultr上vps详情页上给的ip和root密码连接到这台vps。&lt;/p&gt;
&lt;p&gt;刚拿到的船新Linux，第一步先给它来个更新:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;sudo apt-get update
sudo apt-get upgrade
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;建议使用非root用户，部署时最好使用python虚拟环境，具体操作不是本文的重点，便不赘述了&lt;/p&gt;
&lt;p&gt;系统自带Python3.6、vim和git，所以不用装&lt;/p&gt;
&lt;p&gt;安装python3-pip、python3-setuptools、gcc、python3-dev、wheel：
（缺一不可，不然之后用pip安装uwsgi会有各种各样的报错）&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;sudo apt-get install python3-pip python-setuptools python3-dev wheel
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h2 id=&#34;放置django项目&#34;&gt;放置Django项目&lt;/h2&gt;
&lt;p&gt;直接在服务器端用vim什么的写Django当然可取（虽然会很酸爽），但更多的时候我们是在本地写好了Django项目，要把它挪到服务器上。&lt;/p&gt;
&lt;p&gt;在传输之前，要做一些工作：&lt;/p&gt;
&lt;p&gt;先更改一下&lt;code&gt;setting.py&lt;/code&gt;里的&lt;code&gt;ALLOWED_HOSTS&lt;/code&gt;，把服务器的ip加进去，有域名的话顺便把域名也加进去，要不然之后会无法加载Django项目&lt;/p&gt;
&lt;p&gt;在本地的Python虚拟环境上使用&lt;code&gt;pip freeze &amp;gt; requirements.txt&lt;/code&gt;,生成一个txt文件，里面是需要的Python库以及其版本，之后一并传给服务器&lt;/p&gt;
&lt;p&gt;传输文件到服务器的方法非常之多：可以使用Xshell自带的文件传输，也可以使用linux命令scp或安装更直观的lrzsz，或者使用本地的FileZilla、Winscp等软件，当然万能的git也很不错。&lt;/p&gt;
&lt;p&gt;不过考虑到之后这个web项目之后也要修改，用上面的方法感觉都不是特别方便，介绍一个非常好用的方法，那就是使用Pycharm自带的deployment功能，可以实现实时上传以及下载文件，很是方便。&lt;/p&gt;
&lt;p&gt;在&lt;code&gt;Tools&lt;/code&gt;-&amp;gt;&lt;code&gt;Deployment&lt;/code&gt;-&amp;gt;&lt;code&gt;Configuration&lt;/code&gt;中配置好与自己服务器的连接，IP地址、用户名、密码以及对应项目路径&lt;/p&gt;
&lt;center&gt;
&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1543389659/pycharm-deployment-1.jpg&#34; width=60%&gt;
&lt;/center&gt;
&lt;center&gt;
&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1543389659/pycharm-deployment-2.jpg&#34; width=60%&gt;
&lt;/center&gt;
&lt;p&gt;在&lt;code&gt;Settings&lt;/code&gt;-&amp;gt;&lt;code&gt;Project Interpreter&lt;/code&gt;里把项目解释器更改为服务器里的Python，mappings里填写两边项目的目录，再加一条&lt;code&gt;manage.py&lt;/code&gt;的映射&lt;/p&gt;
&lt;center&gt;
&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1543389660/pycharm-deployment-3.jpg&#34; width=60%&gt;
&lt;/center&gt;
&lt;p&gt;apply之后Pycharm右下角会出现上传进度条，会有点慢，喝杯茶等一段时间即可&lt;/p&gt;
&lt;p&gt;传输完毕后会发现本地的项目已经全部上传到服务器了&lt;/p&gt;
&lt;p&gt;但这个毕竟不是这篇文章的重点，不重点介绍，遇到了什么问题可以留言或者私信我。&lt;/p&gt;
&lt;p&gt;最后别忘了把&lt;code&gt;requirements.txt&lt;/code&gt;上传到服务器，用pycharm的话只要直接把文件拖进本地项目目录，Pycharm就会自动帮我们上传到服务器。&lt;/p&gt;
&lt;p&gt;在服务器上使用&lt;code&gt;pip install -r requirements.txt&lt;/code&gt;来安装必要的Python packages
&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&#34;安装与配置uwsgi&#34;&gt;安装与配置uwsgi&lt;/h2&gt;
&lt;p&gt;使用pip3安装uwsgi（注意是pip安装，不是apt-get，否则之后会各种报错）&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;pip3 install uwsgi
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;下面来试一下uwsgi是否好使：
找个位置新建一个py文件，就叫&lt;code&gt;uwsgi_test.py&lt;/code&gt;好了，然后用vim打开&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;touch uwsgi_test.py
vim uwsgi_test.py
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;写入以下内容：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-Python&#34; data-lang=&#34;Python&#34;&gt;&lt;span class=&#34;k&#34;&gt;def&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;application&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;env&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;start_response&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;start_response&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;200 OK&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[(&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;Content-Type&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;text/html&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)])&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;sa&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;Hello Uwsgi&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;wq保存退出（vim的基本操作不赘述，网上教程一大把）&lt;/p&gt;
&lt;p&gt;然后输入以下命令启动uwsgi，把这个部署到某个端口，以9090端口为例&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;uwsgi --http :9090 --wsgi-file uwsgi_test.py
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这时会出现&lt;code&gt;spawned uWSGI worker 1 (and the only) (pid: 11812, cores: 1) &lt;/code&gt;
找个浏览器，访问&lt;code&gt;http://&amp;lt;你的服务器ip&amp;gt;:9090/&lt;/code&gt;，不出意外的话你会看到Hello Uwsgi的字样，说明uwsgi能正常运行。&lt;/p&gt;
&lt;p&gt;在项目目录下新建&lt;code&gt;uwsgi.ini&lt;/code&gt;文件并编辑加入以下内容：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;uwsgi&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;# 直接访问uwsgi的端口号，绕过nginx&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;http&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;8010&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;# 转发给nginx的端口号&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;socket&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mf&#34;&gt;127.0.0.1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;8001&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;# 是否使用主线程&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;master&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;true&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;# 项目的绝对路径&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;chdir&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;var&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;www&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;PROJECT_NAME&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;/&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;# Django项目wsgi.py文件的相对路径&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;wsgi&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;file&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;PROJECT_NAME&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;wsgi&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;py&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;# 进程数&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;processes&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;4&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;# 每个进程的线程数&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;threads&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;# 监听端口&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;stats&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mf&#34;&gt;127.0.0.1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;9191&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;# 每次退出时是否清理环境配置&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;vacuum&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;true&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;# 目录中一旦有文件被改动就自动重启&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;touch&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;reload&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;var&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;www&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;my_site&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;# 存放日志&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;daemonize&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;var&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;www&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;my_site&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;uWSGI&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;log&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;[uwsgi]
# 直接访问uwsgi的端口号，绕过nginx
http = :8010
# 转发给nginx的端口号
socket = 127.0.0.1:8001
# 是否使用主线程
master = true
# 项目的绝对路径
chdir = /var/www/bangumi_project/
# Django项目wsgi.py文件的相对路径
wsgi-file = bangumi_project/wsgi.py
# 进程数
processes = 4
# 每个进程的线程数
threads = 2
# 监听端口
stats = 127.0.0.1:9191
# 每次退出时是否清理环境配置
vacuum = true
# 目录中一旦有文件被改动就自动重启
touch-reload = /var/www/bangumi_project
# 存放日志
daemonize = /var/www/bangumi_project/uWSGI.log
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;加入uwsgi.ini的目的是使让uwsgi对接Django项目的启动变得更简便，否则就得在终端敲很长的代码&lt;/p&gt;
&lt;p&gt;有了&lt;code&gt;uwsgi.ini&lt;/code&gt;我们只需要输入&lt;code&gt;uwsgi --ini uwsgi.ini&lt;/code&gt;就可以运行，浏览器输入ip地址加:8010端口（先绕过nginx因为还没配置呢），发现可以显示我们的项目了，这时css等静态文件可能没获取到，别急&lt;/p&gt;
&lt;h2 id=&#34;安装和配置nginx&#34;&gt;安装和配置nginx&lt;/h2&gt;
&lt;p&gt;先&lt;code&gt;sudo apt-get install nginx&lt;/code&gt;安装nginx，安装后nginx会自动启动，默认端口为80端口，浏览器输入ip地址加:80，可以看到&amp;quot;Welcome to nginx&amp;quot;的欢迎界面&lt;/p&gt;
&lt;p&gt;把/etc/nginx/目录下的&lt;code&gt;uwsgi_params&lt;/code&gt;复制到项目目录下，也可以直接项目目录下新建&lt;code&gt;uwsgi_params&lt;/code&gt;文件，写入以下内容：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;uwsgi_param  QUERY_STRING       &lt;span class=&#34;nv&#34;&gt;$query_string&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
uwsgi_param  REQUEST_METHOD     &lt;span class=&#34;nv&#34;&gt;$request_method&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
uwsgi_param  CONTENT_TYPE       &lt;span class=&#34;nv&#34;&gt;$content_type&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
uwsgi_param  CONTENT_LENGTH     &lt;span class=&#34;nv&#34;&gt;$content_length&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;

uwsgi_param  REQUEST_URI        &lt;span class=&#34;nv&#34;&gt;$request_uri&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
uwsgi_param  PATH_INFO          &lt;span class=&#34;nv&#34;&gt;$document_uri&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
uwsgi_param  DOCUMENT_ROOT      &lt;span class=&#34;nv&#34;&gt;$document_root&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
uwsgi_param  SERVER_PROTOCOL    &lt;span class=&#34;nv&#34;&gt;$server_protocol&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
uwsgi_param  REQUEST_SCHEME     &lt;span class=&#34;nv&#34;&gt;$scheme&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
uwsgi_param  HTTPS              &lt;span class=&#34;nv&#34;&gt;$https&lt;/span&gt; if_not_empty&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;

uwsgi_param  REMOTE_ADDR        &lt;span class=&#34;nv&#34;&gt;$remote_addr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
uwsgi_param  REMOTE_PORT        &lt;span class=&#34;nv&#34;&gt;$remote_port&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
uwsgi_param  SERVER_PORT        &lt;span class=&#34;nv&#34;&gt;$server_port&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
uwsgi_param  SERVER_NAME        &lt;span class=&#34;nv&#34;&gt;$server_name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;前往/etc/nginx/目录，查看&lt;code&gt;nginx.conf&lt;/code&gt;（nginx基础配置），发现里面有这么两行，意思就是包含conf.d文件夹中所有以conf后缀的配置和site-enabled文件夹中的内容&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;include /etc/nginx/conf.d/*.conf;
include /etc/nginx/sites-enabled/*;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;我们不更改nginx.conf基础配置，只需要修改&lt;code&gt;conf.d&lt;/code&gt;目录下的conf文件即可，进入&lt;code&gt;conf.d&lt;/code&gt;文件夹，修改&lt;code&gt;default.conf&lt;/code&gt;文件，没有的话就新建一个（还可以修改site-enabled/default或者sites-available/default，效果都一样的）&lt;/p&gt;
&lt;p&gt;然后写入以下内容：（务必根据自己的情况做相应更改）&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-nginx&#34; data-lang=&#34;nginx&#34;&gt;&lt;span class=&#34;k&#34;&gt;upstream&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;django&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
   &lt;span class=&#34;kn&#34;&gt;server&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;127.0.0.1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;8001&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;k&#34;&gt;server&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;# 监听端口，可改
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;kn&#34;&gt;listen&lt;/span&gt;       &lt;span class=&#34;mi&#34;&gt;80&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;# 修改为你的ip或者域名
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;kn&#34;&gt;server_name&lt;/span&gt;  &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;.2.3.4&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;# 编码方式
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;kn&#34;&gt;charset&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;utf-8&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;

    &lt;span class=&#34;c1&#34;&gt;# 日志记录，可选
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;kn&#34;&gt;access_log&lt;/span&gt;      &lt;span class=&#34;s&#34;&gt;/var/www/&amp;lt;PROJECT_NAME&amp;gt;/nginx_access.log&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;kn&#34;&gt;error_log&lt;/span&gt;       &lt;span class=&#34;s&#34;&gt;/var/www/&amp;lt;PROJECT_NAME&amp;gt;/nginx_error.log&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;

    &lt;span class=&#34;c1&#34;&gt;# 静态文件所在目录（自行修改）
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;kn&#34;&gt;location&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;/static&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;kn&#34;&gt;alias&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;/var/www/my_site/blog/static&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;# 媒体文件所在目录（自行修改）
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;#location /media  {
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;#    alias /home/www/djangotest/Hello/media; # 媒体文件所在文件夹
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;#}
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;kn&#34;&gt;location&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;/&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;kn&#34;&gt;include&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;/var/www/&amp;lt;PROJECT_NAME&amp;gt;/uwsgi_params&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
        &lt;span class=&#34;kn&#34;&gt;uwsgi_pass&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;django&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;运行&lt;code&gt;service nginx restart&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;如果报错&lt;code&gt;nginx.service failed because the control process exited with error code&lt;/code&gt;，那么运行一下&lt;code&gt;nginx -t -c /etc/nginx/nginx.conf&lt;/code&gt;，可以很容易的找到问题在哪。&lt;/p&gt;
&lt;p&gt;浏览器输入ip地址，如果发现看到的还是&amp;quot;Welcome to nginx&amp;quot;，这个是因为在&lt;code&gt;nginx.conf&lt;/code&gt;中还include了一个&lt;code&gt;sites-enabled/*&lt;/code&gt;，它覆盖了我们在&lt;code&gt;default.conf&lt;/code&gt;中的配置，可以干脆直接去&lt;code&gt;nginx.conf&lt;/code&gt;里把&lt;code&gt;include /etc/nginx/sites-enabled/*;&lt;/code&gt;这一行删掉，或者调换两行位置。
如果当时直接修改的sites-available或者sites-enabled中的default，就不会有这个问题&lt;/p&gt;
&lt;p&gt;这时再访问我们的ip，就能看到自己在本地搭建的Django项目了，因为在配置nginx的时候写入了static的路径，所以css什么的都加载进来了。&lt;/p&gt;
&lt;p&gt;至此nginx配置完毕&lt;/p&gt;
&lt;h2 id=&#34;后续工作&#34;&gt;后续工作&lt;/h2&gt;
&lt;p&gt;服务器上的Django还没有执行数据库迁移与管理员创建，所以记得执行&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;python manage.py makemigrations
python manage.py migrate
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;以及&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;python manage.py createsuperuser
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;每次有更新时都要重载uwsgi与nginx才能生效，为了方便uwsgi的重载，在项目目录下新建一个&lt;code&gt;uwsgi&lt;/code&gt;文件夹，然后在里面新建两个文件:&lt;code&gt;uwsgi.pid&lt;/code&gt;（用于重载停止等操作）和&lt;code&gt;uwsgi.status&lt;/code&gt;（用于查看状态）&lt;/p&gt;
&lt;p&gt;修改&lt;code&gt;uwsgi.ini&lt;/code&gt;，把原先的stats那行删掉，下面加上这两行：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;stats=%(chdir)/uwsgi/uwsgi.status
pidfile=%(chdir)/uwsgi/uwsgi.pid
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这样如果项目有更新，就可以使用这两个命令来分别重载uwsgi和nginx了&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;uwsgi --reload uwsgi/uwsgi.pid
systemctl reload nginx.service
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;至此我们的Django项目就部署完成了&lt;/p&gt;
</content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://yichengme.site/categories/%E5%B7%A5%E7%A8%8B/" term="工程" label="工程" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://yichengme.site/tags/django/" term="Django" label="Django" />
                            
                        
                            
                            
                            
                                <category scheme="https://yichengme.site/tags/linux/" term="Linux" label="Linux" />
                            
                        
                            
                            
                            
                                <category scheme="https://yichengme.site/tags/nginx/" term="nginx" label="nginx" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">mac软件推荐</title>
            <link rel="alternate" type="text/html" href="https://yichengme.site/posts/mac-software-recommend/" />
            <id>https://yichengme.site/posts/mac-software-recommend/</id>
            <updated>2022-02-12T21:14:52&#43;08:00</updated>
            <published>2019-11-10T15:38:07&#43;08:00</published>
            <author>
                    <name>王毅诚</name>
                    <uri>https://yichengme.site/</uri>
                    <email>engine74396@gmail.com</email>
                    </author>
            <rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">注：以下软件或组件只是自我记录，因为是颜控，所以包含大量主观感情色彩 本篇不含软件资源，如果有需要建议去官网购买正版 多图预警！！！流量党请慎重 科研篇 Xmind 最好用的思维……</summary>
            
                <content type="html">&lt;p&gt;注：以下软件或组件只是自我记录，因为是颜控，所以包含大量主观感情色彩&lt;/p&gt;
&lt;p&gt;本篇不含软件资源，如果有需要建议去官网购买正版&lt;/p&gt;
&lt;p&gt;多图预警！！！流量党请慎重&lt;/p&gt;
&lt;h2 id=&#34;科研篇&#34;&gt;科研篇&lt;/h2&gt;
&lt;h3 id=&#34;xmind&#34;&gt;Xmind&lt;/h3&gt;
&lt;p&gt;最好用的思维导图软件，做出来的图很漂亮。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1641893834/xmind-1.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;如果想放在ppt里，不要直接导出png图片，而应该导出为svg，然后拖进ppt。如果采用放大加平滑会有更好的演示效果。&lt;/p&gt;
&lt;h3 id=&#34;ivysci&#34;&gt;IvySci&lt;/h3&gt;
&lt;p&gt;青藤学术，论文管理软件，功能丰富，支持多端登录，比如论文管理、框选翻译、自动显示引用、笔记记录等等，比老牌的那几个论文管理软件好用。ReadPaper也不错，就是刚起步bug还比较多。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1641872960/IvySci-1.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;mathpix-snip&#34;&gt;Mathpix Snip&lt;/h3&gt;
&lt;p&gt;区域截图，通过Ai识别返回Latex语法，每个月有免费的次数，不过还是够用的，神器&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1641872960/mathpix-1.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;更新：别拿它图片做图床，过段时间后会被清理，当时图省事直接用它的图床，没保存到本地，笔记里的好几十张图片都没了 o(╥﹏╥)o&lt;/p&gt;
&lt;p&gt;图床，我推荐cloudinary&lt;/p&gt;
&lt;h3 id=&#34;texpad&#34;&gt;Texpad&lt;/h3&gt;
&lt;p&gt;mac平台上最好用颜值最高的Latex编辑器，可以自动同步编译，当然云端的Overleaf也不错（如果网好的话）&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1641872968/texpad-1.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;生活篇&#34;&gt;生活篇&lt;/h2&gt;
&lt;h3 id=&#34;cleanmymac-x&#34;&gt;CleanMyMac X&lt;/h3&gt;
&lt;p&gt;界面极其优雅，功能强大的Mac清理软件&lt;/p&gt;
&lt;p&gt;这个软件的易用性、外观和音效颠覆了我对清理类软件的看法，用起来很舒服，比win平台的某些流氓管家不知道高到哪里去了&lt;/p&gt;
&lt;center&gt;
&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1551701107/yicheng.me%20Blog/Screen_Shot_2019-02-22_at_3.29.35_PM.png&#34; width=80%&gt;
&lt;/center&gt;
&lt;h3 id=&#34;fantastical-2&#34;&gt;Fantastical 2&lt;/h3&gt;
&lt;p&gt;想找个同步Google Calendar事件的Mac端日历，最后找到了找个。界面优雅且功能强大的日历应用，曾获年度设计奖，比默认日历多了很多功能，能绑定Google Calendar和Apple日历事件，在菜单栏显示，非常方便。&lt;/p&gt;
&lt;center&gt;
&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1551701106/yicheng.me%20Blog/Screen_Shot_2019-02-22_at_3.25.36_PM.png&#34; width=80%&gt;
&lt;/center&gt;
&lt;h3 id=&#34;network--battery&#34;&gt;Network &amp;amp; Battery&lt;/h3&gt;
&lt;p&gt;最好看的网速菜单栏显示软件，试了就知道&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1641872968/network-and-battery-1.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;网易云音乐spotify在线音乐流媒体&#34;&gt;网易云音乐、Spotify（在线音乐流媒体）&lt;/h3&gt;
&lt;p&gt;可能对我这种找歌靠日推而不是靠歌手的人而言，不粉任何当红歌星，就听听acg、纯音乐什么的，版权基本对我没有影响。相比国内其他音乐软件而言，网易云的界面是最耐看的，日推算法很准确，评论氛围也不错。&lt;/p&gt;
&lt;p&gt;后来接触到了spotify之后就和Spotify结合着用，Spotify的推荐算法很强，多平台播放同步和支持Google home也很酸爽。&lt;/p&gt;
&lt;p&gt;更新：这两年网易云的版权越来越少了，杂七杂八的东西也多了起来，Spotify版权更差，而且大多数没有歌词，后面基本都是本地听无损了。当然网易云可以通过代理的方法从其他地方获取灰掉的歌，只是不太方便。&lt;/p&gt;
&lt;h3 id=&#34;audirvana-plus本地无损音乐播放器&#34;&gt;Audirvana Plus（本地无损音乐播放器）&lt;/h3&gt;
&lt;p&gt;本地无损音乐播放器，墙裂推荐，听起来确实和其他音乐软件的音效不一样，就不只是听个响了，配合wav、ape等无损格式食用更佳（如1G多的加州旅馆）&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1641872958/Audirvana-1.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;hidden-bar&#34;&gt;Hidden Bar&lt;/h3&gt;
&lt;p&gt;开源的菜单栏隐藏工具，可以帮助右上方的菜单栏变得干净。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1641872959/hidden-bar-1.gif&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;fe-file-explorer&#34;&gt;FE File Explorer&lt;/h3&gt;
&lt;p&gt;文件管理、nas连接都很方便&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1641872968/fe-file-explorer-1.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;iina&#34;&gt;IINA&lt;/h3&gt;
&lt;p&gt;mac下很好用的一款开源的颜值很高的视频播放器&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1641872960/IINA-1.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;uniconverter&#34;&gt;UniConverter&lt;/h3&gt;
&lt;p&gt;万兴的文件格式转换软件（万兴真的是国产软件的清流），支持超多格式，界面干净，非常好用。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1641894992/uniconverter-1.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;pdf-expertpdfelement&#34;&gt;PDF Expert、Pdfelement&lt;/h3&gt;
&lt;p&gt;前者是轻量的pdf阅读软件，响应速度非常快。后者是万兴的pdf软件，功能很强大，经常拿它转换一些pdf，让它们的文字可以被搜索到。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1641894993/pdf-expert-1.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;shadowsocksx-ngclashx&#34;&gt;ShadowsocksX-NG、ClashX&lt;/h3&gt;
&lt;p&gt;某科学的上网方法，节点不建议自己撘，还是找个靠谱的服务商比较好，一个月几十块钱，国内程序员、搞学术的必需品。就不细说了。&lt;/p&gt;
&lt;h3 id=&#34;dropbox&#34;&gt;Dropbox&lt;/h3&gt;
&lt;p&gt;赫赫有名的同步云盘，和国内云盘的理念不同，dropbox只是纯粹的做同步和备份工作，不限速，多平台同步、国外支持云盘导入导出的软件基本都支持dropbox，唯一的缺点就是初始空间只有2G，之后可以做任务攒到18G左右（可以去淘宝买），订阅的话很贵，但是体验是真的舒服。我是配合NAS一起食用NAS放大文件（如视频），dropbox储存一些重要的小文件（如笔记、代码）。&lt;/p&gt;
&lt;p&gt;Dropbox的历史文档自动存储救了我好几次，好用到哭泣。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1641894992/dropbox-1.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;telegram&#34;&gt;Telegram&lt;/h3&gt;
&lt;p&gt;优雅的聊天应用，Mac/Win/Android/ios全平台推荐，聊天信息完全加密，（因为不透露用户隐私，tg在老家毛子那都被墙了），另外全平台传文件非常好用，吊打QQ，因为大家都懂的原因，国内用的人确实不是很多，和QQ互补着用挺好，微信就算了吧，文件太拉胯了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1641894992/telegram-1.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;paste&#34;&gt;Paste&lt;/h3&gt;
&lt;p&gt;很方便的复制粘贴工具，可以记录历史复制的内容，提高效率&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1644157207/paste-1.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;downie4allavsoft&#34;&gt;Downie4、Allavsoft&lt;/h3&gt;
&lt;p&gt;都是很好用的视频下载器，可以下载很多网站的视频，比如Bilibili、Youtube等等&lt;/p&gt;
&lt;h3 id=&#34;parallels-desktop&#34;&gt;Parallels Desktop&lt;/h3&gt;
&lt;p&gt;macOS下的最强虚拟机软件，不过说实话，真不建议用mac开虚拟机，太浪费了，有win需求的话建议再买一台win。&lt;/p&gt;
&lt;h2 id=&#34;程序猿篇&#34;&gt;程序猿篇&lt;/h2&gt;
&lt;h3 id=&#34;jetbrains全家桶&#34;&gt;Jetbrains全家桶&lt;/h3&gt;
&lt;p&gt;Pycharm、Idea、WEbstorm、Goland、Clion、Android Studio&lt;/p&gt;
&lt;p&gt;（Jetbrains家的ide，用过的都说好）&lt;/p&gt;
&lt;p&gt;xcode只有做ios、mac app开发的时候的挺好，毕竟垄断了，Visual Studio for mac用起来有点怪，还是乖乖的在win下用宇宙第一IDE吧。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1641894992/jetbrains-1.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;atomvs-code&#34;&gt;Atom/VS Code&lt;/h3&gt;
&lt;p&gt;最开始选的Atom，中途无数次尝试VS Code（毕竟推荐的人很多），但是最后还是选择了Atom，性能确实不如vs code，但也没有感到明显的延迟（插件十来个也是秒开）。&lt;/p&gt;
&lt;p&gt;用的是material ui的darker配色，比较耐看。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1549894263/E8F0C761-0FF4-4739-BFFB-62126E855D78_.png.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;Atom：99分的界面+70分的性能&lt;/p&gt;
&lt;p&gt;VS code：90分的界面+99分的性能&lt;/p&gt;
&lt;p&gt;颜控当然是选择Atom了&lt;/p&gt;
&lt;h3 id=&#34;transmit&#34;&gt;Transmit&lt;/h3&gt;
&lt;p&gt;图形化的ftp软件，在mac与远程服务器之间传输数据，很好用&lt;/p&gt;
&lt;h3 id=&#34;startuml&#34;&gt;StartUML&lt;/h3&gt;
&lt;p&gt;UML分析设计应用，画UML图还不错，虽然有些方面很糟心（比如复制什么的），但是好像找不出更能打的软件了。&lt;/p&gt;
&lt;h3 id=&#34;navicat&#34;&gt;Navicat&lt;/h3&gt;
&lt;p&gt;数据库管理软件，比命令行直观多了&lt;/p&gt;
&lt;h3 id=&#34;postman&#34;&gt;Postman&lt;/h3&gt;
&lt;p&gt;大名鼎鼎的api调试神器，CRUD程序猿必备&lt;/p&gt;
&lt;h3 id=&#34;iterm2&#34;&gt;iTerm2&lt;/h3&gt;
&lt;p&gt;代替自带终端bash的神器，自定义很丰富。&lt;/p&gt;
&lt;h2 id=&#34;命令行组件&#34;&gt;命令行组件&lt;/h2&gt;
&lt;h3 id=&#34;homebrew必装&#34;&gt;HomeBrew（必装）&lt;/h3&gt;
&lt;p&gt;Mac中类似linux的包管理工具，神器&lt;/p&gt;
&lt;p&gt;安装Xcode命令行工具：&lt;code&gt;xcode-select --install&lt;/code&gt;
安装HomeBrew：&lt;code&gt;/usr/bin/ruby -e &amp;quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&amp;quot;&lt;/code&gt;
等待即可，如果连不上可能是wall的原因&lt;/p&gt;
&lt;h3 id=&#34;pythongitnode&#34;&gt;python、git、node...&lt;/h3&gt;
&lt;p&gt;这类必装组件太多了，就不单独提了&lt;/p&gt;
&lt;h3 id=&#34;oh-my-zsh&#34;&gt;oh-my-zsh&lt;/h3&gt;
&lt;p&gt;下载zsh
&lt;code&gt;brew install zsh&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;设置为默认shell
&lt;code&gt;sudo sh -c &amp;quot;echo /usr/local/bin/zsh &amp;gt;&amp;gt; /etc/shells&amp;quot;&lt;/code&gt;
&lt;code&gt;chsh -s /usr/local/bin/zsh&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;zsh进一步配置及美化可以上网搜寻一些文章，我用了一圈主题最后还是回到了zsh的原版主题&lt;/p&gt;
&lt;p&gt;功能很强大，这里不细谈了&lt;/p&gt;
&lt;h3 id=&#34;neofetch&#34;&gt;neofetch&lt;/h3&gt;
&lt;p&gt;显示ASCII形式的logo以及系统和硬件信息，很炫酷，华而不实hh&lt;/p&gt;
&lt;p&gt;安装只需要&lt;code&gt;brew install neofetch&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;使用只需要输入&lt;code&gt;neofetch&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1551701105/yicheng.me%20Blog/Screen_Shot_2019-02-21_at_6.23.13_PM.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;设计狮篇&#34;&gt;设计狮篇&lt;/h2&gt;
&lt;h3 id=&#34;adobe全家桶&#34;&gt;Adobe全家桶&lt;/h3&gt;
&lt;p&gt;PS、Pr、Ae、Au、Ai...不解释了，接触设计、多媒体的应该都会用到Adobe家的软件，Adobe在Mac平台下有加成。（而office在Mac下就是被削了）&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1641819661/adobe-1.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;sip&#34;&gt;Sip&lt;/h3&gt;
&lt;p&gt;屏幕取色器，可以取到屏幕任意位置的颜色数值，rgb、html格式都有，做ppt、PS和前端都很方便&lt;/p&gt;
&lt;h3 id=&#34;sketch&#34;&gt;Sketch&lt;/h3&gt;
&lt;p&gt;mac上最好用的矢量绘图软件，适合画概念图&lt;/p&gt;
&lt;p&gt;未完待续...&lt;/p&gt;
</content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://yichengme.site/categories/%E7%94%9F%E6%B4%BB/" term="生活" label="生活" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://yichengme.site/tags/macos/" term="macOS" label="macOS" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">Precision5510 黑苹果使用体验</title>
            <link rel="alternate" type="text/html" href="https://yichengme.site/posts/precision5510-hackintosh/" />
            <id>https://yichengme.site/posts/precision5510-hackintosh/</id>
            <updated>2022-02-12T21:01:13&#43;08:00</updated>
            <published>2019-09-05T14:33:07&#43;08:00</published>
            <author>
                    <name>王毅诚</name>
                    <uri>https://yichengme.site/</uri>
                    <email>engine74396@gmail.com</email>
                    </author>
            <rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">前年的时候，也就是17年年底，鉴于最低配的苏菲4性能比较羸弱，可怜的4G内存开个Chrome和Office就能吃满，分分钟卡爆，于是原来的电脑出掉了，准备更换一……</summary>
            
                <content type="html">&lt;p&gt;前年的时候，也就是17年年底，鉴于最低配的苏菲4性能比较羸弱，可怜的4G内存开个Chrome和Office就能吃满，分分钟卡爆，于是原来的电脑出掉了，准备更换一台高性能的电脑。&lt;/p&gt;
&lt;p&gt;当时还在原专业读土木，某些软件只有Windows才有，上mbp显然是没想过的，另外宿舍用台式机也比较麻烦，所以只能选Windows笔记本。&lt;/p&gt;
&lt;p&gt;预算其实并不是非常充足，但是内心有一种强烈的想法：买个配置够用的电脑多用几年。说实话五千块的电脑用三四年，真心不如一万的电脑用七八年。&lt;/p&gt;
&lt;p&gt;卡顿是对时间的浪费，崩溃是对心血的亵渎。&lt;/p&gt;
&lt;p&gt;一台电脑，配置固然是核心，但对我这种强迫症而言，工业设计也是一个重要因素。于是最后决定在XPS 15或者precision 5510中选择，它们的模具是一样的，主要区别在于其显卡和定位，前者是搭载游戏显卡，定位是超极本；后者搭载图形显卡，定位是移动图形工作站。&lt;/p&gt;
&lt;p&gt;因为不玩大型游戏，所以最后选择了海淘一款官翻的precision 5510移动图形工作站，虽然买的价格不到国行新机的一半，但还是非常高。最后咬咬牙还是买了，事实证明这台precision 5510确实值这个价。&lt;/p&gt;
&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1550418842/precision5510.jpg&#34; width=100%&gt;
&lt;p&gt;主要部件如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;intel i7 6820HQ 处理器&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;16GB 镁光 DDR4  内存条&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;SK hynix 512GB 固态硬盘&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;夏普 SHP1476 屏幕&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Nvidia Quadro M1000M 图形显卡&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Windows10 pro 系统&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;使用这台工作站，跑了一年多Windows，总的体验当然是很用得很舒服，基本没出现过卡顿的情况，除了Ae渲染时风扇会狂转，其他时候完全无压力啊。win10本身尤其是UWP应用对4k触摸屏还是比较友好的（除了Windows的遗留win7风格界面），但是一些比较老旧或者小众的软件根本没有适配4k，导致那些软件要么字体非常小，看瞎了，要么强行靠缩放来保持尺寸，导致图标和字体发虚严重。4k在windows下的体验只能打80分。&lt;/p&gt;
&lt;p&gt;最开始没想到要装黑苹果，只是偶然在B站看到了科技美学的XPS 15顶配黑苹果评测，瞬间被折服了:
&lt;a href=&#34;https://www.bilibili.com/video/av6079016&#34;&gt;「科技美学」戴尔XPS15顶配版体验测评 黑苹果系统安装&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;当海舟用手开始在屏幕上拖视频块来做FCP剪辑时，弹幕已经沸腾了，就算是顶配定制版MacBook Pro也没有触摸屏，不管原因是为了与ipad的交互区分开，以免造成产品线混淆（正常人理解）还是考虑到抬手触屏不方便 触控板万岁！（果粉理解）亦或只是为了节约屏幕成本 赚更多的钱（果黑理解），事实还是：mbp就是没有配置触摸屏。&lt;/p&gt;
&lt;p&gt;然而有趣的是，Mac OS系统和软件不仅支持高分辨率屏幕触摸操作，甚至比win10还支持的更好。&lt;/p&gt;
&lt;p&gt;前几天通过针大的教程&lt;a href=&#34;https://hyejeong.cn/hackintosh5510mojave&#34;&gt;Dell Precision 5510 Mojave Clover分享&lt;/a&gt;，花了两三天就比较顺利的装上了黑苹果，版本为Mojave 10.14.3，针大不仅写了很详细的教程和分享clover等文件，还通过私信解决了我的很多疑问，非常感激。如果有同样的precision5510想安装黑苹果的，可以去参考针大的这篇文章。&lt;/p&gt;
&lt;p&gt;因为一些软件只能在win上运行，因此装的是双系统，512GB的SSD给Mac OS分了320GB，给win10留了剩下的一百来G。&lt;/p&gt;
&lt;p&gt;下面对precision m5510 4k版黑苹果的各个方面做一个简单的小结，与mbp相比的优势与不足，以及黑苹果的完整程度：&lt;/p&gt;
&lt;h2 id=&#34;屏幕&#34;&gt;屏幕&lt;/h2&gt;
&lt;p&gt;MacBook Pro 15.4英寸的屏幕是 2880 x 1800 P3广色域 Retina视网膜屏
Precision5510 / XPS15 4k版的是 3840 x 2160 100%AdobeRGB UHD 康宁大猩猩玻璃触屏&lt;/p&gt;
&lt;p&gt;单论屏幕素质，Retina的校色更准确，观感更舒适，而Dell的镜面屏分辨率更高，观感更鲜艳。这两款屏幕的素质在笔记本中绝对都在第一梯队，是设计人员的福音，两款屏幕属于神仙打架。&lt;/p&gt;
&lt;p&gt;但有着触摸屏和Mac OS的加持，Precision 4k版本实现了mbp没有加入的触屏功能，感觉像是体验到了未来的mbp。&lt;/p&gt;
&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1550418841/photo_2019-02-17_23.40.37.jpg&#34; width=100%&gt;
&lt;h2 id=&#34;触控板&#34;&gt;触控板&lt;/h2&gt;
&lt;p&gt;mbp的触控板有目共睹，触感和手势交互甩了普通PC一条街，precision/xps的触控板在win本中属于很优秀的，说实话触感虽然和mac是两种感觉，但也十分不错，可喜的是在黑苹果中precision/xps也各种手势操作能够有效执行，比如三指上下划、五指缩放等等，虽然还有一些距离但已经有些接近mbp了。但是前者触控板做工任然有一些瑕疵，看到很多反馈是有一部分比例的x/p本触控板出现轻微的下凹或上凸。&lt;/p&gt;
&lt;p&gt;Mac可以不需要鼠标，只用触控板做大部分工作，但是我尝试了一下搭载Mac OS的5510，还是不能完全脱离鼠标。&lt;/p&gt;
&lt;h2 id=&#34;键盘&#34;&gt;键盘&lt;/h2&gt;
&lt;p&gt;precision/xps的键盘键程太短，说实话敲起来完全没有感觉，而且品控有的有些问题，我的两个Shift键都失灵了，扣下键帽也按不动就很难受，必须接着外接机械键盘，这样确实没问题而且敲得爽，但是外接键盘背来背去很不方便。&lt;/p&gt;
&lt;h2 id=&#34;续航&#34;&gt;续航&lt;/h2&gt;
&lt;p&gt;续航是4k版本的大短板，第一次使用这台电脑时，不插电两个小时后电脑就没电自动关机了，我的内心是绝望的。一方面是电池本身不足，另一方面是屏幕和显卡等（尤其是屏幕）耗电严重，我的这台5510就算开着屏幕什么软件也不运行，也就只能撑两个来小时；中大型软件开几个，80分钟内就能耗光全部电量。平常使用一直都得插着电，电脑要背走，充电器必须跟着，没有插座的地方完全不敢开机。&lt;/p&gt;
&lt;p&gt;也许是我的这台情况过于严重了，其他的4k屏5510可能要好一些，不过也好不到太多，续航确实是硬伤。&lt;/p&gt;
&lt;h2 id=&#34;相关驱动&#34;&gt;相关驱动&lt;/h2&gt;
&lt;p&gt;intel的网卡无法驱动，需要去某宝单独购买，拆机后自动识别和正常苹果没区别。丽台M1000M图形显卡无法驱动，不过i7 6820hq的集显就够用了，只要不玩大游戏就好说，设计软件无压力。其他的驱动基本都可以正常运行。&lt;/p&gt;
&lt;h3 id=&#34;总结&#34;&gt;总结&lt;/h3&gt;
&lt;p&gt;总的说来，precision 5000系列/XPS 15可能是win阵营中，最适合安装黑苹果的机器之一，尤其是4k版本，触摸屏的加持更是更够体验到Mac OS别样的功能，4k下Mac的体验也比win10强太多了。&lt;/p&gt;
&lt;p&gt;另外这个系列的模具工艺质量与工业设计很出色，也是PC本中少见的设计感与mbp有的一拼的产品。&lt;/p&gt;
&lt;p&gt;以上便是我的Precision 5510安装黑苹果后的使用体验，若有任何疑问或错误请联系我，谢谢。&lt;/p&gt;
&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1550418841/photo_2019-02-17_23.40.26.jpg&#34; width=100%&gt;
&lt;p&gt;两天时间陆陆续续装了一些应用上去（未完待续），下一篇不鸽的话会写Mac的应用推荐与资源分享，不见不散&lt;/p&gt;
</content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://yichengme.site/categories/%E7%94%9F%E6%B4%BB/" term="生活" label="生活" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://yichengme.site/tags/%E9%BB%91%E8%8B%B9%E6%9E%9C/" term="黑苹果" label="黑苹果" />
                            
                        
                            
                            
                            
                                <category scheme="https://yichengme.site/tags/%E6%8A%98%E8%85%BE/" term="折腾" label="折腾" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">Atom的Markdown配置与美化</title>
            <link rel="alternate" type="text/html" href="https://yichengme.site/posts/use-atom-as-an-elegant-markdown-editor/" />
            <id>https://yichengme.site/posts/use-atom-as-an-elegant-markdown-editor/</id>
            <updated>2022-02-08T17:27:00&#43;08:00</updated>
            <published>2019-03-22T16:12:25&#43;08:00</published>
            <author>
                    <name>王毅诚</name>
                    <uri>https://yichengme.site/</uri>
                    <email>engine74396@gmail.com</email>
                    </author>
            <rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">Atom介绍 Atom是一个Github出品的一个开源的免费文本编辑器，和VS Code、Sublime Text是对标产品。 Atom和VS Code一样，都是用Ele……</summary>
            
                <content type="html">&lt;h2 id=&#34;atom介绍&#34;&gt;Atom介绍&lt;/h2&gt;
&lt;p&gt;Atom是一个Github出品的一个开源的免费文本编辑器，和VS Code、Sublime Text是对标产品。&lt;/p&gt;
&lt;p&gt;Atom和VS Code一样，都是用Eletron构建的，插件也基本通用，可以认为是平替，我之所以用Atom主要还是因为其界面看上去更清爽，虽然性能比VS Code差，但是内存够大，实际体验也没有什么延迟。&lt;/p&gt;
&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1537506574/atom_1.png&#34; width=100%&gt;
&lt;p&gt;如果不清楚markdown的语法，可以访问 &lt;a href=&#34;https://www.markdownguide.org/basic-syntax/&#34;&gt;Markdown basics&lt;/a&gt;进行学习，markdown的语法和配置都非常简单，比$LaTeX$容易太多了。&lt;/p&gt;
&lt;p&gt;通过安装支持markdown插件就可以进行markdown的笔记写作，下面是一些我认为比较好的插件&lt;/p&gt;
&lt;h2 id=&#34;markdown-preview-enhanced&#34;&gt;Markdown Preview Enhanced&lt;/h2&gt;
&lt;p&gt;Atom有原生对markdown的支持，但是毕竟简陋，Markdown Preview Enhanced可以扩展更多的功能，比如公式、图床、导出等。&lt;/p&gt;
&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1544349042/Annotation_2018-12-09_175025.jpg&#34; width=&#34;90%&#34;&gt;
&lt;h2 id=&#34;material-ui&#34;&gt;Material UI&lt;/h2&gt;
&lt;p&gt;Material UI几乎是我所有编辑器的UI（包括Atom、VS Code、Jetbrains全家桶等），这套UI非常优雅和美观。&lt;/p&gt;
&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1544348243/Annotation_2018-12-09_173501.jpg&#34; width=&#34;90%&#34;&gt;
&lt;h2 id=&#34;title-bar-replacer-windows专用&#34;&gt;Title-bar-replacer (windows专用)&lt;/h2&gt;
&lt;p&gt;Title-bar-replacer可以隐藏掉windows上方比较唐突的白色标题栏，使软件更加一体化。&lt;/p&gt;
&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1544348538/Annotation_2018-12-09_174204.jpg&#34; width=&#34;90%&#34;&gt;
&lt;h2 id=&#34;markdown-table-editor&#34;&gt;Markdown-table-editor&lt;/h2&gt;
&lt;p&gt;Markdown语法写表格非常麻烦，markdown-table-editor可以使得我们在用写表格的时候更加方便，可以通过Tab、Enter等键快速排版&lt;/p&gt;
&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1544348803/Annotation_2018-12-09_174619.jpg&#34; width=&#34;90%&#34;&gt;
&lt;h3 id=&#34;其他的一些操作&#34;&gt;其他的一些操作&lt;/h3&gt;
&lt;h2 id=&#34;修改字体&#34;&gt;修改字体&lt;/h2&gt;
&lt;p&gt;修改软件界面字体，需要手动修改&lt;code&gt;styles.less&lt;/code&gt;，通过&lt;code&gt;File&lt;/code&gt;-&amp;gt;&lt;code&gt;stylesheet&lt;/code&gt;来打开它&lt;/p&gt;
&lt;p&gt;修改字体的属性：&lt;code&gt;atom-text-editor&lt;/code&gt;, 我最喜欢的代码字体是&lt;code&gt;Fira Code&lt;/code&gt;, 需要在本地电脑先安装&lt;a href=&#34;https://github.com/tonsky/FiraCode&#34;&gt;Fira Code&lt;/a&gt;，然后修改为：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-CSS&#34; data-lang=&#34;CSS&#34;&gt;&lt;span class=&#34;nt&#34;&gt;atom-text-editor&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;n&#34;&gt;text-rendering&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;optimizeLegibility&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
  &lt;span class=&#34;kp&#34;&gt;-webkit-&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;font-smoothing&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;antialiased&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
  &lt;span class=&#34;k&#34;&gt;font-family&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;Fira Code&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
  &lt;span class=&#34;k&#34;&gt;font-weight&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;500&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
  &lt;span class=&#34;k&#34;&gt;line-height&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;mf&#34;&gt;1.7&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;nt&#34;&gt;atom-text-editor&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nc&#34;&gt;editor&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;err&#34;&gt;.syntax--storage.syntax--type.syntax--function.syntax--arrow,&lt;/span&gt;
  &lt;span class=&#34;err&#34;&gt;.syntax--keyword.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;syntax--operator&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;not&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;accessor&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt;
  &lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;syntax--punctuation&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;syntax--definition&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;font-family&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;Fira Code&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
  &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

  &lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nc&#34;&gt;syntax--string&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nc&#34;&gt;syntax--quoted&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt;
  &lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nc&#34;&gt;syntax--string&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nc&#34;&gt;syntax--regexp&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;kp&#34;&gt;-webkit-&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;font-feature-settings&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;liga&amp;#34;&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;off&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;calt&amp;#34;&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;off&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
  &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;err&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;如果要修改markdown右侧预览窗口的字体，则需要去markdown-preview-enhanced的theme里修改css。具体的路径为：&lt;/p&gt;
&lt;p&gt;Windows通常在&lt;/p&gt;
&lt;p&gt;&lt;code&gt;C:\Users\&amp;lt;USER&amp;gt;\.atom\packages\markdown-preview-enhanced\node_modules\@shd101wyy\mume\styles\preview_theme&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;macOS通常在&lt;/p&gt;
&lt;p&gt;&lt;code&gt;/Users/&amp;lt;USER&amp;gt;/.atom/packages/markdown-preview-enhanced/node_modules/@shd101wyy/mume/styles/preview_theme&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;选择目前使用的markdown预览样式的css文件，通常是github-light。&lt;/p&gt;
&lt;p&gt;打开这个css，然后修改诸如字体等属性：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-css&#34; data-lang=&#34;css&#34;&gt;&lt;span class=&#34;nt&#34;&gt;html&lt;/span&gt; &lt;span class=&#34;nt&#34;&gt;body&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;k&#34;&gt;font-family&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;Fira Code&amp;#34;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;...&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;最后的样式：&lt;/p&gt;
&lt;p&gt;Windows:&lt;/p&gt;
&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1549894263/E8F0C761-0FF4-4739-BFFB-62126E855D78_.png.jpg&#34; width=100%&gt;
&lt;p&gt;MacOS:&lt;/p&gt;
&lt;img src=&#34;https://res.cloudinary.com/dbmkzs2ez/image/upload/v1585187085/aNa4CHec.png&#34; width=&#34;100%&#34;&gt;
</content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://yichengme.site/categories/%E7%94%9F%E6%B4%BB/" term="生活" label="生活" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://yichengme.site/tags/atom/" term="Atom" label="Atom" />
                            
                        
                            
                            
                            
                                <category scheme="https://yichengme.site/tags/markdown/" term="markdown" label="markdown" />
                            
                        
                            
                            
                            
                                <category scheme="https://yichengme.site/tags/%E7%BE%8E%E5%8C%96/" term="美化" label="美化" />
                            
                        
                    
                
            
        </entry>
    
</feed>
